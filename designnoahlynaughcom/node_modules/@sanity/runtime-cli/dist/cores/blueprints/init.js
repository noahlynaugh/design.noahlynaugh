import { join } from 'node:path';
import { cwd } from 'node:process';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { BLUEPRINT_CONFIG_FILE, BLUEPRINT_DIR, findBlueprintFile, writeBlueprintToDisk, writeConfigFile, writeGitignoreFile, writeOrUpdateNodeDependency, } from '../../actions/blueprints/blueprint.js';
import { createEmptyStack, getStack } from '../../actions/blueprints/stacks.js';
import { getProject } from '../../actions/sanity/projects.js';
import { check, warn } from '../../utils/display/presenters.js';
import { promptForProject, promptForStackId } from '../../utils/display/prompt.js';
const LAUNCH_LIMIT_STACK_PER_PROJECT = true;
export async function blueprintInitCore(options) {
    const { bin = 'sanity', log, token, args, flags } = options;
    try {
        const { 'blueprint-type': flagBlueprintType, 'project-id': flagProjectId, 'stack-id': flagStackId, 'stack-name': flagStackName, dir: flagDir, } = flags;
        const { dir: argDir } = args;
        const providedDir = argDir || flagDir;
        const here = cwd();
        const dir = argDir || flagDir || here;
        const existingBlueprint = findBlueprintFile(dir);
        if (existingBlueprint) {
            return { success: false, error: 'Existing Blueprint found.' };
        }
        const blueprintExtension = flagBlueprintType || (await promptForBlueprintType());
        if (!blueprintExtension) {
            return { success: false, error: 'Blueprint type is required.' };
        }
        let projectId = flagProjectId;
        let stackId = flagStackId;
        if (!projectId) {
            const pickedProject = await promptForProject({ token });
            projectId = pickedProject.projectId;
        }
        log('');
        if (flagStackName) {
            // using --stack-name gets around "LAUNCH LIMIT: 1 Stack per Project"
            const stack = await createEmptyStack({
                token,
                projectId,
                name: flagStackName,
                projectBased: false,
            });
            stackId = stack.id;
        }
        const auth = { token: token, projectId };
        if (!stackId) {
            // LAUNCH LIMIT: 1 Stack per Project - do not prompt for Stack, just create one
            if (LAUNCH_LIMIT_STACK_PER_PROJECT) {
                await createProjectBasedStack(auth, token, log);
                // do not set stackId, to avoid saving it to the config file
            }
            else {
                stackId = await promptForStackId({ projectId, token });
            }
        }
        const fileName = `sanity.blueprint.${blueprintExtension}`;
        const filePath = join(dir, fileName);
        writeBlueprintToDisk({ blueprintFilePath: filePath });
        if (providedDir)
            log(check(`${chalk.bold('New folder created:')}  ${providedDir}/`));
        log(check(`${chalk.bold('Created Blueprint:')}   ${providedDir ?? '.'}/${fileName}`));
        writeConfigFile({ blueprintFilePath: filePath, projectId, stackId });
        log(check(`${chalk.bold('Added configuration:')} ${providedDir ?? '.'}/${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`));
        writeGitignoreFile({ blueprintFilePath: filePath });
        log(check(`${chalk.bold('Added .gitignore:')}    ${providedDir ?? '.'}/.gitignore`));
        if (blueprintExtension !== 'json') {
            try {
                // check for || create package.json and add @sanity/blueprints to dependencies
                await writeOrUpdateNodeDependency({
                    blueprintFilePath: filePath,
                    dependency: '@sanity/blueprints',
                });
                log(check(`${chalk.bold('Added dependency:')}    @sanity/blueprints`));
            }
            catch (err) {
                log(warn('Unable to add @sanity/blueprints to your project.'));
            }
        }
        const nextStepParts = [];
        if (providedDir)
            nextStepParts.push(`cd ./${providedDir}`);
        if (blueprintExtension !== 'json')
            nextStepParts.push('npm install');
        nextStepParts.push(`${bin} blueprints --help`);
        const nextStep = `Run ${chalk.bold.magenta(nextStepParts.join(' && '))}`;
        log(`\n  ${nextStep} to get started`);
        return { success: true };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
async function promptForBlueprintType() {
    const { pickedBlueprintsType } = await inquirer.prompt([
        {
            type: 'list',
            name: 'pickedBlueprintsType',
            message: 'Choose a Blueprint file type:',
            choices: [
                { name: 'TypeScript', value: 'ts' },
                { name: 'JavaScript', value: 'js' },
                { name: 'JSON', value: 'json' },
            ],
            default: 'ts',
        },
    ]);
    return pickedBlueprintsType;
}
// LAUNCH LIMIT: 1 Stack per Project - create exclusive stack for project
async function createProjectBasedStack(auth, token, log) {
    const { projectId } = auth;
    // get project
    const { ok: projectOk, project } = await getProject(auth);
    if (!projectOk) {
        throw new Error('Failed to find Project while creating Stack');
    }
    const projectDisplayName = project.displayName;
    // check if project has a stack
    const inferredStackId = `ST-${projectId}`;
    const { stack: existingStack, ok: stackOk } = await getStack({ stackId: inferredStackId, auth });
    // if existing stack, return stack
    if (stackOk && existingStack) {
        log(warn(`"${projectDisplayName}" has an existing deployment.`));
        log(warn(`Deploying an empty Blueprint ${chalk.bold.red('will override the existing deployment!')}`));
        log('');
        return existingStack;
    }
    // if not, create a stack
    const stack = await createEmptyStack({
        token,
        projectId,
        name: projectDisplayName,
    });
    return stack;
}
