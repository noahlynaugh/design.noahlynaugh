{"version":3,"file":"index.js","sources":["../src/editor-event-listener.tsx","../src/internal-utils/debug.ts","../src/internal-utils/values.ts","../src/internal-utils/slate-utils.ts","../src/internal-utils/event-position.ts","../src/internal-utils/paths.ts","../src/internal-utils/ranges.ts","../src/internal-utils/selection.ts","../src/internal-utils/weakMaps.ts","../src/editor/editor-actor-context.ts","../src/editor/components/drop-indicator.tsx","../src/editor/components/render-default-object.tsx","../src/internal-utils/drag-selection.ts","../src/editor/key-generator.ts","../src/priority/priority.types.ts","../src/priority/priority.core.ts","../src/behaviors/behavior.core.block-element.ts","../src/editor/components/use-core-block-element-behaviors.ts","../src/editor/components/render-block-object.tsx","../src/editor/components/render-inline-object.tsx","../src/editor/components/render-text-block.tsx","../src/editor/components/render-element.tsx","../src/editor/hooks/usePortableTextEditor.ts","../src/internal-utils/stop-actor.ts","../src/converters/converter.json.ts","../src/converters/converter.portable-text.ts","../src/converters/converter.text-html.ts","../src/converters/converter.text-plain.ts","../src/converters/converters.core.ts","../src/internal-utils/schema.ts","../src/internal-utils/create-placeholder-block.ts","../src/editor/get-active-annotations.ts","../src/editor/get-active-decorators.ts","../src/operations/behavior.operation.insert.text.ts","../../../node_modules/.pnpm/@portabletext+toolkit@2.0.17/node_modules/@portabletext/toolkit/dist/index.js","../src/internal-utils/sibling-utils.ts","../src/internal-utils/withChanges.ts","../src/internal-utils/withUndoRedo.ts","../src/editor/editor-selector.ts","../src/editor/plugins/createWithPortableTextMarkModel.ts","../../../node_modules/.pnpm/@sanity+diff-match-patch@3.2.0/node_modules/@sanity/diff-match-patch/dist/index.js","../src/editor/with-undo-step.ts","../src/editor/plugins/createWithUndoRedo.ts","../src/operations/behavior.operation.annotation.add.ts","../src/operations/behavior.operation.annotation.remove.ts","../src/operations/behavior.operation.block.set.ts","../src/operations/behavior.operation.block.unset.ts","../src/operations/behavior.operation.decorator.add.ts","../src/operations/behavior.operation.delete.ts","../src/operations/behavior.operation.insert-inline-object.ts","../src/operations/behavior.operation.insert-span.ts","../src/operations/behavior.operation.insert.block.ts","../src/operations/behavior.operation.move.backward.ts","../src/operations/behavior.operation.move.block.ts","../src/operations/behavior.operation.move.forward.ts","../src/operations/behavior.operation.select.ts","../src/operations/behavior.operations.ts","../src/editor/with-applying-behavior-operations.ts","../src/editor/plugins/create-with-event-listeners.ts","../src/editor/plugins/createWithMaxBlocks.ts","../src/editor/plugins/createWithObjectKeys.ts","../src/internal-utils/applyPatch.ts","../src/internal-utils/operation-to-patches.ts","../src/internal-utils/withoutPatching.ts","../src/editor/plugins/createWithPatches.ts","../src/editor/plugins/createWithPlaceholderBlock.ts","../src/editor/plugins/createWithPortableTextBlockStyle.ts","../src/editor/plugins/createWithPortableTextSelections.ts","../src/editor/plugins/createWithSchemaTypes.ts","../src/editor/plugins/createWithUtils.ts","../src/internal-utils/mark-state.ts","../src/editor/plugins/slate-plugin.update-mark-state.ts","../src/internal-utils/portable-text-node.ts","../src/internal-utils/apply-operation-to-portable-text.ts","../src/editor/plugins/slate-plugin.update-value.ts","../src/editor/plugins/with-plugins.ts","../src/editor/create-slate-editor.tsx","../src/behaviors/behavior.core.annotations.ts","../src/internal-utils/is-hotkey.ts","../src/behaviors/behavior.core.block-objects.ts","../src/behaviors/behavior.core.decorators.ts","../src/internal-utils/compound-client-rect.ts","../src/behaviors/behavior.core.dnd.ts","../src/behaviors/behavior.core.insert-break.ts","../src/behaviors/behavior.core.lists.ts","../src/behaviors/behavior.core.ts","../src/internal-utils/selection-elements.ts","../src/behaviors/behavior.abstract.annotation.ts","../src/behaviors/behavior.abstract.decorator.ts","../src/behaviors/behavior.abstract.delete.ts","../src/behaviors/behavior.abstract.insert.ts","../src/internal-utils/key-is.ts","../src/behaviors/behavior.abstract.keyboard.ts","../src/behaviors/behavior.abstract.list-item.ts","../src/behaviors/behavior.abstract.move.ts","../src/behaviors/behavior.abstract.select.ts","../src/behaviors/behavior.abstract.split.ts","../src/behaviors/behavior.abstract.style.ts","../src/behaviors/behavior.abstract.ts","../src/behaviors/behavior.types.event.ts","../src/behaviors/behavior.perform-event.ts","../src/priority/priority.sort.ts","../src/editor/editor-snapshot.ts","../src/editor/editor-machine.ts","../src/editor/legacy-schema.ts","../src/editor/editor-schema.ts","../src/editor/mutation-machine.ts","../src/editor/plugins/createWithEditableAPI.ts","../src/editor/relay-machine.ts","../src/internal-utils/validateValue.ts","../src/editor/sync-machine.ts","../src/editor/create-editor.ts","../src/editor/hooks/usePortableTextEditorSelection.tsx","../src/editor/relay-actor-context.ts","../src/editor/route-events-to-changes.tsx","../src/editor/PortableTextEditor.tsx","../src/editor/components/render-span.tsx","../src/editor/components/render-leaf.tsx","../src/editor/components/render-text.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/range-decorations-machine.ts","../src/editor/Editable.tsx","../src/internal-utils/use-constant.ts","../src/editor/editor-provider.tsx"],"sourcesContent":["import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/relay-machine'\nimport {useEditor} from './editor/use-editor'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n","import debug from 'debug'\n\nconst rootName = 'sanity-pte:'\n\nexport default debug(rootName)\nexport function debugWithName(name: string): debug.Debugger {\n  const namespace = `${rootName}${name}`\n  if (debug && debug.enabled(namespace)) {\n    return debug(namespace)\n  }\n  return debug(rootName)\n}\n","import type {\n  PathSegment,\n  PortableTextBlock,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {Element, Text, type Descendant, type Node} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\n\nexport const EMPTY_MARKDEFS: PortableTextObject[] = []\n\nexport const VOID_CHILD_KEY = 'void-child'\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\nfunction keepObjectEquality(\n  object: PortableTextBlock | PortableTextChild,\n  keyMap: Record<string, PortableTextBlock | PortableTextChild>,\n) {\n  const value = keyMap[object._key]\n  if (value && isEqual(object, value)) {\n    return value\n  }\n  keyMap[object._key] = object\n  return object\n}\n\nexport function toSlateValue(\n  value: PortableTextBlock[] | undefined,\n  {schemaTypes}: {schemaTypes: EditorSchema},\n  keyMap: Record<string, any> = {},\n): Descendant[] {\n  if (value && Array.isArray(value)) {\n    return value.map((block) => {\n      const {_type, _key, ...rest} = block\n      const isPortableText = block && block._type === schemaTypes.block.name\n      if (isPortableText) {\n        const textBlock = block as PortableTextTextBlock\n        let hasInlines = false\n        const hasMissingStyle = typeof textBlock.style === 'undefined'\n        const hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined'\n        const hasMissingChildren = typeof textBlock.children === 'undefined'\n\n        const children = (textBlock.children || []).map((child) => {\n          const {_type: cType, _key: cKey, ...cRest} = child\n          // Return 'slate' version of inline object where the actual\n          // value is stored in the `value` property.\n          // In slate, inline objects are represented as regular\n          // children with actual text node in order to be able to\n          // be selected the same way as the rest of the (text) content.\n          if (cType !== 'span') {\n            hasInlines = true\n            return keepObjectEquality(\n              {\n                _type: cType,\n                _key: cKey,\n                children: [\n                  {\n                    _key: VOID_CHILD_KEY,\n                    _type: 'span',\n                    text: '',\n                    marks: [],\n                  },\n                ],\n                value: cRest,\n                __inline: true,\n              },\n              keyMap,\n            )\n          }\n          // Original child object (span)\n          return child\n        })\n        // Return original block\n        if (\n          !hasMissingStyle &&\n          !hasMissingMarkDefs &&\n          !hasMissingChildren &&\n          !hasInlines &&\n          Element.isElement(block)\n        ) {\n          // Original object\n          return block\n        }\n        // TODO: remove this when we have a better way to handle missing style\n        if (hasMissingStyle) {\n          rest.style = schemaTypes.styles[0].name\n        }\n        return keepObjectEquality({_type, _key, ...rest, children}, keyMap)\n      }\n      return keepObjectEquality(\n        {\n          _type,\n          _key,\n          children: [\n            {\n              _key: VOID_CHILD_KEY,\n              _type: 'span',\n              text: '',\n              marks: [],\n            },\n          ],\n          value: rest,\n        },\n        keyMap,\n      )\n    }) as Descendant[]\n  }\n  return []\n}\n\nexport function fromSlateValue(\n  value: Descendant[],\n  textBlockType: string,\n  keyMap: Record<string, PortableTextBlock | PortableTextChild> = {},\n): PortableTextBlock[] {\n  return value.map((block) => {\n    const {_key, _type} = block\n    if (!_key || !_type) {\n      throw new Error('Not a valid block')\n    }\n    if (\n      _type === textBlockType &&\n      'children' in block &&\n      Array.isArray(block.children) &&\n      _key\n    ) {\n      let hasInlines = false\n      const children = block.children.map((child) => {\n        const {_type: _cType} = child\n        if ('value' in child && _cType !== 'span') {\n          hasInlines = true\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child\n          return keepObjectEquality(\n            {...rest, ...v, _key: k as string, _type: t as string},\n            keyMap,\n          )\n        }\n        return child\n      })\n      if (!hasInlines) {\n        return block as PortableTextBlock // Original object\n      }\n      return keepObjectEquality(\n        {...block, children, _key, _type},\n        keyMap,\n      ) as PortableTextBlock\n    }\n    const blockValue = 'value' in block && block.value\n    return keepObjectEquality(\n      {_key, _type, ...(typeof blockValue === 'object' ? blockValue : {})},\n      keyMap,\n    ) as PortableTextBlock\n  })\n}\n\nexport function isEqualToEmptyEditor(\n  children: Descendant[] | PortableTextBlock[],\n  schemaTypes: EditorSchema,\n): boolean {\n  return (\n    children === undefined ||\n    (children && Array.isArray(children) && children.length === 0) ||\n    (children &&\n      Array.isArray(children) &&\n      children.length === 1 &&\n      Element.isElement(children[0]) &&\n      children[0]._type === schemaTypes.block.name &&\n      'style' in children[0] &&\n      children[0].style === schemaTypes.styles[0].name &&\n      !('listItem' in children[0]) &&\n      Array.isArray(children[0].children) &&\n      children[0].children.length === 1 &&\n      Text.isText(children[0].children[0]) &&\n      children[0].children[0]._type === 'span' &&\n      !children[0].children[0].marks?.join('') &&\n      children[0].children[0].text === '')\n  )\n}\n\nexport function findBlockAndIndexFromPath(\n  firstPathSegment: PathSegment,\n  children: (Node | Partial<Node>)[],\n): [Element | undefined, number | undefined] {\n  let blockIndex = -1\n  const isNumber = Number.isInteger(Number(firstPathSegment))\n  if (isNumber) {\n    blockIndex = Number(firstPathSegment)\n  } else if (children) {\n    blockIndex = children.findIndex(\n      (blk) =>\n        Element.isElement(blk) && isEqual({_key: blk._key}, firstPathSegment),\n    )\n  }\n  if (blockIndex > -1) {\n    return [children[blockIndex] as Element, blockIndex]\n  }\n  return [undefined, -1]\n}\n\nexport function findChildAndIndexFromPath(\n  secondPathSegment: PathSegment,\n  block: Element,\n): [Element | Text | undefined, number] {\n  let childIndex = -1\n  const isNumber = Number.isInteger(Number(secondPathSegment))\n  if (isNumber) {\n    childIndex = Number(secondPathSegment)\n  } else {\n    childIndex = block.children.findIndex((child) =>\n      isEqual({_key: child._key}, secondPathSegment),\n    )\n  }\n  if (childIndex > -1) {\n    return [block.children[childIndex] as Element | Text, childIndex]\n  }\n  return [undefined, -1]\n}\n\nexport function getValueOrInitialValue(\n  value: unknown,\n  initialValue: PortableTextBlock[],\n): PortableTextBlock[] | undefined {\n  if (value && Array.isArray(value) && value.length > 0) {\n    return value\n  }\n  return initialValue\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport {Editor, Element, Node, Range, type Path, type Point} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorSelection, PortableTextSlateEditor} from '../types/editor'\nimport {fromSlateValue} from './values'\n\nexport function getBlockPath({\n  editor,\n  _key,\n}: {\n  editor: PortableTextSlateEditor\n  _key: string\n}): [number] | undefined {\n  const [, blockPath] = Array.from(\n    Editor.nodes(editor, {\n      at: [],\n      match: (n) => n._key === _key,\n    }),\n  ).at(0) ?? [undefined, undefined]\n\n  const blockIndex = blockPath?.at(0)\n\n  if (blockIndex === undefined) {\n    return undefined\n  }\n\n  return [blockIndex]\n}\n\nexport function getAnchorBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (!editor.selection) {\n    return [undefined, undefined]\n  }\n\n  try {\n    return (\n      Editor.node(editor, editor.selection.anchor.path.slice(0, 1)) ?? [\n        undefined,\n        undefined,\n      ]\n    )\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getFocusBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (!editor.selection) {\n    return [undefined, undefined]\n  }\n\n  try {\n    return (\n      Editor.node(editor, editor.selection.focus.path.slice(0, 1)) ?? [\n        undefined,\n        undefined,\n      ]\n    )\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getFocusSpan({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: PortableTextSpan, path: Path] | [undefined, undefined] {\n  if (!editor.selection) {\n    return [undefined, undefined]\n  }\n\n  try {\n    const [node, path] = Editor.node(editor, editor.selection.focus.path)\n\n    if (editor.isTextSpan(node)) {\n      return [node, path]\n    }\n  } catch {\n    return [undefined, undefined]\n  }\n\n  return [undefined, undefined]\n}\n\nexport function getSelectedSpans({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): Array<[node: PortableTextSpan, path: Path]> {\n  if (!editor.selection) {\n    return []\n  }\n\n  try {\n    return Array.from(\n      Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextSpan(node),\n      }),\n    )\n  } catch {\n    return []\n  }\n}\n\nexport function getSelectionStartBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (!editor.selection) {\n    return [undefined, undefined]\n  }\n\n  const selectionStartPoint = Range.start(editor.selection)\n\n  return getPointBlock({editor, point: selectionStartPoint})\n}\n\nexport function getSelectionEndBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (!editor.selection) {\n    return [undefined, undefined]\n  }\n\n  const selectionEndPoint = Range.end(editor.selection)\n\n  return getPointBlock({editor, point: selectionEndPoint})\n}\n\nexport function getPointBlock({\n  editor,\n  point,\n}: {\n  editor: PortableTextSlateEditor\n  point: Point\n}): [node: Node, path: Path] | [undefined, undefined] {\n  try {\n    const [block] = Editor.node(editor, point.path.slice(0, 1)) ?? [\n      undefined,\n      undefined,\n    ]\n    return block ? [block, point.path.slice(0, 1)] : [undefined, undefined]\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getFocusChild({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  const [focusBlock, focusBlockPath] = getFocusBlock({editor})\n  const childIndex = editor.selection?.focus.path.at(1)\n\n  if (!focusBlock || !focusBlockPath || childIndex === undefined) {\n    return [undefined, undefined]\n  }\n\n  try {\n    const focusChild = Node.child(focusBlock, childIndex)\n\n    return focusChild\n      ? [focusChild, [...focusBlockPath, childIndex]]\n      : [undefined, undefined]\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nfunction getPointChild({\n  editor,\n  point,\n}: {\n  editor: PortableTextSlateEditor\n  point: Point\n}): [node: Node, path: Path] | [undefined, undefined] {\n  const [block, blockPath] = getPointBlock({editor, point})\n  const childIndex = point.path.at(1)\n\n  if (!block || !blockPath || childIndex === undefined) {\n    return [undefined, undefined]\n  }\n\n  try {\n    const pointChild = Node.child(block, childIndex)\n\n    return pointChild\n      ? [pointChild, [...blockPath, childIndex]]\n      : [undefined, undefined]\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getFirstBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (editor.children.length === 0) {\n    return [undefined, undefined]\n  }\n\n  const firstPoint = Editor.start(editor, [])\n  const firstBlockPath = firstPoint.path.at(0)\n\n  try {\n    return firstBlockPath !== undefined\n      ? (Editor.node(editor, [firstBlockPath]) ?? [undefined, undefined])\n      : [undefined, undefined]\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getLastBlock({\n  editor,\n}: {\n  editor: PortableTextSlateEditor\n}): [node: Node, path: Path] | [undefined, undefined] {\n  if (editor.children.length === 0) {\n    return [undefined, undefined]\n  }\n\n  const lastPoint = Editor.end(editor, [])\n  const lastBlockPath = lastPoint.path.at(0)\n\n  try {\n    return lastBlockPath !== undefined\n      ? (Editor.node(editor, [lastBlockPath]) ?? [undefined, undefined])\n      : [undefined, undefined]\n  } catch {\n    return [undefined, undefined]\n  }\n}\n\nexport function getNodeBlock({\n  editor,\n  schema,\n  node,\n}: {\n  editor: PortableTextSlateEditor\n  schema: EditorSchema\n  node: Node\n}) {\n  if (Editor.isEditor(node)) {\n    return undefined\n  }\n\n  if (isBlockElement({editor, schema}, node)) {\n    return elementToBlock({schema, element: node})\n  }\n\n  const parent = Array.from(\n    Editor.nodes(editor, {\n      mode: 'highest',\n      at: [],\n      match: (n) =>\n        isBlockElement({editor, schema}, n) &&\n        n.children.some((child) => child._key === node._key),\n    }),\n  )\n    .at(0)\n    ?.at(0)\n\n  return Element.isElement(parent)\n    ? elementToBlock({\n        schema,\n        element: parent,\n      })\n    : undefined\n}\n\nfunction elementToBlock({\n  schema,\n  element,\n}: {\n  schema: EditorSchema\n  element: Element\n}) {\n  return fromSlateValue([element], schema.block.name)?.at(0)\n}\n\nfunction isBlockElement(\n  {editor, schema}: {editor: PortableTextSlateEditor; schema: EditorSchema},\n  node: Node,\n): node is Element {\n  return (\n    Element.isElement(node) &&\n    !editor.isInline(node) &&\n    (schema.block.name === node._type ||\n      schema.blockObjects.some(\n        (blockObject) => blockObject.name === node._type,\n      ))\n  )\n}\n\nexport function isListItemActive({\n  editor,\n  listItem,\n}: {\n  editor: Editor\n  listItem: string\n}): boolean {\n  if (!editor.selection) {\n    return false\n  }\n\n  const selectedBlocks = [\n    ...Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    }),\n  ]\n\n  if (selectedBlocks.length > 0) {\n    return selectedBlocks.every(\n      ([node]) => editor.isListBlock(node) && node.listItem === listItem,\n    )\n  }\n\n  return false\n}\n\nexport function isStyleActive({\n  editor,\n  style,\n}: {\n  editor: Editor\n  style: string\n}): boolean {\n  if (!editor.selection) {\n    return false\n  }\n\n  const selectedBlocks = [\n    ...Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    }),\n  ]\n\n  if (selectedBlocks.length > 0) {\n    return selectedBlocks.every(([node]) => node.style === style)\n  }\n\n  return false\n}\n\nexport function slateRangeToSelection({\n  schema,\n  editor,\n  range,\n}: {\n  schema: EditorSchema\n  editor: PortableTextSlateEditor\n  range: Range\n}): EditorSelection {\n  const [anchorBlock] = getPointBlock({\n    editor,\n    point: range.anchor,\n  })\n  const [focusBlock] = getPointBlock({\n    editor,\n    point: range.focus,\n  })\n\n  if (!anchorBlock || !focusBlock) {\n    return null\n  }\n\n  const [anchorChild] =\n    anchorBlock._type === schema.block.name\n      ? getPointChild({\n          editor,\n          point: range.anchor,\n        })\n      : [undefined, undefined]\n  const [focusChild] =\n    focusBlock._type === schema.block.name\n      ? getPointChild({\n          editor,\n          point: range.focus,\n        })\n      : [undefined, undefined]\n\n  const selection: EditorSelection = {\n    anchor: {\n      path: [{_key: anchorBlock._key}],\n      offset: range.anchor.offset,\n    },\n    focus: {\n      path: [{_key: focusBlock._key}],\n      offset: range.focus.offset,\n    },\n    backward: Range.isBackward(range),\n  }\n\n  if (anchorChild) {\n    selection.anchor.path.push('children')\n    selection.anchor.path.push({_key: anchorChild._key})\n  }\n\n  if (focusChild) {\n    selection.focus.path.push('children')\n    selection.focus.path.push({_key: focusChild._key})\n  }\n\n  return selection\n}\n","import {Editor, type BaseRange, type Node} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport type {EditorSchema, EditorSelection} from '..'\nimport type {EditorActor} from '../editor/editor-machine'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {\n  getFirstBlock,\n  getLastBlock,\n  getNodeBlock,\n  slateRangeToSelection,\n} from './slate-utils'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  editorActor,\n  slateEditor,\n  event,\n}: {\n  editorActor: EditorActor\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPosition | undefined {\n  if (editorActor.getSnapshot().matches({setup: 'setting up'})) {\n    return undefined\n  }\n\n  const eventNode = getEventNode({slateEditor, event})\n\n  if (!eventNode) {\n    return undefined\n  }\n\n  const eventBlock = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node: eventNode,\n  })\n  const eventPositionBlock = getEventPositionBlock({\n    node: eventNode,\n    slateEditor,\n    event,\n  })\n  const eventSelection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event,\n  })\n\n  if (\n    eventBlock &&\n    eventPositionBlock &&\n    !eventSelection &&\n    !Editor.isEditor(eventNode)\n  ) {\n    // If we for some reason can't find the event selection, then we default to\n    // selecting the entire block that the event originates from.\n    return {\n      block: eventPositionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{_key: eventBlock._key}],\n          },\n        }),\n        focus: utils.getBlockEndPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{_key: eventBlock._key}],\n          },\n        }),\n      },\n    }\n  }\n\n  if (!eventPositionBlock || !eventSelection) {\n    return undefined\n  }\n\n  const eventSelectionFocusBlockKey = getBlockKeyFromSelectionPoint(\n    eventSelection.focus,\n  )\n\n  if (eventSelectionFocusBlockKey === undefined) {\n    return undefined\n  }\n\n  if (\n    utils.isSelectionCollapsed(eventSelection) &&\n    eventBlock &&\n    eventSelectionFocusBlockKey !== eventBlock._key\n  ) {\n    // If the event block and event selection somehow don't match, then the\n    // event block takes precedence.\n    return {\n      block: eventPositionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{_key: eventBlock._key}],\n          },\n        }),\n        focus: utils.getBlockEndPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{_key: eventBlock._key}],\n          },\n        }),\n      },\n    }\n  }\n\n  return {\n    block: eventPositionBlock,\n    isEditor: Editor.isEditor(eventNode),\n    selection: eventSelection,\n  }\n}\n\nexport function getEventNode({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}) {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  return node\n}\n\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event,\n}: {\n  node: Node\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  const [firstBlock] = getFirstBlock({editor: slateEditor})\n\n  if (!firstBlock) {\n    return undefined\n  }\n\n  const firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock)\n  const firstBlockRect = firstBlockElement.getBoundingClientRect()\n\n  if (event.pageY < firstBlockRect.top) {\n    return 'start'\n  }\n\n  const [lastBlock] = getLastBlock({editor: slateEditor})\n\n  if (!lastBlock) {\n    return undefined\n  }\n\n  const lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock)\n  const lastBlockRef = lastBlockElement.getBoundingClientRect()\n\n  if (event.pageY > lastBlockRef.bottom) {\n    return 'end'\n  }\n\n  const element = DOMEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nexport function getEventSelection({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? slateRangeToSelection({\n        schema,\n        editor: slateEditor,\n        range,\n      })\n    : null\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      try {\n        domRange = window.document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      } catch {}\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n","import {isKeySegment, type Path} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {Editor, Element, type Descendant, type Path as SlatePath} from 'slate'\n\nexport function toSlatePath(path: Path, editor: Editor): SlatePath {\n  if (!editor) {\n    return []\n  }\n  const [block, blockPath] = Array.from(\n    Editor.nodes(editor, {\n      at: [],\n      match: (n) =>\n        isKeySegment(path[0]) && (n as Descendant)._key === path[0]._key,\n    }),\n  )[0] || [undefined, undefined]\n\n  if (!block || !Element.isElement(block)) {\n    return []\n  }\n\n  if (editor.isVoid(block)) {\n    return [blockPath[0], 0]\n  }\n\n  const childPath = [path[2]]\n  const childIndex = block.children.findIndex((child) =>\n    isEqual([{_key: child._key}], childPath),\n  )\n\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex]\n    if (Element.isElement(child) && editor.isVoid(child)) {\n      return blockPath.concat(childIndex).concat(0)\n    }\n    return blockPath.concat(childIndex)\n  }\n\n  return [blockPath[0], 0]\n}\n","import {Point, type Editor, type Operation, type Range} from 'slate'\nimport type {EditorSelection} from '../types/editor'\nimport {toSlatePath} from './paths'\n\nexport interface ObjectWithKeyAndType {\n  _key: string\n  _type: string\n  children?: ObjectWithKeyAndType[]\n}\n\nexport function toSlateRange(\n  selection: EditorSelection,\n  editor: Editor,\n): Range | null {\n  if (!selection || !editor) {\n    return null\n  }\n  const anchor = {\n    path: toSlatePath(selection.anchor.path, editor),\n    offset: selection.anchor.offset,\n  }\n  const focus = {\n    path: toSlatePath(selection.focus.path, editor),\n    offset: selection.focus.offset,\n  }\n  if (focus.path.length === 0 || anchor.path.length === 0) {\n    return null\n  }\n  const range = anchor && focus ? {anchor, focus} : null\n  return range\n}\n\nexport function moveRangeByOperation(\n  range: Range,\n  operation: Operation,\n): Range | null {\n  const anchor = Point.transform(range.anchor, operation)\n  const focus = Point.transform(range.focus, operation)\n\n  if (anchor === null || focus === null) {\n    return null\n  }\n\n  if (Point.equals(anchor, range.anchor) && Point.equals(focus, range.focus)) {\n    return range\n  }\n\n  return {anchor, focus}\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import type {Editor, Range} from 'slate'\nimport type {EditorSelection} from '..'\n\n// Is the editor currently receiving remote changes that are being applied to the content?\nexport const IS_PROCESSING_REMOTE_CHANGES: WeakMap<Editor, boolean> =\n  new WeakMap()\n\nexport const KEY_TO_SLATE_ELEMENT: WeakMap<Editor, any | undefined> =\n  new WeakMap()\nexport const KEY_TO_VALUE_ELEMENT: WeakMap<Editor, any | undefined> =\n  new WeakMap()\n\n// Keep object relation to slate range in the portable-text-range\nexport const SLATE_TO_PORTABLE_TEXT_RANGE = new WeakMap<\n  Range,\n  EditorSelection\n>()\n","import {createContext} from 'react'\nimport type {EditorActor} from './editor-machine'\n\nexport const EditorActorContext = createContext<EditorActor>({} as EditorActor)\n","export function DropIndicator() {\n  return (\n    <div\n      contentEditable={false}\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    >\n      <span />\n    </div>\n  )\n}\n","import type {PortableTextChild, PortableTextObject} from '@sanity/types'\n\nexport function RenderDefaultBlockObject(props: {\n  blockObject: PortableTextObject\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.blockObject._type}: {props.blockObject._key}]\n    </div>\n  )\n}\n\nexport function RenderDefaultInlineObject(props: {\n  inlineObject: PortableTextObject | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.inlineObject._type}: {props.inlineObject._key}]\n    </span>\n  )\n}\n","import type {EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {EventPosition} from './event-position'\n\n/**\n * Given the current editor `snapshot` and an `eventSelection` representing\n * where the drag event origins from, this function calculates the selection\n * in the editor that should be dragged.\n */\nexport function getDragSelection({\n  eventSelection,\n  snapshot,\n}: {\n  eventSelection: EventPosition['selection']\n  snapshot: EditorSnapshot\n}) {\n  let dragSelection = eventSelection\n\n  const draggedInlineObject = selectors.getFocusInlineObject({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggedInlineObject) {\n    return dragSelection\n  }\n\n  const draggingCollapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggingCollapsedSelection && draggedTextBlock && draggedSpan) {\n    // Looks like we are dragging an empty span\n    // Let's drag the entire block instead\n    dragSelection = {\n      anchor: utils.getBlockStartPoint({\n        context: snapshot.context,\n        block: draggedTextBlock,\n      }),\n      focus: utils.getBlockEndPoint({\n        context: snapshot.context,\n        block: draggedTextBlock,\n      }),\n    }\n  }\n\n  const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n\n  if (\n    snapshot.context.selection &&\n    selectors.isSelectionExpanded(snapshot) &&\n    selectedBlocks.length > 1\n  ) {\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return dragSelection\n    }\n\n    const selectionStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block: selectionStartBlock,\n    })\n    const selectionEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block: selectionEndBlock,\n    })\n\n    const eventSelectionInsideBlocks = selectors.isOverlappingSelection(\n      eventSelection,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {anchor: selectionStartPoint, focus: selectionEndPoint},\n      },\n    })\n\n    if (eventSelectionInsideBlocks) {\n      dragSelection = {\n        anchor: selectionStartPoint,\n        focus: selectionEndPoint,\n      }\n    }\n  }\n\n  return dragSelection\n}\n","import getRandomValues from 'get-random-values-esm'\n\n/**\n * @public\n */\nexport const defaultKeyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {defaultKeyGenerator} from '../editor/key-generator'\n\nexport type EditorPriority = {\n  id: string\n  name?: string\n  reference?: {\n    priority: EditorPriority\n    importance: 'higher' | 'lower'\n  }\n}\n\nexport function createEditorPriority(config?: {\n  name?: string\n  reference?: {\n    priority: EditorPriority\n    importance: 'higher' | 'lower'\n  }\n}): EditorPriority {\n  return {\n    id: defaultKeyGenerator(),\n    name: config?.name,\n    reference: config?.reference,\n  }\n}\n","import {createEditorPriority} from './priority.types'\n\nexport const corePriority = createEditorPriority({name: 'core'})\n","import {getDragSelection} from '../internal-utils/drag-selection'\nimport type {EventPositionBlock} from '../internal-utils/event-position'\nimport {corePriority} from '../priority/priority.core'\nimport {createEditorPriority} from '../priority/priority.types'\nimport * as selectors from '../selectors'\nimport {forward} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport function createCoreBlockElementBehaviorsConfig({\n  key,\n  onSetDragPositionBlock,\n}: {\n  key: string\n  onSetDragPositionBlock: (\n    eventPositionBlock: EventPositionBlock | undefined,\n  ) => void\n}) {\n  return [\n    {\n      behavior: defineBehavior({\n        on: 'drag.dragover',\n        guard: ({snapshot, event}) => {\n          const dropFocusBlock = selectors.getFocusBlock({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: event.position.selection,\n            },\n          })\n\n          if (!dropFocusBlock || dropFocusBlock.node._key !== key) {\n            return false\n          }\n\n          const dragOrigin = event.dragOrigin\n\n          if (!dragOrigin) {\n            return false\n          }\n\n          const dragSelection = getDragSelection({\n            eventSelection: dragOrigin.selection,\n            snapshot,\n          })\n\n          const draggedBlocks = selectors.getSelectedBlocks({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragSelection,\n            },\n          })\n\n          if (\n            draggedBlocks.some((draggedBlock) => draggedBlock.node._key === key)\n          ) {\n            return false\n          }\n\n          const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragSelection,\n            },\n          })\n\n          return draggingEntireBlocks\n        },\n        actions: [\n          ({event}) => [\n            {\n              type: 'effect',\n              effect: () => {\n                onSetDragPositionBlock(event.position.block)\n              },\n            },\n          ],\n        ],\n      }),\n      priority: createEditorPriority({\n        reference: {\n          priority: corePriority,\n          importance: 'lower',\n        },\n      }),\n    },\n    {\n      behavior: defineBehavior({\n        on: 'drag.*',\n        guard: ({event}) => {\n          return event.type !== 'drag.dragover'\n        },\n        actions: [\n          ({event}) => [\n            {\n              type: 'effect',\n              effect: () => {\n                onSetDragPositionBlock(undefined)\n              },\n            },\n            forward(event),\n          ],\n        ],\n      }),\n      priority: createEditorPriority({\n        reference: {\n          priority: corePriority,\n          importance: 'lower',\n        },\n      }),\n    },\n  ]\n}\n","import {useContext, useEffect} from 'react'\nimport {createCoreBlockElementBehaviorsConfig} from '../../behaviors/behavior.core.block-element'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {EditorActorContext} from '../editor-actor-context'\n\nexport function useCoreBlockElementBehaviors({\n  key,\n  onSetDragPositionBlock,\n}: {\n  key: string\n  onSetDragPositionBlock: (\n    eventPositionBlock: EventPositionBlock | undefined,\n  ) => void\n}) {\n  const editorActor = useContext(EditorActorContext)\n\n  useEffect(() => {\n    const behaviorConfigs = createCoreBlockElementBehaviorsConfig({\n      key,\n      onSetDragPositionBlock,\n    })\n\n    for (const behaviorConfig of behaviorConfigs) {\n      editorActor.send({\n        type: 'add behavior',\n        behaviorConfig,\n      })\n    }\n\n    return () => {\n      for (const behaviorConfig of behaviorConfigs) {\n        editorActor.send({\n          type: 'remove behavior',\n          behaviorConfig,\n        })\n      }\n    }\n  }, [editorActor, key, onSetDragPositionBlock])\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, useState, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport type {RenderBlockFunction} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DropIndicator} from './drop-indicator'\nimport {RenderDefaultBlockObject} from './render-default-object'\nimport {useCoreBlockElementBehaviors} from './use-core-block-element-behaviors'\n\nexport function RenderBlockObject(props: {\n  attributes: RenderElementProps['attributes']\n  blockObject: PortableTextObject\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n}) {\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const blockObjectRef = useRef<HTMLDivElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock,\n  })\n\n  const legacySchemaType = useSelector(editorActor, (s) =>\n    s.context\n      .getLegacySchema()\n      .blockObjects.find(\n        (blockObject) => blockObject.name === props.element._type,\n      ),\n  )\n\n  if (!legacySchemaType) {\n    console.error(\n      `Block object type ${props.element._type} not found in Schema`,\n    )\n  }\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n\n  return (\n    <div\n      {...props.attributes}\n      className=\"pt-block pt-object-block\"\n      data-block-key={props.element._key}\n      data-block-name={props.element._type}\n      data-block-type=\"object\"\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {props.children}\n      <div\n        ref={blockObjectRef}\n        contentEditable={false}\n        draggable={!props.readOnly}\n      >\n        {props.renderBlock && legacySchemaType ? (\n          props.renderBlock({\n            children: (\n              <RenderDefaultBlockObject blockObject={props.blockObject} />\n            ),\n            editorElementRef: blockObjectRef,\n            focused,\n            path: [{_key: props.element._key}],\n            schemaType: legacySchemaType,\n            selected,\n            type: legacySchemaType,\n            value: props.blockObject,\n          })\n        ) : (\n          <RenderDefaultBlockObject blockObject={props.blockObject} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport {getPointBlock} from '../../internal-utils/slate-utils'\nimport type {RenderChildFunction} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {RenderDefaultInlineObject} from './render-default-object'\n\nexport function RenderInlineObject(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  inlineObject: PortableTextObject\n  readOnly: boolean\n  renderChild?: RenderChildFunction\n}) {\n  const inlineObjectRef = useRef<HTMLElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n  const legacySchemaType = useSelector(editorActor, (s) =>\n    s.context\n      .getLegacySchema()\n      .inlineObjects.find(\n        (inlineObject) => inlineObject.name === props.element._type,\n      ),\n  )\n\n  if (!legacySchemaType) {\n    console.error(\n      `Inline object type ${props.element._type} not found in Schema`,\n    )\n  }\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n  const path = DOMEditor.findPath(slateEditor, props.element)\n  const [block] = getPointBlock({\n    editor: slateEditor,\n    point: {\n      path,\n      offset: 0,\n    },\n  })\n\n  if (!block) {\n    console.error(\n      `Unable to find parent block of inline object ${props.element._key}`,\n    )\n  }\n\n  return (\n    <span\n      {...props.attributes}\n      draggable={!props.readOnly}\n      className=\"pt-inline-object\"\n      data-child-key={props.inlineObject._key}\n      data-child-name={props.inlineObject._type}\n      data-child-type=\"object\"\n    >\n      {props.children}\n      <span ref={inlineObjectRef} style={{display: 'inline-block'}}>\n        {props.renderChild && block && legacySchemaType ? (\n          props.renderChild({\n            annotations: [],\n            children: (\n              <RenderDefaultInlineObject inlineObject={props.inlineObject} />\n            ),\n            editorElementRef: inlineObjectRef,\n            selected,\n            focused,\n            path: [{_key: block._key}, 'children', {_key: props.element._key}],\n            schemaType: legacySchemaType,\n            value: props.inlineObject,\n            type: legacySchemaType,\n          })\n        ) : (\n          <RenderDefaultInlineObject inlineObject={props.inlineObject} />\n        )}\n      </span>\n    </span>\n  )\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, useState, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport type {\n  RenderBlockFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DropIndicator} from './drop-indicator'\nimport {useCoreBlockElementBehaviors} from './use-core-block-element-behaviors'\n\nexport function RenderTextBlock(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n  textBlock: PortableTextTextBlock\n}) {\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const blockRef = useRef<HTMLDivElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock,\n  })\n\n  const legacySchema = useSelector(editorActor, (s) =>\n    s.context.getLegacySchema(),\n  )\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n\n  let children = props.children\n\n  const legacyBlockSchemaType = legacySchema.block\n\n  if (props.renderStyle && props.textBlock.style) {\n    const legacyStyleSchemaType =\n      props.textBlock.style !== undefined\n        ? legacySchema.styles.find(\n            (style) => style.value === props.textBlock.style,\n          )\n        : undefined\n\n    if (legacyStyleSchemaType) {\n      children = props.renderStyle({\n        block: props.textBlock,\n        children,\n        editorElementRef: blockRef,\n        focused,\n        path: [{_key: props.textBlock._key}],\n        schemaType: legacyStyleSchemaType,\n        selected,\n        value: props.textBlock.style,\n      })\n    } else {\n      console.error(\n        `Unable to find Schema type for text block style ${props.textBlock.style}`,\n      )\n    }\n  }\n\n  if (props.renderListItem && props.textBlock.listItem) {\n    const legacyListItemSchemaType = legacySchema.lists.find(\n      (list) => list.value === props.textBlock.listItem,\n    )\n\n    if (legacyListItemSchemaType) {\n      children = props.renderListItem({\n        block: props.textBlock,\n        children,\n        editorElementRef: blockRef,\n        focused,\n        level: props.textBlock.level ?? 1,\n        path: [{_key: props.textBlock._key}],\n        selected,\n        value: props.textBlock.listItem,\n        schemaType: legacyListItemSchemaType,\n      })\n    } else {\n      console.error(\n        `Unable to find Schema type for text block list item ${props.textBlock.listItem}`,\n      )\n    }\n  }\n\n  return (\n    <div\n      {...props.attributes}\n      className={[\n        'pt-block',\n        'pt-text-block',\n        ...(props.textBlock.style\n          ? [`pt-text-block-style-${props.textBlock.style}`]\n          : []),\n        ...(props.textBlock.listItem\n          ? [\n              'pt-list-item',\n              `pt-list-item-${props.textBlock.listItem}`,\n              `pt-list-item-level-${props.textBlock.level ?? 1}`,\n            ]\n          : []),\n      ].join(' ')}\n      spellCheck={props.spellCheck}\n      data-block-key={props.textBlock._key}\n      data-block-name={props.textBlock._type}\n      data-block-type=\"text\"\n      {...(props.textBlock.listItem !== undefined\n        ? {\n            'data-list-item': props.textBlock.listItem,\n          }\n        : {})}\n      {...(props.textBlock.level !== undefined\n        ? {\n            'data-level': props.textBlock.level,\n          }\n        : {})}\n      {...(props.textBlock.style !== undefined\n        ? {\n            'data-style': props.textBlock.style,\n          }\n        : {})}\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      <div ref={blockRef}>\n        {props.renderBlock\n          ? props.renderBlock({\n              children,\n              editorElementRef: blockRef,\n              focused,\n              level: props.textBlock.level,\n              listItem: props.textBlock.listItem,\n              path: [{_key: props.textBlock._key}],\n              selected,\n              schemaType: legacyBlockSchemaType,\n              style: props.textBlock.style,\n              type: legacyBlockSchemaType,\n              value: props.textBlock,\n            })\n          : props.children}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n","import {useSelector} from '@xstate/react'\nimport {useContext, type ReactElement} from 'react'\nimport type {Element as SlateElement} from 'slate'\nimport type {RenderElementProps} from 'slate-react'\nimport {isTextBlock} from '../../internal-utils/parse-blocks'\nimport type {\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {RenderBlockObject} from './render-block-object'\nimport {RenderInlineObject} from './render-inline-object'\nimport {RenderTextBlock} from './render-text-block'\n\nexport function RenderElement(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}) {\n  const editorActor = useContext(EditorActorContext)\n  const schema = useSelector(editorActor, (s) => s.context.schema)\n  const isInline =\n    '__inline' in props.element && props.element.__inline === true\n\n  if (isInline) {\n    const inlineObject = {\n      _key: props.element._key,\n      _type: props.element._type,\n      ...('value' in props.element && typeof props.element.value === 'object'\n        ? props.element.value\n        : {}),\n    }\n\n    if (\n      !schema.inlineObjects.find(\n        (inlineObject) => inlineObject.name === props.element._type,\n      )\n    ) {\n      console.error(\n        `Unable to find Inline Object \"${props.element._type}\" in Schema`,\n      )\n    }\n\n    return (\n      <RenderInlineObject\n        attributes={props.attributes}\n        element={props.element}\n        inlineObject={\n          inlineObject ?? {\n            _key: props.element._key,\n            _type: props.element._type,\n          }\n        }\n        readOnly={props.readOnly}\n        renderChild={props.renderChild}\n      >\n        {props.children}\n      </RenderInlineObject>\n    )\n  }\n\n  if (isTextBlock({schema}, props.element)) {\n    return (\n      <RenderTextBlock\n        attributes={props.attributes}\n        element={props.element}\n        readOnly={props.readOnly}\n        renderBlock={props.renderBlock}\n        renderListItem={props.renderListItem}\n        renderStyle={props.renderStyle}\n        spellCheck={props.spellCheck}\n        textBlock={props.element}\n      >\n        {props.children}\n      </RenderTextBlock>\n    )\n  }\n\n  const blockObject = {\n    _key: props.element._key,\n    _type: props.element._type,\n    ...('value' in props.element && typeof props.element.value === 'object'\n      ? props.element.value\n      : {}),\n  }\n\n  if (\n    !schema.blockObjects.find(\n      (blockObject) => blockObject.name === props.element._type,\n    )\n  ) {\n    console.error(\n      `Unable to find Block Object \"${props.element._type}\" in Schema`,\n    )\n  }\n\n  return (\n    <RenderBlockObject\n      attributes={props.attributes}\n      blockObject={\n        blockObject ?? {\n          _key: props.element._key,\n          _type: props.element._type,\n        }\n      }\n      element={props.element}\n      readOnly={props.readOnly}\n      renderBlock={props.renderBlock}\n    >\n      {props.children}\n    </RenderBlockObject>\n  )\n}\n","import {createContext, useContext} from 'react'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\n/**\n * A React context for sharing the editor object.\n */\nexport const PortableTextEditorContext =\n  createContext<PortableTextEditor | null>(null)\n\n/**\n * @deprecated Use `useEditor` to get the current editor instance.\n * @public\n * Get the current editor object from the React context.\n */\nexport const usePortableTextEditor = (): PortableTextEditor => {\n  const editor = useContext(PortableTextEditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`usePortableTextEditor\\` hook must be used inside the <PortableTextEditor> component's context.`,\n    )\n  }\n\n  return editor\n}\n","/**\n * Copy/pasted from https://github.com/statelyai/xstate/blob/main/packages/xstate-react/src/stopRootWithRehydration.ts\n * and renamed to `stopActor`\n */\n\nimport type {AnyActorRef, Snapshot} from 'xstate'\n\nconst forEachActor = (\n  actorRef: AnyActorRef,\n  callback: (ref: AnyActorRef) => void,\n) => {\n  callback(actorRef)\n  const children = actorRef.getSnapshot().children\n  if (children) {\n    Object.values(children).forEach((child) => {\n      forEachActor(child as AnyActorRef, callback)\n    })\n  }\n}\n\nexport function stopActor(actorRef: AnyActorRef) {\n  // persist snapshot here in a custom way allows us to persist inline actors and to preserve actor references\n  // we do it to avoid setState in useEffect when the effect gets \"reconnected\"\n  // this currently only happens in Strict Effects but it simulates the Offscreen aka Activity API\n  // it also just allows us to end up with a somewhat more predictable behavior for the users\n  const persistedSnapshots: Array<[AnyActorRef, Snapshot<unknown>]> = []\n  forEachActor(actorRef, (ref) => {\n    persistedSnapshots.push([ref, ref.getSnapshot()])\n    // muting observers allow us to avoid `useSelector` from being notified about the stopped snapshot\n    // React reconnects its subscribers (from the useSyncExternalStore) on its own\n    // and userland subscibers should basically always do the same anyway\n    // as each subscription should have its own cleanup logic and that should be called each such reconnect\n    ;(ref as any).observers = new Set()\n  })\n  const systemSnapshot = actorRef.system.getSnapshot?.()\n\n  actorRef.stop()\n  ;(actorRef.system as any)._snapshot = systemSnapshot\n  persistedSnapshots.forEach(([ref, snapshot]) => {\n    ;(ref as any)._processingStatus = 0\n    ;(ref as any)._snapshot = snapshot\n  })\n}\n","import {defineConverter} from './converter.types'\n\nexport const converterJson = defineConverter({\n  mimeType: 'application/json',\n  serialize: ({snapshot, event}) => {\n    const portableTextConverter = snapshot.context.converters.find(\n      (converter) => converter.mimeType === 'application/x-portable-text',\n    )\n\n    if (!portableTextConverter) {\n      return {\n        type: 'serialization.failure',\n        mimeType: 'application/json',\n        originEvent: event.originEvent,\n        reason: 'No application/x-portable-text Converter found',\n      }\n    }\n\n    const serializationEvent = portableTextConverter.serialize({\n      snapshot,\n      event,\n    })\n\n    return {\n      ...serializationEvent,\n      mimeType: 'application/json',\n      originEvent: event.originEvent,\n    }\n  },\n  deserialize: ({snapshot, event}) => {\n    const portableTextConverter = snapshot.context.converters.find(\n      (converter) => converter.mimeType === 'application/x-portable-text',\n    )\n\n    if (!portableTextConverter) {\n      return {\n        type: 'deserialization.failure',\n        mimeType: 'application/json',\n        reason: 'No application/x-portable-text Converter found',\n      }\n    }\n\n    const deserializationEvent = portableTextConverter.deserialize({\n      snapshot,\n      event,\n    })\n\n    return {\n      ...deserializationEvent,\n      mimeType: 'application/json',\n    }\n  },\n})\n","import {parseBlock} from '../internal-utils/parse-blocks'\nimport {sliceBlocks} from '../utils'\nimport {defineConverter} from './converter.types'\n\nexport const converterPortableText = defineConverter({\n  mimeType: 'application/x-portable-text',\n  serialize: ({snapshot, event}) => {\n    const selection = snapshot.context.selection\n\n    if (!selection) {\n      return {\n        type: 'serialization.failure',\n        mimeType: 'application/x-portable-text',\n        originEvent: event.originEvent,\n        reason: 'No selection',\n      }\n    }\n\n    const blocks = sliceBlocks({\n      context: {\n        selection,\n        schema: snapshot.context.schema,\n      },\n      blocks: snapshot.context.value,\n    })\n\n    if (blocks.length === 0) {\n      return {\n        type: 'serialization.failure',\n        mimeType: 'application/x-portable-text',\n        reason: 'No blocks serialized',\n        originEvent: event.originEvent,\n      }\n    }\n\n    return {\n      type: 'serialization.success',\n      data: JSON.stringify(blocks),\n      mimeType: 'application/x-portable-text',\n      originEvent: event.originEvent,\n    }\n  },\n  deserialize: ({snapshot, event}) => {\n    const blocks = JSON.parse(event.data)\n\n    if (!Array.isArray(blocks)) {\n      return {\n        type: 'deserialization.failure',\n        mimeType: 'application/x-portable-text',\n        reason: 'Data is not an array',\n      }\n    }\n\n    const parsedBlocks = blocks.flatMap((block) => {\n      const parsedBlock = parseBlock({\n        context: snapshot.context,\n        block,\n        options: {\n          refreshKeys: true,\n          validateFields: false,\n        },\n      })\n      return parsedBlock ? [parsedBlock] : []\n    })\n\n    if (parsedBlocks.length === 0 && blocks.length > 0) {\n      return {\n        type: 'deserialization.failure',\n        mimeType: 'application/x-portable-text',\n        reason: 'No blocks were parsed',\n      }\n    }\n\n    return {\n      type: 'deserialization.success',\n      data: parsedBlocks,\n      mimeType: 'application/x-portable-text',\n    }\n  },\n})\n","import {htmlToBlocks} from '@portabletext/block-tools'\nimport {toHTML} from '@portabletext/to-html'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {parseBlock} from '../internal-utils/parse-blocks'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport {sliceBlocks} from '../utils'\nimport {defineConverter} from './converter.types'\n\nexport function createConverterTextHtml(\n  legacySchema: PortableTextMemberSchemaTypes,\n) {\n  return defineConverter({\n    mimeType: 'text/html',\n    serialize: ({snapshot, event}) => {\n      const selection = snapshot.context.selection\n\n      if (!selection) {\n        return {\n          type: 'serialization.failure',\n          mimeType: 'text/html',\n          originEvent: event.originEvent,\n          reason: 'No selection',\n        }\n      }\n\n      const blocks = sliceBlocks({\n        context: {\n          selection,\n          schema: snapshot.context.schema,\n        },\n        blocks: snapshot.context.value,\n      })\n\n      const html = toHTML(blocks, {\n        onMissingComponent: false,\n        components: {\n          unknownType: ({children}) =>\n            children !== undefined ? `${children}` : '',\n        },\n      })\n\n      if (html === '') {\n        return {\n          type: 'serialization.failure',\n          mimeType: 'text/html',\n          originEvent: event.originEvent,\n          reason: 'Serialized HTML is empty',\n        }\n      }\n\n      return {\n        type: 'serialization.success',\n        data: html,\n        mimeType: 'text/html',\n        originEvent: event.originEvent,\n      }\n    },\n    deserialize: ({snapshot, event}) => {\n      const blocks = htmlToBlocks(event.data, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator,\n        unstable_whitespaceOnPasteMode:\n          legacySchema.block.options.unstable_whitespaceOnPasteMode,\n      }) as Array<PortableTextBlock>\n\n      const parsedBlocks = blocks.flatMap((block) => {\n        const parsedBlock = parseBlock({\n          context: snapshot.context,\n          block,\n          options: {\n            refreshKeys: false,\n            validateFields: true,\n          },\n        })\n        return parsedBlock ? [parsedBlock] : []\n      })\n\n      if (parsedBlocks.length === 0) {\n        return {\n          type: 'deserialization.failure',\n          mimeType: 'text/html',\n          reason: 'No blocks deserialized',\n        }\n      }\n\n      return {\n        type: 'deserialization.success',\n        data: parsedBlocks,\n        mimeType: 'text/html',\n      }\n    },\n  })\n}\n","import {htmlToBlocks} from '@portabletext/block-tools'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {isTextBlock, parseBlock} from '../internal-utils/parse-blocks'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport {sliceBlocks} from '../utils'\nimport {defineConverter} from './converter.types'\n\nexport function createConverterTextPlain(\n  legacySchema: PortableTextMemberSchemaTypes,\n) {\n  return defineConverter({\n    mimeType: 'text/plain',\n    serialize: ({snapshot, event}) => {\n      const selection = snapshot.context.selection\n\n      if (!selection) {\n        return {\n          type: 'serialization.failure',\n          mimeType: 'text/plain',\n          originEvent: event.originEvent,\n          reason: 'No selection',\n        }\n      }\n\n      const blocks = sliceBlocks({\n        context: {\n          selection,\n          schema: snapshot.context.schema,\n        },\n        blocks: snapshot.context.value,\n      })\n\n      const data = blocks\n        .map((block) => {\n          if (isTextBlock(snapshot.context, block)) {\n            return block.children\n              .map((child) => {\n                if (child._type === snapshot.context.schema.span.name) {\n                  return child.text\n                }\n\n                return event.originEvent === 'drag.dragstart'\n                  ? `[${\n                      snapshot.context.schema.inlineObjects.find(\n                        (inlineObjectType) =>\n                          inlineObjectType.name === child._type,\n                      )?.title ?? 'Object'\n                    }]`\n                  : ''\n              })\n              .join('')\n          }\n\n          return event.originEvent === 'drag.dragstart'\n            ? `[${\n                snapshot.context.schema.blockObjects.find(\n                  (blockObjectType) => blockObjectType.name === block._type,\n                )?.title ?? 'Object'\n              }]`\n            : ''\n        })\n        .filter((block) => block !== '')\n        .join('\\n\\n')\n\n      return {\n        type: 'serialization.success',\n        data,\n        mimeType: 'text/plain',\n        originEvent: event.originEvent,\n      }\n    },\n    deserialize: ({snapshot, event}) => {\n      const html = escapeHtml(event.data)\n        .split(/\\n{2,}/)\n        .map((line) =>\n          line\n            ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>')}</p>`\n            : '<p></p>',\n        )\n        .join('')\n\n      const textToHtml = `<html><body>${html}</body></html>`\n\n      const blocks = htmlToBlocks(textToHtml, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator,\n      }) as Array<PortableTextBlock>\n\n      const parsedBlocks = blocks.flatMap((block) => {\n        const parsedBlock = parseBlock({\n          context: snapshot.context,\n          block,\n          options: {\n            refreshKeys: false,\n            validateFields: true,\n          },\n        })\n        return parsedBlock ? [parsedBlock] : []\n      })\n\n      if (parsedBlocks.length === 0) {\n        return {\n          type: 'deserialization.failure',\n          mimeType: 'text/plain',\n          reason: 'No blocks deserialized',\n        }\n      }\n\n      return {\n        type: 'deserialization.success',\n        data: parsedBlocks,\n        mimeType: 'text/plain',\n      }\n    },\n  })\n}\n\nconst entityMap: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;',\n}\n\nfunction escapeHtml(str: string) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s: string) => entityMap[s])\n}\n","import type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport {converterJson} from './converter.json'\nimport {converterPortableText} from './converter.portable-text'\nimport {createConverterTextHtml} from './converter.text-html'\nimport {createConverterTextPlain} from './converter.text-plain'\n\nexport function createCoreConverters(\n  legacySchema: PortableTextMemberSchemaTypes,\n) {\n  return [\n    converterJson,\n    converterPortableText,\n    createConverterTextHtml(legacySchema),\n    createConverterTextPlain(legacySchema),\n  ]\n}\n","import {Schema} from '@sanity/schema'\n\nexport function compileType(rawType: any) {\n  return Schema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType],\n  }).get(rawType.name)\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\n\nexport function createPlaceholderBlock(\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>,\n) {\n  return {\n    _type: context.schema.block.name,\n    _key: context.keyGenerator(),\n    style: context.schema.styles[0].name ?? 'normal',\n    markDefs: [],\n    children: [\n      {\n        _type: context.schema.span.name,\n        _key: context.keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ],\n  }\n}\n","import type {MarkState} from '../internal-utils/mark-state'\nimport type {EditorSchema} from './editor-schema'\n\nexport function getActiveAnnotations({\n  markState,\n  schema,\n}: {\n  markState: MarkState | undefined\n  schema: EditorSchema\n}) {\n  return (markState?.marks ?? []).filter(\n    (mark) =>\n      !schema.decorators.map((decorator) => decorator.name).includes(mark),\n  )\n}\n","import type {MarkState} from '../internal-utils/mark-state'\nimport type {EditorSchema} from './editor-schema'\n\nexport function getActiveDecorators({\n  decoratorState,\n  markState,\n  schema,\n}: {\n  decoratorState: Record<string, boolean | undefined>\n  markState: MarkState | undefined\n  schema: EditorSchema\n}) {\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n\n  const markStateDecorators = (markState?.marks ?? []).filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  let activeDecorators: Array<string> = markStateDecorators\n\n  for (const decorator in decoratorState) {\n    if (decoratorState[decorator] === false) {\n      activeDecorators = activeDecorators.filter(\n        (activeDecorator) => activeDecorator !== decorator,\n      )\n    } else if (decoratorState[decorator] === true) {\n      if (!activeDecorators.includes(decorator)) {\n        activeDecorators.push(decorator)\n      }\n    }\n  }\n\n  return activeDecorators\n}\n","import {Transforms} from 'slate'\nimport {getActiveAnnotations} from '../editor/get-active-annotations'\nimport {getActiveDecorators} from '../editor/get-active-decorators'\nimport {getFocusSpan} from '../internal-utils/slate-utils'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const insertTextOperationImplementation: BehaviorOperationImplementation<\n  'insert.text'\n> = ({context, operation}) => {\n  const activeDecorators = getActiveDecorators({\n    decoratorState: operation.editor.decoratorState,\n    markState: operation.editor.markState,\n    schema: context.schema,\n  })\n  const activeAnnotations = getActiveAnnotations({\n    markState: operation.editor.markState,\n    schema: context.schema,\n  })\n\n  const [focusSpan] = getFocusSpan({\n    editor: operation.editor,\n  })\n\n  if (!focusSpan) {\n    Transforms.insertText(operation.editor, operation.text)\n    return\n  }\n\n  if (\n    operation.editor.markState &&\n    operation.editor.markState.state === 'unchanged'\n  ) {\n    const markStateDecorators = (operation.editor.markState.marks ?? []).filter(\n      (mark) =>\n        context.schema.decorators\n          .map((decorator) => decorator.name)\n          .includes(mark),\n    )\n\n    if (\n      markStateDecorators.length === activeDecorators.length &&\n      markStateDecorators.every((mark) => activeDecorators.includes(mark))\n    ) {\n      Transforms.insertText(operation.editor, operation.text)\n      return\n    }\n  }\n\n  Transforms.insertNodes(operation.editor, {\n    _type: focusSpan._type,\n    _key: context.keyGenerator(),\n    text: operation.text,\n    marks: [...activeDecorators, ...activeAnnotations],\n  })\n\n  operation.editor.decoratorState = {}\n}\n","function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a, _b;\n  const {\n      children\n    } = block,\n    markDefs = (_a = block.markDefs) != null ? _a : [];\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs == null ? void 0 : markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\nexport { LIST_NEST_MODE_DIRECT, LIST_NEST_MODE_HTML, buildMarksTree, isPortableTextBlock, isPortableTextListItemBlock, isPortableTextSpan, isPortableTextToolkitList, isPortableTextToolkitSpan, isPortableTextToolkitTextNode, nestLists, sortMarksByOccurences, spanToPlainText, toPlainText };\n//# sourceMappingURL=index.js.map\n","import type {PortableTextSpan} from '@sanity/types'\nimport {Node, Path} from 'slate'\nimport type {PortableTextSlateEditor} from '../types/editor'\n\nexport function getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath,\n}: {\n  editor: PortableTextSlateEditor\n  blockPath: Path\n  spanPath: Path\n}): PortableTextSpan | undefined {\n  let previousSpan: PortableTextSpan | undefined\n\n  for (const [child, childPath] of Node.children(editor, blockPath, {\n    reverse: true,\n  })) {\n    if (!editor.isTextSpan(child)) {\n      continue\n    }\n\n    if (Path.isBefore(childPath, spanPath)) {\n      previousSpan = child\n      break\n    }\n  }\n\n  return previousSpan\n}\n\nexport function getNextSpan({\n  editor,\n  blockPath,\n  spanPath,\n}: {\n  editor: PortableTextSlateEditor\n  blockPath: Path\n  spanPath: Path\n}): PortableTextSpan | undefined {\n  let nextSpan: PortableTextSpan | undefined\n\n  for (const [child, childPath] of Node.children(editor, blockPath)) {\n    if (!editor.isTextSpan(child)) {\n      continue\n    }\n\n    if (Path.isAfter(childPath, spanPath)) {\n      nextSpan = child\n      break\n    }\n  }\n\n  return nextSpan\n}\n","import type {Editor} from 'slate'\nimport {IS_PROCESSING_REMOTE_CHANGES} from './weakMaps'\n\nexport function withRemoteChanges(editor: Editor, fn: () => void): void {\n  const prev = isChangingRemotely(editor) || false\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, true)\n  fn()\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, prev)\n}\n\nexport function isChangingRemotely(editor: Editor): boolean | undefined {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor)\n}\n","import type {Editor} from 'slate'\n\nconst IS_UDOING: WeakMap<Editor, boolean | undefined> = new WeakMap()\nconst IS_REDOING: WeakMap<Editor, boolean | undefined> = new WeakMap()\n\nexport function withUndoing(editor: Editor, fn: () => void) {\n  const prev = isUndoing(editor)\n  IS_UDOING.set(editor, true)\n  fn()\n  IS_UDOING.set(editor, prev)\n}\n\nexport function isUndoing(editor: Editor) {\n  return IS_UDOING.get(editor) ?? false\n}\n\nexport function setIsUndoing(editor: Editor, isUndoing: boolean) {\n  IS_UDOING.set(editor, isUndoing)\n}\n\nexport function withRedoing(editor: Editor, fn: () => void) {\n  const prev = isRedoing(editor)\n  IS_REDOING.set(editor, true)\n  fn()\n  IS_REDOING.set(editor, prev)\n}\n\nexport function isRedoing(editor: Editor) {\n  return IS_REDOING.get(editor) ?? false\n}\n\nexport function setIsRedoing(editor: Editor, isRedoing: boolean) {\n  IS_REDOING.set(editor, isRedoing)\n}\n","import {useSelector} from '@xstate/react'\nimport type {Editor} from '../editor'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {InternalEditor} from './create-editor'\nimport type {EditorActor} from './editor-machine'\nimport type {EditorSnapshot} from './editor-snapshot'\nimport {getActiveAnnotations} from './get-active-annotations'\nimport {getActiveDecorators} from './get-active-decorators'\n\nfunction defaultCompare<T>(a: T, b: T) {\n  return a === b\n}\n\n/**\n * @public\n */\nexport type EditorSelector<TSelected> = (snapshot: EditorSnapshot) => TSelected\n\n/**\n * @public\n * Hook to select a value from the editor state.\n * @example\n * Pass a selector as the second argument\n * ```tsx\n * import { useEditorSelector } from '@portabletext/editor'\n *\n * function MyComponent(editor) {\n *  const value = useEditorSelector(editor, selector)\n * }\n * ```\n * @example\n * Pass an inline selector as the second argument.\n * In this case, use the editor context to obtain the schema.\n * ```tsx\n * import { useEditorSelector } from '@portabletext/editor'\n *\n * function MyComponent(editor) {\n *  const schema = useEditorSelector(editor, (snapshot) => snapshot.context.schema)\n * }\n * ```\n * @group Hooks\n */\nexport function useEditorSelector<TSelected>(\n  editor: Editor,\n  selector: EditorSelector<TSelected>,\n  compare: (a: TSelected, b: TSelected) => boolean = defaultCompare,\n) {\n  return useSelector(\n    (editor as InternalEditor)._internal.editorActor,\n    (editorActorSnapshot) => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot,\n        slateEditorInstance: (editor as InternalEditor)._internal.slateEditor\n          .instance,\n      })\n\n      return selector(snapshot)\n    },\n    compare,\n  )\n}\n\nexport function getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance,\n}: {\n  editorActorSnapshot: ReturnType<EditorActor['getSnapshot']>\n  slateEditorInstance: PortableTextSlateEditor\n}): EditorSnapshot {\n  return {\n    context: {\n      converters: [...editorActorSnapshot.context.converters],\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      readOnly: editorActorSnapshot.matches({'edit mode': 'read only'}),\n      schema: editorActorSnapshot.context.schema,\n      selection: editorActorSnapshot.context.selection,\n      value: slateEditorInstance.value,\n    },\n    beta: {\n      activeAnnotations: getActiveAnnotations({\n        markState: slateEditorInstance.markState,\n        schema: editorActorSnapshot.context.schema,\n      }),\n      activeDecorators: getActiveDecorators({\n        decoratorState: slateEditorInstance.decoratorState,\n        markState: slateEditorInstance.markState,\n        schema: editorActorSnapshot.context.schema,\n      }),\n    },\n  }\n}\n","/**\n *\n * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).\n *\n */\n\nimport {isPortableTextBlock, isPortableTextSpan} from '@portabletext/toolkit'\nimport type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {Editor, Element, Node, Path, Range, Text, Transforms} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {getNextSpan, getPreviousSpan} from '../../internal-utils/sibling-utils'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {BehaviorOperationImplementation} from '../../operations/behavior.operations'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {getEditorSnapshot} from '../editor-selector'\n\nconst debug = debugWithName('plugin:withPortableTextMarkModel')\n\nexport function createWithPortableTextMarkModel(\n  editorActor: EditorActor,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  return function withPortableTextMarkModel(editor: PortableTextSlateEditor) {\n    const {apply, normalizeNode} = editor\n    const decorators = editorActor\n      .getSnapshot()\n      .context.schema.decorators.map((t) => t.name)\n\n    // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks\n    editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry\n\n      if (editor.isTextBlock(node)) {\n        const children = Node.children(editor, path)\n\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1]\n\n          if (\n            editor.isTextSpan(child) &&\n            editor.isTextSpan(nextNode) &&\n            child.marks?.every((mark) => nextNode.marks?.includes(mark)) &&\n            nextNode.marks?.every((mark) => child.marks?.includes(mark))\n          ) {\n            debug(\n              'Merging spans',\n              JSON.stringify(child, null, 2),\n              JSON.stringify(nextNode, null, 2),\n            )\n            editorActor.send({type: 'normalizing'})\n            Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: true,\n            })\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      /**\n       * Add missing .markDefs to block nodes\n       */\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug('Adding .markDefs to block node')\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {markDefs: []}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      /**\n       * Add missing .marks to span nodes\n       */\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug('Adding .marks to span node')\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {marks: []}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      /**\n       * Remove annotations from empty spans\n       */\n      if (editor.isTextSpan(node)) {\n        const blockPath = Path.parent(path)\n        const [block] = Editor.node(editor, blockPath)\n        const decorators = editorActor\n          .getSnapshot()\n          .context.schema.decorators.map((decorator) => decorator.name)\n        const annotations = node.marks?.filter(\n          (mark) => !decorators.includes(mark),\n        )\n\n        if (editor.isTextBlock(block)) {\n          if (node.text === '' && annotations && annotations.length > 0) {\n            debug('Removing annotations from empty span node')\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {marks: node.marks?.filter((mark) => decorators.includes(mark))},\n              {at: path},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      /**\n       * Remove orphaned annotations from child spans of block nodes\n       */\n      if (editor.isTextBlock(node)) {\n        const decorators = editorActor\n          .getSnapshot()\n          .context.schema.decorators.map((decorator) => decorator.name)\n\n        for (const [child, childPath] of Node.children(editor, path)) {\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? []\n            const orphanedAnnotations = marks.filter((mark) => {\n              return (\n                !decorators.includes(mark) &&\n                !node.markDefs?.find((def) => def._key === mark)\n              )\n            })\n\n            if (orphanedAnnotations.length > 0) {\n              debug('Removing orphaned annotations from span node')\n              editorActor.send({type: 'normalizing'})\n              Transforms.setNodes(\n                editor,\n                {\n                  marks: marks.filter(\n                    (mark) => !orphanedAnnotations.includes(mark),\n                  ),\n                },\n                {at: childPath},\n              )\n              editorActor.send({type: 'done normalizing'})\n              return\n            }\n          }\n        }\n      }\n\n      /**\n       * Remove orphaned annotations from span nodes\n       */\n      if (editor.isTextSpan(node)) {\n        const blockPath = Path.parent(path)\n        const [block] = Editor.node(editor, blockPath)\n\n        if (editor.isTextBlock(block)) {\n          const decorators = editorActor\n            .getSnapshot()\n            .context.schema.decorators.map((decorator) => decorator.name)\n          const marks = node.marks ?? []\n          const orphanedAnnotations = marks.filter((mark) => {\n            return (\n              !decorators.includes(mark) &&\n              !block.markDefs?.find((def) => def._key === mark)\n            )\n          })\n\n          if (orphanedAnnotations.length > 0) {\n            debug('Removing orphaned annotations from span node')\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {\n                marks: marks.filter(\n                  (mark) => !orphanedAnnotations.includes(mark),\n                ),\n              },\n              {at: path},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      // Remove duplicate markDefs\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? []\n        const markDefKeys = new Set<string>()\n        const newMarkDefs: Array<PortableTextObject> = []\n\n        for (const markDef of markDefs) {\n          if (!markDefKeys.has(markDef._key)) {\n            markDefKeys.add(markDef._key)\n            newMarkDefs.push(markDef)\n          }\n        }\n\n        if (markDefs.length !== newMarkDefs.length) {\n          debug('Removing duplicate markDefs')\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(editor, {markDefs: newMarkDefs}, {at: path})\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n      }\n\n      // Check consistency of markDefs (unless we are merging two nodes)\n      if (\n        editor.isTextBlock(node) &&\n        !editor.operations.some(\n          (op) =>\n            op.type === 'merge_node' &&\n            'markDefs' in op.properties &&\n            op.path.length === 1,\n        )\n      ) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => {\n          return node.children.find((child) => {\n            return (\n              Text.isText(child) &&\n              Array.isArray(child.marks) &&\n              child.marks.includes(def._key)\n            )\n          })\n        })\n        if (node.markDefs && !isEqual(newMarkDefs, node.markDefs)) {\n          debug('Removing markDef not in use')\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(\n            editor,\n            {\n              markDefs: newMarkDefs,\n            },\n            {at: path},\n          )\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n      }\n\n      normalizeNode(nodeEntry)\n    }\n\n    editor.apply = (op) => {\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      if (op.type === 'set_selection') {\n        if (\n          op.properties &&\n          op.newProperties &&\n          op.properties.anchor &&\n          op.properties.focus &&\n          op.newProperties.anchor &&\n          op.newProperties.focus\n        ) {\n          const previousSelectionIsCollapsed = Range.isCollapsed({\n            anchor: op.properties.anchor,\n            focus: op.properties.focus,\n          })\n          const newSelectionIsCollapsed = Range.isCollapsed({\n            anchor: op.newProperties.anchor,\n            focus: op.newProperties.focus,\n          })\n\n          if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n            const focusSpan: PortableTextSpan | undefined = Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: op.properties.focus,\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0]?.[0]\n            const newFocusSpan: PortableTextSpan | undefined = Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: op.newProperties.focus,\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0]?.[0]\n            const movedToNextSpan =\n              focusSpan &&\n              newFocusSpan &&\n              op.newProperties.focus.path[0] === op.properties.focus.path[0] &&\n              op.newProperties.focus.path[1] ===\n                op.properties.focus.path[1] + 1 &&\n              focusSpan.text.length === op.properties.focus.offset &&\n              op.newProperties.focus.offset === 0\n            const movedToPreviousSpan =\n              focusSpan &&\n              newFocusSpan &&\n              op.newProperties.focus.path[0] === op.properties.focus.path[0] &&\n              op.newProperties.focus.path[1] ===\n                op.properties.focus.path[1] - 1 &&\n              op.properties.focus.offset === 0 &&\n              newFocusSpan.text.length === op.newProperties.focus.offset\n\n            // We only want to clear the decorator state if the caret is visually\n            // moving\n            if (!movedToNextSpan && !movedToPreviousSpan) {\n              editor.decoratorState = {}\n            }\n          }\n        }\n      }\n\n      if (op.type === 'insert_node') {\n        const {selection} = editor\n\n        if (selection) {\n          const [_block, blockPath] = Editor.node(editor, selection, {depth: 1})\n          const previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path,\n          })\n          const previousSpanAnnotations = previousSpan\n            ? previousSpan.marks?.filter((mark) => !decorators.includes(mark))\n            : []\n\n          const nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1],\n          })\n          const nextSpanAnnotations = nextSpan\n            ? nextSpan.marks?.filter((mark) => !decorators.includes(mark))\n            : []\n\n          const annotationsEnding =\n            previousSpanAnnotations?.filter(\n              (annotation) => !nextSpanAnnotations?.includes(annotation),\n            ) ?? []\n          const atTheEndOfAnnotation = annotationsEnding.length > 0\n\n          if (\n            atTheEndOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.some((mark) => annotationsEnding.includes(mark))\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks:\n                op.node.marks?.filter(\n                  (mark) => !annotationsEnding.includes(mark),\n                ) ?? [],\n            })\n            return\n          }\n\n          const annotationsStarting =\n            nextSpanAnnotations?.filter(\n              (annotation) => !previousSpanAnnotations?.includes(annotation),\n            ) ?? []\n          const atTheStartOfAnnotation = annotationsStarting.length > 0\n\n          if (\n            atTheStartOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.some((mark) => annotationsStarting.includes(mark))\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks:\n                op.node.marks?.filter(\n                  (mark) => !annotationsStarting.includes(mark),\n                ) ?? [],\n            })\n            return\n          }\n\n          const nextSpanDecorators =\n            nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? []\n          const decoratorStarting = nextSpanDecorators.length > 0\n\n          if (\n            decoratorStarting &&\n            atTheEndOfAnnotation &&\n            !atTheStartOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.length === 0\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: nextSpanDecorators,\n            })\n            return\n          }\n        }\n      }\n\n      if (op.type === 'insert_text') {\n        if (!editor.markState) {\n          apply(op)\n          return\n        }\n\n        if (editor.markState.state === 'unchanged') {\n          apply(op)\n          return\n        }\n\n        Transforms.insertNodes(editor, {\n          _type: 'span',\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          text: op.text,\n          marks: editor.markState.marks,\n        })\n\n        return\n      }\n\n      if (op.type === 'remove_text') {\n        const {selection} = editor\n\n        if (selection && Range.isExpanded(selection)) {\n          const [block, blockPath] = Editor.node(editor, selection, {\n            depth: 1,\n          })\n          const [span, spanPath] =\n            Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: {path: op.path, offset: op.offset},\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0] ?? ([undefined, undefined] as const)\n\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? []\n            const marks = span.marks ?? []\n            const spanHasAnnotations = marks.some((mark) =>\n              markDefs.find((markDef) => markDef._key === mark),\n            )\n            const deletingFromTheEnd =\n              op.offset + op.text.length === span.text.length\n            const deletingAllText = op.offset === 0 && deletingFromTheEnd\n\n            const previousSpan = getPreviousSpan({editor, blockPath, spanPath})\n            const nextSpan = getNextSpan({editor, blockPath, spanPath})\n\n            const previousSpanHasSameAnnotation = previousSpan\n              ? previousSpan.marks?.some(\n                  (mark) => !decorators.includes(mark) && marks.includes(mark),\n                )\n              : false\n            const nextSpanHasSameAnnotation = nextSpan\n              ? nextSpan.marks?.some(\n                  (mark) => !decorators.includes(mark) && marks.includes(mark),\n                )\n              : false\n\n            if (\n              spanHasAnnotations &&\n              deletingAllText &&\n              !previousSpanHasSameAnnotation &&\n              !nextSpanHasSameAnnotation\n            ) {\n              const snapshot = getEditorSnapshot({\n                editorActorSnapshot: editorActor.getSnapshot(),\n                slateEditorInstance: editor,\n              })\n\n              Editor.withoutNormalizing(editor, () => {\n                apply(op)\n                Transforms.setNodes(\n                  editor,\n                  {marks: snapshot.beta.activeDecorators},\n                  {at: op.path},\n                )\n              })\n\n              editor.onChange()\n              return\n            }\n          }\n        }\n      }\n\n      /**\n       * Copy over markDefs when merging blocks\n       */\n      if (\n        op.type === 'merge_node' &&\n        op.path.length === 1 &&\n        'markDefs' in op.properties &&\n        op.properties._type ===\n          editorActor.getSnapshot().context.schema.block.name &&\n        Array.isArray(op.properties.markDefs) &&\n        op.properties.markDefs.length > 0 &&\n        op.path[0] - 1 >= 0\n      ) {\n        const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] - 1])\n\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs =\n            (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || []\n          const newMarkDefs = uniq([...oldDefs, ...op.properties.markDefs])\n\n          debug(`Copying markDefs over to merged block`, op)\n          Transforms.setNodes(\n            editor,\n            {markDefs: newMarkDefs},\n            {at: targetPath, voids: false},\n          )\n          apply(op)\n          return\n        }\n      }\n\n      apply(op)\n    }\n\n    return editor\n  }\n}\n\nexport const removeDecoratorOperationImplementation: BehaviorOperationImplementation<\n  'decorator.remove'\n> = ({operation}) => {\n  const editor = operation.editor\n  const mark = operation.decorator\n  const {selection} = editor\n\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      // Split if needed\n      Transforms.setNodes(\n        editor,\n        {},\n        {match: Text.isText, split: true, hanging: true},\n      )\n      if (editor.selection) {\n        const splitTextNodes = [\n          ...Editor.nodes(editor, {\n            at: editor.selection,\n            match: Text.isText,\n          }),\n        ]\n        splitTextNodes.forEach(([node, path]) => {\n          const block = editor.children[path[0]]\n          if (Element.isElement(block) && block.children.includes(node)) {\n            Transforms.setNodes(\n              editor,\n              {\n                marks: (Array.isArray(node.marks) ? node.marks : []).filter(\n                  (eMark: string) => eMark !== mark,\n                ),\n                _type: 'span',\n              },\n              {at: path},\n            )\n          }\n        })\n      }\n    } else {\n      const [block, blockPath] = Editor.node(editor, selection, {\n        depth: 1,\n      })\n      const lonelyEmptySpan =\n        editor.isTextBlock(block) &&\n        block.children.length === 1 &&\n        editor.isTextSpan(block.children[0]) &&\n        block.children[0].text === ''\n          ? block.children[0]\n          : undefined\n\n      if (lonelyEmptySpan) {\n        const existingMarks = lonelyEmptySpan.marks ?? []\n        const existingMarksWithoutDecorator = existingMarks.filter(\n          (existingMark) => existingMark !== mark,\n        )\n\n        Transforms.setNodes(\n          editor,\n          {\n            marks: existingMarksWithoutDecorator,\n          },\n          {\n            at: blockPath,\n            match: (node) => editor.isTextSpan(node),\n          },\n        )\n      } else {\n        editor.decoratorState[mark] = false\n      }\n    }\n\n    if (editor.selection) {\n      // Reselect\n      const selection = editor.selection\n      editor.selection = {...selection}\n    }\n  }\n}\n","function cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2]\n  ];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, { checkLines: !1, deadline }), diffsb = doDiff(text1b, text2b, { checkLines: !1, deadline });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [\n    bestLongTextA || \"\",\n    bestLongTextB || \"\",\n    bestShortTextA || \"\",\n    bestShortTextB || \"\",\n    bestCommon || \"\"\n  ] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return { chars1, chars2, lineArray };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2]\n    ];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n          0,\n          commonlength\n        ) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation, options = {}) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc, options);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, location) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(\n      text,\n      text1.substring(text1.length - MAX_BITS),\n      expectedLoc + text1.length - MAX_BITS\n    ), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, { checkLines: !1 });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nvar __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTS = {\n  margin: 4\n};\nfunction getDefaultOpts(opts = {}) {\n  return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);\n}\nfunction make(a, b, options) {\n  if (typeof a == \"string\" && typeof b == \"string\") {\n    let diffs = diff(a, b, { checkLines: !0 });\n    return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));\n  }\n  if (a && Array.isArray(a) && typeof b > \"u\")\n    return _make(diffText1(a), a, getDefaultOpts(options));\n  if (typeof a == \"string\" && b && Array.isArray(b))\n    return _make(a, b, getDefaultOpts(options));\n  throw new Error(\"Unknown call format to make()\");\n}\nfunction _make(textA, diffs, options) {\n  if (diffs.length === 0)\n    return [];\n  const patches = [];\n  let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);\n    switch (!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);\n        break;\n      case DIFF_EQUAL:\n        diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);\n        break;\n      default:\n        throw new Error(\"Unknown diff type\");\n    }\n    diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);\n  }\n  return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;\n}\nfunction addContext(patch, text, opts) {\n  if (text.length === 0)\n    return;\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;\n  for (; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin; )\n    padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  padding += opts.margin;\n  let prefixStart = patch.start2 - padding;\n  prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;\n  const prefix = text.substring(prefixStart, patch.start2);\n  prefix && patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);\n  let suffixEnd = patch.start2 + patch.length1 + padding;\n  suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);\n  suffix && patch.diffs.push([DIFF_EQUAL, suffix]);\n  const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);\n  patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch (ex) {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nfunction stringify(patches) {\n  return patches.map(stringifyPatch).join(\"\");\n}\nfunction stringifyPatch(patch) {\n  const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;\n  let coords1;\n  utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;\n  let coords2;\n  utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;\n  const text = [`@@ -${coords1} +${coords2} @@\n`];\n  let op;\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = \"+\";\n        break;\n      case DIFF_DELETE:\n        op = \"-\";\n        break;\n      case DIFF_EQUAL:\n        op = \" \";\n        break;\n      default:\n        throw new Error(\"Unknown patch operation.\");\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\n`;\n  }\n  return text.join(\"\").replace(/%20/g, \" \");\n}\nexport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  adjustIndiciesToUcs2,\n  apply as applyPatches,\n  cleanupEfficiency,\n  cleanupSemantic,\n  diff as makeDiff,\n  make as makePatches,\n  match,\n  parse as parsePatch,\n  stringifyPatch,\n  stringify as stringifyPatches,\n  xIndex\n};\n//# sourceMappingURL=index.js.map\n","import type {Editor} from 'slate'\nimport {defaultKeyGenerator} from './key-generator'\n\nconst CURRENT_UNDO_STEP: WeakMap<Editor, {undoStepId: string} | undefined> =\n  new WeakMap()\n\nexport function withUndoStep(editor: Editor, fn: () => void) {\n  const current = CURRENT_UNDO_STEP.get(editor)\n\n  if (current) {\n    fn()\n    return\n  }\n\n  CURRENT_UNDO_STEP.set(\n    editor,\n    current ?? {\n      undoStepId: defaultKeyGenerator(),\n    },\n  )\n  fn()\n  CURRENT_UNDO_STEP.set(editor, undefined)\n}\n\nexport function getCurrentUndoStepId(editor: Editor) {\n  return CURRENT_UNDO_STEP.get(editor)?.undoStepId\n}\n","/**\n * This plugin will make the editor support undo/redo on the local state only.\n * The undo/redo steps are rebased against incoming patches since the step occurred.\n */\n\nimport type {Patch} from '@portabletext/patches'\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  parsePatch,\n} from '@sanity/diff-match-patch'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {flatten, isEqual} from 'lodash'\nimport {\n  Editor,\n  Operation,\n  Path,\n  Transforms,\n  type Descendant,\n  type SelectionOperation,\n} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {\n  isRedoing,\n  isUndoing,\n  setIsRedoing,\n  setIsUndoing,\n  withRedoing,\n  withUndoing,\n} from '../../internal-utils/withUndoRedo'\nimport type {BehaviorOperationImplementation} from '../../operations/behavior.operations'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {getCurrentUndoStepId} from '../with-undo-step'\n\nconst debug = debugWithName('plugin:withUndoRedo')\nconst debugVerbose = debug.enabled && false\n\nconst SAVING = new WeakMap<Editor, boolean | undefined>()\nconst REMOTE_PATCHES = new WeakMap<\n  Editor,\n  {\n    patch: Patch\n    time: Date\n    snapshot: PortableTextBlock[] | undefined\n    previousSnapshot: PortableTextBlock[] | undefined\n  }[]\n>()\nconst UNDO_STEP_LIMIT = 1000\n\nconst isSaving = (editor: Editor): boolean | undefined => {\n  const state = SAVING.get(editor)\n  return state === undefined ? true : state\n}\n\nexport interface Options {\n  editorActor: EditorActor\n  subscriptions: Array<() => () => void>\n}\n\nconst getRemotePatches = (editor: Editor) => {\n  if (!REMOTE_PATCHES.get(editor)) {\n    REMOTE_PATCHES.set(editor, [])\n  }\n  return REMOTE_PATCHES.get(editor) || []\n}\n\nexport function createWithUndoRedo(\n  options: Options,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  const {editorActor} = options\n\n  return (editor: PortableTextSlateEditor) => {\n    let previousSnapshot: PortableTextBlock[] | undefined = fromSlateValue(\n      editor.children,\n      editorActor.getSnapshot().context.schema.block.name,\n    )\n    const remotePatches = getRemotePatches(editor)\n    let previousUndoStepId = getCurrentUndoStepId(editor)\n\n    options.subscriptions.push(() => {\n      debug('Subscribing to patches')\n      const sub = editorActor.on('patches', ({patches, snapshot}) => {\n        let reset = false\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== 'local' && remotePatches) {\n            if (patch.type === 'unset' && patch.path.length === 0) {\n              debug(\n                'Someone else cleared the content, resetting undo/redo history',\n              )\n              editor.history = {undos: [], redos: []}\n              remotePatches.splice(0, remotePatches.length)\n              SAVING.set(editor, true)\n              reset = true\n              return\n            }\n            remotePatches.push({\n              patch,\n              time: new Date(),\n              snapshot,\n              previousSnapshot,\n            })\n          }\n        })\n        previousSnapshot = snapshot\n      })\n      return () => {\n        debug('Unsubscribing to patches')\n        sub.unsubscribe()\n      }\n    })\n\n    editor.history = {undos: [], redos: []}\n\n    const {apply} = editor\n\n    editor.apply = (op: Operation) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      const {operations, history} = editor\n      const {undos} = history\n      const step = undos[undos.length - 1]\n      const lastOp =\n        step && step.operations && step.operations[step.operations.length - 1]\n      const overwrite = shouldOverwrite(op, lastOp)\n      const save = isSaving(editor)\n\n      const currentUndoStepId = getCurrentUndoStepId(editor)\n\n      let merge =\n        currentUndoStepId !== undefined && previousUndoStepId === undefined\n          ? false\n          : currentUndoStepId !== undefined && previousUndoStepId !== undefined\n            ? currentUndoStepId === previousUndoStepId\n            : true\n\n      if (save) {\n        if (!step) {\n          merge = false\n        } else if (operations.length === 0) {\n          merge =\n            currentUndoStepId === undefined && previousUndoStepId === undefined\n              ? shouldMerge(op, lastOp) || overwrite\n              : merge\n        }\n\n        if (step && merge) {\n          step.operations.push(op)\n        } else {\n          const newStep = {\n            operations: [\n              ...(editor.selection === null\n                ? []\n                : [createSelectOperation(editor)]),\n              op,\n            ],\n            timestamp: new Date(),\n          }\n          undos.push(newStep)\n          debug('Created new undo step', step)\n        }\n\n        while (undos.length > UNDO_STEP_LIMIT) {\n          undos.shift()\n        }\n\n        if (shouldClear(op)) {\n          history.redos = []\n        }\n      }\n\n      previousUndoStepId = currentUndoStepId\n\n      apply(op)\n    }\n\n    // Plugin return\n    return editor\n  }\n}\n\nexport const historyUndoOperationImplementation: BehaviorOperationImplementation<\n  'history.undo'\n> = ({operation}) => {\n  const editor = operation.editor\n  const {undos} = editor.history\n  const remotePatches = getRemotePatches(editor)\n\n  if (undos.length > 0) {\n    const step = undos[undos.length - 1]\n    debug('Undoing', step)\n    if (step.operations.length > 0) {\n      const otherPatches = remotePatches.filter(\n        (item) => item.time >= step.timestamp,\n      )\n      let transformedOperations = step.operations\n      otherPatches.forEach((item) => {\n        transformedOperations = flatten(\n          transformedOperations.map((op) =>\n            transformOperation(\n              editor,\n              item.patch,\n              op,\n              item.snapshot,\n              item.previousSnapshot,\n            ),\n          ),\n        )\n      })\n      const reversedOperations = transformedOperations\n        .map(Operation.inverse)\n        .reverse()\n\n      try {\n        Editor.withoutNormalizing(editor, () => {\n          withUndoing(editor, () => {\n            withoutSaving(editor, () => {\n              reversedOperations.forEach((op) => {\n                editor.apply(op)\n              })\n            })\n          })\n        })\n      } catch (err) {\n        debug('Could not perform undo step', err)\n        remotePatches.splice(0, remotePatches.length)\n        Transforms.deselect(editor)\n        editor.history = {undos: [], redos: []}\n        SAVING.set(editor, true)\n        setIsUndoing(editor, false)\n        editor.onChange()\n        return\n      }\n      editor.history.redos.push(step)\n      editor.history.undos.pop()\n    }\n  }\n}\n\nexport const historyRedoOperationImplementation: BehaviorOperationImplementation<\n  'history.redo'\n> = ({operation}) => {\n  const editor = operation.editor\n  const {redos} = editor.history\n  const remotePatches = getRemotePatches(editor)\n\n  if (redos.length > 0) {\n    const step = redos[redos.length - 1]\n    debug('Redoing', step)\n    if (step.operations.length > 0) {\n      const otherPatches = remotePatches.filter(\n        (item) => item.time >= step.timestamp,\n      )\n      let transformedOperations = step.operations\n      otherPatches.forEach((item) => {\n        transformedOperations = flatten(\n          transformedOperations.map((op) =>\n            transformOperation(\n              editor,\n              item.patch,\n              op,\n              item.snapshot,\n              item.previousSnapshot,\n            ),\n          ),\n        )\n      })\n      try {\n        Editor.withoutNormalizing(editor, () => {\n          withRedoing(editor, () => {\n            withoutSaving(editor, () => {\n              transformedOperations.forEach((op) => {\n                editor.apply(op)\n              })\n            })\n          })\n        })\n      } catch (err) {\n        debug('Could not perform redo step', err)\n        remotePatches.splice(0, remotePatches.length)\n        Transforms.deselect(editor)\n        editor.history = {undos: [], redos: []}\n        SAVING.set(editor, true)\n        setIsRedoing(editor, false)\n        editor.onChange()\n        return\n      }\n      editor.history.undos.push(step)\n      editor.history.redos.pop()\n    }\n  }\n}\n\n/**\n * This will adjust the operation paths and offsets according to the\n * remote patches by other editors since the step operations was performed.\n */\nfunction transformOperation(\n  editor: PortableTextSlateEditor,\n  patch: Patch,\n  operation: Operation,\n  snapshot: PortableTextBlock[] | undefined,\n  previousSnapshot: PortableTextBlock[] | undefined,\n): Operation[] {\n  if (debugVerbose) {\n    debug(\n      `Adjusting '${operation.type}' operation paths for '${patch.type}' patch`,\n    )\n    debug(`Operation ${JSON.stringify(operation)}`)\n    debug(`Patch ${JSON.stringify(patch)}`)\n  }\n\n  const transformedOperation = {...operation}\n\n  if (patch.type === 'insert' && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) =>\n      isEqual({_key: blk._key}, patch.path[0]),\n    )\n    debug(\n      `Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`,\n    )\n    return [\n      adjustBlockPath(\n        transformedOperation,\n        patch.items.length,\n        insertBlockIndex,\n      ),\n    ]\n  }\n\n  if (patch.type === 'unset' && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) =>\n      isEqual({_key: blk._key}, patch.path[0]),\n    )\n    // If this operation is targeting the same block that got removed, return empty\n    if (\n      'path' in transformedOperation &&\n      Array.isArray(transformedOperation.path) &&\n      transformedOperation.path[0] === unsetBlockIndex\n    ) {\n      debug('Skipping transformation that targeted removed block')\n      return []\n    }\n    if (debugVerbose) {\n      debug(`Selection ${JSON.stringify(editor.selection)}`)\n      debug(\n        `Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`,\n      )\n    }\n    return [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]\n  }\n\n  // Someone reset the whole value\n  if (patch.type === 'unset' && patch.path.length === 0) {\n    debug(\n      `Adjusting selection for unset everything patch and ${operation.type} operation`,\n    )\n    return []\n  }\n\n  if (patch.type === 'diffMatchPatch') {\n    const operationTargetBlock = findOperationTargetBlock(\n      editor,\n      transformedOperation,\n    )\n    if (\n      !operationTargetBlock ||\n      !isEqual({_key: operationTargetBlock._key}, patch.path[0])\n    ) {\n      return [transformedOperation]\n    }\n    const diffPatches = parsePatch(patch.value)\n    diffPatches.forEach((diffPatch) => {\n      let adjustOffsetBy = 0\n      let changedOffset = diffPatch.utf8Start1\n      const {diffs} = diffPatch\n      diffs.forEach((diff, index) => {\n        const [diffType, text] = diff\n        if (diffType === DIFF_INSERT) {\n          adjustOffsetBy += text.length\n          changedOffset += text.length\n        } else if (diffType === DIFF_DELETE) {\n          adjustOffsetBy -= text.length\n          changedOffset -= text.length\n        } else if (diffType === DIFF_EQUAL) {\n          // Only up to the point where there are no other changes\n          if (!diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL)) {\n            changedOffset += text.length\n          }\n        }\n      })\n      // Adjust accordingly if someone inserted text in the same node before us\n      if (transformedOperation.type === 'insert_text') {\n        if (changedOffset < transformedOperation.offset) {\n          transformedOperation.offset += adjustOffsetBy\n        }\n      }\n      // Adjust accordingly if someone removed text in the same node before us\n      if (transformedOperation.type === 'remove_text') {\n        if (\n          changedOffset <=\n          transformedOperation.offset - transformedOperation.text.length\n        ) {\n          transformedOperation.offset += adjustOffsetBy\n        }\n      }\n      // Adjust set_selection operation's points to new offset\n      if (transformedOperation.type === 'set_selection') {\n        const currentFocus = transformedOperation.properties?.focus\n          ? {...transformedOperation.properties.focus}\n          : undefined\n        const currentAnchor = transformedOperation?.properties?.anchor\n          ? {...transformedOperation.properties.anchor}\n          : undefined\n        const newFocus = transformedOperation?.newProperties?.focus\n          ? {...transformedOperation.newProperties.focus}\n          : undefined\n        const newAnchor = transformedOperation?.newProperties?.anchor\n          ? {...transformedOperation.newProperties.anchor}\n          : undefined\n        if ((currentFocus && currentAnchor) || (newFocus && newAnchor)) {\n          const points = [currentFocus, currentAnchor, newFocus, newAnchor]\n          points.forEach((point) => {\n            if (point && changedOffset < point.offset) {\n              point.offset += adjustOffsetBy\n            }\n          })\n          if (currentFocus && currentAnchor) {\n            transformedOperation.properties = {\n              focus: currentFocus,\n              anchor: currentAnchor,\n            }\n          }\n          if (newFocus && newAnchor) {\n            transformedOperation.newProperties = {\n              focus: newFocus,\n              anchor: newAnchor,\n            }\n          }\n        }\n      }\n    })\n    return [transformedOperation]\n  }\n  return [transformedOperation]\n}\n/**\n * Adjust the block path for a operation\n */\nfunction adjustBlockPath(\n  operation: Operation,\n  level: number,\n  blockIndex: number,\n): Operation {\n  const transformedOperation = {...operation}\n  if (\n    blockIndex >= 0 &&\n    transformedOperation.type !== 'set_selection' &&\n    Array.isArray(transformedOperation.path) &&\n    transformedOperation.path[0] >= blockIndex + level &&\n    transformedOperation.path[0] + level > -1\n  ) {\n    const newPath = [\n      transformedOperation.path[0] + level,\n      ...transformedOperation.path.slice(1),\n    ]\n    transformedOperation.path = newPath\n  }\n  if (transformedOperation.type === 'set_selection') {\n    const currentFocus = transformedOperation.properties?.focus\n      ? {...transformedOperation.properties.focus}\n      : undefined\n    const currentAnchor = transformedOperation?.properties?.anchor\n      ? {...transformedOperation.properties.anchor}\n      : undefined\n    const newFocus = transformedOperation?.newProperties?.focus\n      ? {...transformedOperation.newProperties.focus}\n      : undefined\n    const newAnchor = transformedOperation?.newProperties?.anchor\n      ? {...transformedOperation.newProperties.anchor}\n      : undefined\n    if ((currentFocus && currentAnchor) || (newFocus && newAnchor)) {\n      const points = [currentFocus, currentAnchor, newFocus, newAnchor]\n      points.forEach((point) => {\n        if (\n          point &&\n          point.path[0] >= blockIndex + level &&\n          point.path[0] + level > -1\n        ) {\n          point.path = [point.path[0] + level, ...point.path.slice(1)]\n        }\n      })\n      if (currentFocus && currentAnchor) {\n        transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor,\n        }\n      }\n      if (newFocus && newAnchor) {\n        transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor,\n        }\n      }\n    }\n  }\n  //   // Assign fresh point objects (we don't want to mutate the original ones)\n  return transformedOperation\n}\n\n// Helper functions for editor.apply above\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  // Text input\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path) &&\n    op.text !== ' ' // Tokenize between words\n  ) {\n    return true\n  }\n\n  // Text deletion\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  // Don't merge\n  return false\n}\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined,\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n\nexport function withoutSaving(editor: Editor, fn: () => void): void {\n  const prev = isSaving(editor)\n  SAVING.set(editor, false)\n  fn()\n  SAVING.set(editor, prev)\n}\n\nfunction createSelectOperation(editor: Editor): SelectionOperation {\n  return {\n    type: 'set_selection',\n    properties: {...editor.selection},\n    newProperties: {...editor.selection},\n  }\n}\n\nfunction findOperationTargetBlock(\n  editor: PortableTextSlateEditor,\n  operation: Operation,\n): Descendant | undefined {\n  let block: Descendant | undefined\n  if (operation.type === 'set_selection' && editor.selection) {\n    block = editor.children[editor.selection.focus.path[0]]\n  } else if ('path' in operation) {\n    block = editor.children[operation.path[0]]\n  }\n  return block\n}\n","import type {Path} from '@sanity/types'\nimport {Editor, Node, Range, Text, Transforms} from 'slate'\nimport {parseAnnotation} from '../internal-utils/parse-blocks'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\n/**\n * @public\n */\nexport type AddedAnnotationPaths = {\n  /**\n   * @deprecated An annotation may be applied to multiple blocks, resulting\n   * in multiple `markDef`'s being created. Use `markDefPaths` instead.\n   */\n  markDefPath: Path\n  markDefPaths: Array<Path>\n  /**\n   * @deprecated Does not return anything meaningful since an annotation\n   * can span multiple blocks and spans. If references the span closest\n   * to the focus point of the selection.\n   */\n  spanPath: Path\n}\n\nexport const addAnnotationOperationImplementation: BehaviorOperationImplementation<\n  'annotation.add',\n  AddedAnnotationPaths | undefined\n> = ({context, operation}) => {\n  const parsedAnnotation = parseAnnotation({\n    annotation: {\n      _type: operation.annotation.name,\n      ...operation.annotation.value,\n    },\n    context,\n    options: {refreshKeys: false, validateFields: true},\n  })\n\n  if (!parsedAnnotation) {\n    throw new Error(\n      `Failed to parse annotation ${JSON.stringify(operation.annotation)}`,\n    )\n  }\n\n  const editor = operation.editor\n\n  if (!editor.selection || Range.isCollapsed(editor.selection)) {\n    return\n  }\n\n  let paths: AddedAnnotationPaths | undefined = undefined\n  let spanPath: Path | undefined\n  let markDefPath: Path | undefined\n  const markDefPaths: Path[] = []\n\n  const selectedBlocks = Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node),\n    reverse: Range.isBackward(editor.selection),\n  })\n\n  let blockIndex = 0\n\n  for (const [block, blockPath] of selectedBlocks) {\n    if (block.children.length === 0) {\n      continue\n    }\n\n    if (block.children.length === 1 && block.children[0].text === '') {\n      continue\n    }\n\n    // Make sure we don't generate more keys than needed\n    const annotationKey =\n      blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator()\n    const markDefs = block.markDefs ?? []\n    const existingMarkDef = markDefs.find(\n      (markDef) =>\n        markDef._type === parsedAnnotation._type &&\n        markDef._key === annotationKey,\n    )\n\n    if (existingMarkDef === undefined) {\n      Transforms.setNodes(\n        editor,\n        {\n          markDefs: [\n            ...markDefs,\n            {\n              ...parsedAnnotation,\n              _key: annotationKey,\n            },\n          ],\n        },\n        {at: blockPath},\n      )\n\n      markDefPath = [{_key: block._key}, 'markDefs', {_key: annotationKey}]\n\n      if (Range.isBackward(editor.selection)) {\n        markDefPaths.unshift(markDefPath)\n      } else {\n        markDefPaths.push(markDefPath)\n      }\n    }\n\n    Transforms.setNodes(editor, {}, {match: Text.isText, split: true})\n\n    const children = Node.children(editor, blockPath)\n\n    for (const [span, path] of children) {\n      if (!editor.isTextSpan(span)) {\n        continue\n      }\n\n      if (!Range.includes(editor.selection, path)) {\n        continue\n      }\n\n      const marks = span.marks ?? []\n      const existingSameTypeAnnotations = marks.filter((mark) =>\n        markDefs.some(\n          (markDef) =>\n            markDef._key === mark && markDef._type === parsedAnnotation._type,\n        ),\n      )\n\n      Transforms.setNodes(\n        editor,\n        {\n          marks: [\n            ...marks.filter(\n              (mark) => !existingSameTypeAnnotations.includes(mark),\n            ),\n            annotationKey,\n          ],\n        },\n        {at: path},\n      )\n\n      spanPath = [{_key: block._key}, 'children', {_key: span._key}]\n    }\n\n    blockIndex++\n  }\n\n  if (markDefPath && spanPath) {\n    paths = {\n      markDefPath,\n      markDefPaths,\n      spanPath,\n    }\n  }\n\n  return paths\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport {Editor, Node, Path, Range, Transforms} from 'slate'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const removeAnnotationOperationImplementation: BehaviorOperationImplementation<\n  'annotation.remove'\n> = ({operation}) => {\n  const editor = operation.editor\n\n  if (!editor.selection) {\n    return\n  }\n\n  if (Range.isCollapsed(editor.selection)) {\n    const [block, blockPath] = Editor.node(editor, editor.selection, {\n      depth: 1,\n    })\n\n    if (!editor.isTextBlock(block)) {\n      return\n    }\n\n    const markDefs = block.markDefs ?? []\n    const potentialAnnotations = markDefs.filter(\n      (markDef) => markDef._type === operation.annotation.name,\n    )\n\n    const [selectedChild, selectedChildPath] = Editor.node(\n      editor,\n      editor.selection,\n      {\n        depth: 2,\n      },\n    )\n\n    if (!editor.isTextSpan(selectedChild)) {\n      return\n    }\n\n    const annotationToRemove = selectedChild.marks?.find((mark) =>\n      potentialAnnotations.some((markDef) => markDef._key === mark),\n    )\n\n    if (!annotationToRemove) {\n      return\n    }\n\n    const previousSpansWithSameAnnotation: Array<\n      [span: PortableTextSpan, path: Path]\n    > = []\n\n    for (const [child, childPath] of Node.children(editor, blockPath, {\n      reverse: true,\n    })) {\n      if (!editor.isTextSpan(child)) {\n        continue\n      }\n\n      if (!Path.isBefore(childPath, selectedChildPath)) {\n        continue\n      }\n\n      if (child.marks?.includes(annotationToRemove)) {\n        previousSpansWithSameAnnotation.push([child, childPath])\n      } else {\n        break\n      }\n    }\n\n    const nextSpansWithSameAnnotation: Array<\n      [span: PortableTextSpan, path: Path]\n    > = []\n\n    for (const [child, childPath] of Node.children(editor, blockPath)) {\n      if (!editor.isTextSpan(child)) {\n        continue\n      }\n\n      if (!Path.isAfter(childPath, selectedChildPath)) {\n        continue\n      }\n\n      if (child.marks?.includes(annotationToRemove)) {\n        nextSpansWithSameAnnotation.push([child, childPath])\n      } else {\n        break\n      }\n    }\n\n    for (const [child, childPath] of [\n      ...previousSpansWithSameAnnotation,\n      [selectedChild, selectedChildPath] as const,\n      ...nextSpansWithSameAnnotation,\n    ]) {\n      Transforms.setNodes(\n        editor,\n        {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove),\n        },\n        {at: childPath},\n      )\n    }\n  } else {\n    Transforms.setNodes(\n      editor,\n      {},\n      {\n        match: (node) => editor.isTextSpan(node),\n        split: true,\n        hanging: true,\n      },\n    )\n\n    const blocks = Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    })\n\n    for (const [block, blockPath] of blocks) {\n      const children = Node.children(editor, blockPath)\n\n      for (const [child, childPath] of children) {\n        if (!editor.isTextSpan(child)) {\n          continue\n        }\n\n        if (!Range.includes(editor.selection, childPath)) {\n          continue\n        }\n\n        const markDefs = block.markDefs ?? []\n        const marks = child.marks ?? []\n        const marksWithoutAnnotation = marks.filter((mark) => {\n          const markDef = markDefs.find((markDef) => markDef._key === mark)\n          return markDef?._type !== operation.annotation.name\n        })\n\n        if (marksWithoutAnnotation.length !== marks.length) {\n          Transforms.setNodes(\n            editor,\n            {\n              marks: marksWithoutAnnotation,\n            },\n            {at: childPath},\n          )\n        }\n      }\n    }\n  }\n}\n","import {Editor, Transforms, type Element as SlateElement} from 'slate'\nimport {parseBlock} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {fromSlateValue, toSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const blockSetOperationImplementation: BehaviorOperationImplementation<\n  'block.set'\n> = ({context, operation}) => {\n  const location = toSlateRange(\n    {\n      anchor: {path: operation.at, offset: 0},\n      focus: {path: operation.at, offset: 0},\n    },\n    operation.editor,\n  )\n\n  if (!location) {\n    throw new Error(\n      `Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`,\n    )\n  }\n\n  const blockEntry = Editor.node(operation.editor, location, {depth: 1})\n  const block = blockEntry?.[0]\n\n  if (!block) {\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`)\n  }\n\n  const parsedBlock = fromSlateValue(\n    [block],\n    context.schema.block.name,\n    KEY_TO_VALUE_ELEMENT.get(operation.editor),\n  ).at(0)\n\n  if (!parsedBlock) {\n    throw new Error(`Unable to parse block at ${JSON.stringify(operation.at)}`)\n  }\n\n  const {_type, ...filteredProps} = operation.props\n\n  const updatedBlock = parseBlock({\n    context,\n    block: {\n      ...parsedBlock,\n      ...filteredProps,\n    },\n    options: {refreshKeys: false, validateFields: true},\n  })\n\n  if (!updatedBlock) {\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`)\n  }\n\n  const slateBlock = toSlateValue([updatedBlock], {\n    schemaTypes: context.schema,\n  })?.at(0) as SlateElement | undefined\n\n  if (!slateBlock) {\n    throw new Error(`Unable to convert block to Slate value`)\n  }\n\n  Transforms.setNodes(operation.editor, slateBlock, {at: location})\n}\n","import {omit} from 'lodash'\nimport {Editor, Transforms} from 'slate'\nimport {isTextBlock, parseBlock} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const blockUnsetOperationImplementation: BehaviorOperationImplementation<\n  'block.unset'\n> = ({context, operation}) => {\n  const location = toSlateRange(\n    {\n      anchor: {path: operation.at, offset: 0},\n      focus: {path: operation.at, offset: 0},\n    },\n    operation.editor,\n  )\n\n  if (!location) {\n    throw new Error(\n      `Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`,\n    )\n  }\n\n  const blockEntry = Editor.node(operation.editor, location, {depth: 1})\n  const block = blockEntry?.[0]\n\n  if (!block) {\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`)\n  }\n\n  const parsedBlock = fromSlateValue(\n    [block],\n    context.schema.block.name,\n    KEY_TO_VALUE_ELEMENT.get(operation.editor),\n  ).at(0)\n\n  if (!parsedBlock) {\n    throw new Error(`Unable to parse block at ${JSON.stringify(operation.at)}`)\n  }\n\n  if (isTextBlock(context, parsedBlock)) {\n    const propsToRemove = operation.props.filter((prop) => prop !== '_type')\n\n    const updatedTextBlock = parseBlock({\n      context,\n      block: omit(parsedBlock, propsToRemove),\n      options: {refreshKeys: false, validateFields: true},\n    })\n\n    if (!updatedTextBlock) {\n      throw new Error(\n        `Unable to update block at ${JSON.stringify(operation.at)}`,\n      )\n    }\n\n    const propsToSet: Record<string, unknown> = {}\n\n    for (const prop of propsToRemove) {\n      if (!(prop in updatedTextBlock)) {\n        propsToSet[prop] = undefined\n      } else {\n        propsToSet[prop] = (updatedTextBlock as Record<string, unknown>)[prop]\n      }\n    }\n\n    Transforms.setNodes(operation.editor, propsToSet, {at: location})\n\n    return\n  }\n\n  const updatedBlockObject = parseBlock({\n    context,\n    block: omit(\n      parsedBlock,\n      operation.props.filter((prop) => prop !== '_type'),\n    ),\n    options: {refreshKeys: false, validateFields: true},\n  })\n\n  if (!updatedBlockObject) {\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`)\n  }\n\n  const {_type, _key, ...props} = updatedBlockObject\n\n  Transforms.setNodes(\n    operation.editor,\n    {\n      _type,\n      _key,\n      value: props,\n    },\n    {at: location},\n  )\n}\n","import {Editor, Range, Text, Transforms} from 'slate'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const decoratorAddOperationImplementation: BehaviorOperationImplementation<\n  'decorator.add'\n> = ({context, operation}) => {\n  const editor = operation.editor\n  const mark = operation.decorator\n  const value = fromSlateValue(\n    editor.children,\n    context.schema.block.name,\n    KEY_TO_VALUE_ELEMENT.get(editor),\n  )\n\n  const manualAnchor = operation.at?.anchor\n    ? utils.blockOffsetToSpanSelectionPoint({\n        context: {\n          ...context,\n          value,\n        },\n        blockOffset: operation.at.anchor,\n        direction: 'backward',\n      })\n    : undefined\n  const manualFocus = operation.at?.focus\n    ? utils.blockOffsetToSpanSelectionPoint({\n        context: {\n          ...context,\n          value,\n        },\n        blockOffset: operation.at.focus,\n        direction: 'forward',\n      })\n    : undefined\n  const manualSelection =\n    manualAnchor && manualFocus\n      ? {\n          anchor: manualAnchor,\n          focus: manualFocus,\n        }\n      : undefined\n\n  const selection = manualSelection\n    ? (toSlateRange(manualSelection, operation.editor) ?? editor.selection)\n    : editor.selection\n\n  if (!selection) {\n    return\n  }\n\n  const editorSelection = slateRangeToSelection({\n    schema: context.schema,\n    editor,\n    range: selection,\n  })\n  const anchorOffset = editorSelection\n    ? utils.selectionPointToBlockOffset({\n        context: {\n          ...context,\n          value,\n        },\n        selectionPoint: editorSelection.anchor,\n      })\n    : undefined\n  const focusOffset = editorSelection\n    ? utils.selectionPointToBlockOffset({\n        context: {\n          ...context,\n          value,\n        },\n        selectionPoint: editorSelection.focus,\n      })\n    : undefined\n\n  if (!anchorOffset || !focusOffset) {\n    throw new Error('Unable to find anchor or focus offset')\n  }\n\n  if (Range.isExpanded(selection)) {\n    // Split if needed\n    Transforms.setNodes(\n      editor,\n      {},\n      {at: selection, match: Text.isText, split: true, hanging: true},\n    )\n\n    // The value might have changed after splitting\n    const newValue = fromSlateValue(\n      editor.children,\n      context.schema.block.name,\n      KEY_TO_VALUE_ELEMENT.get(editor),\n    )\n    // We need to find the new selection from the original offsets because the\n    // split operation might have changed the value.\n    const newSelection = utils.blockOffsetsToSelection({\n      context: {\n        ...context,\n        value: newValue,\n      },\n      offsets: {anchor: anchorOffset, focus: focusOffset},\n      backward: editorSelection?.backward,\n    })\n\n    const trimmedSelection = selectors.getTrimmedSelection({\n      beta: {\n        activeAnnotations: [],\n        activeDecorators: [],\n      },\n      context: {\n        converters: [],\n        keyGenerator: context.keyGenerator,\n        readOnly: false,\n        schema: context.schema,\n        selection: newSelection,\n        value: newValue,\n      },\n    })\n\n    if (!trimmedSelection) {\n      throw new Error('Unable to find trimmed selection')\n    }\n\n    const newRange = toSlateRange(trimmedSelection, editor)\n\n    if (!newRange) {\n      throw new Error('Unable to find new selection')\n    }\n\n    // Use new selection to find nodes to decorate\n    const splitTextNodes = Range.isRange(newRange)\n      ? [\n          ...Editor.nodes(editor, {\n            at: newRange,\n            match: (node) => Text.isText(node),\n          }),\n        ]\n      : []\n\n    for (const [node, path] of splitTextNodes) {\n      const marks = [\n        ...(Array.isArray(node.marks) ? node.marks : []).filter(\n          (eMark: string) => eMark !== mark,\n        ),\n        mark,\n      ]\n      Transforms.setNodes(\n        editor,\n        {marks},\n        {at: path, match: Text.isText, split: true, hanging: true},\n      )\n    }\n  } else {\n    const selectedSpan = Array.from(\n      Editor.nodes(editor, {\n        at: selection,\n        match: (node) => editor.isTextSpan(node),\n      }),\n    )?.at(0)\n\n    if (!selectedSpan) {\n      return\n    }\n\n    const [block, blockPath] = Editor.node(editor, selection, {\n      depth: 1,\n    })\n    const lonelyEmptySpan =\n      editor.isTextBlock(block) &&\n      block.children.length === 1 &&\n      editor.isTextSpan(block.children[0]) &&\n      block.children[0].text === ''\n        ? block.children[0]\n        : undefined\n\n    if (lonelyEmptySpan) {\n      const existingMarks = lonelyEmptySpan.marks ?? []\n      const existingMarksWithoutDecorator = existingMarks.filter(\n        (existingMark) => existingMark !== mark,\n      )\n\n      Transforms.setNodes(\n        editor,\n        {\n          marks:\n            existingMarks.length === existingMarksWithoutDecorator.length\n              ? [...existingMarks, mark]\n              : existingMarksWithoutDecorator,\n        },\n        {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node),\n        },\n      )\n    } else {\n      editor.decoratorState[mark] = true\n    }\n  }\n\n  if (editor.selection) {\n    // Reselect\n    const selection = editor.selection\n    editor.selection = {...selection}\n  }\n}\n","import {Transforms} from 'slate'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {getBlockPath} from '../internal-utils/slate-utils'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const deleteOperationImplementation: BehaviorOperationImplementation<\n  'delete'\n> = ({operation}) => {\n  const anchorBlockKey = getBlockKeyFromSelectionPoint(operation.at.anchor)\n  const focusBlockKey = getBlockKeyFromSelectionPoint(operation.at.focus)\n\n  const anchorBlockPath =\n    anchorBlockKey !== undefined\n      ? getBlockPath({\n          editor: operation.editor,\n          _key: anchorBlockKey,\n        })\n      : undefined\n  const focusBlockPath =\n    focusBlockKey !== undefined\n      ? getBlockPath({\n          editor: operation.editor,\n          _key: focusBlockKey,\n        })\n      : undefined\n\n  if (\n    operation.at.anchor.path.length === 1 &&\n    operation.at.focus.path.length === 1 &&\n    anchorBlockPath &&\n    focusBlockPath &&\n    anchorBlockPath[0] === focusBlockPath[0]\n  ) {\n    Transforms.removeNodes(operation.editor, {\n      at: [anchorBlockPath[0]],\n    })\n\n    return\n  }\n\n  const range = toSlateRange(operation.at, operation.editor)\n\n  if (!range) {\n    throw new Error(\n      `Failed to get Slate Range for selection ${JSON.stringify(operation.at)}`,\n    )\n  }\n\n  operation.editor.delete({\n    at: range,\n    reverse: operation.direction === 'backward',\n    unit: operation.unit,\n  })\n}\n","import {Editor, Transforms, type Element} from 'slate'\nimport {parseInlineObject} from '../internal-utils/parse-blocks'\nimport {toSlateValue} from '../internal-utils/values'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const insertInlineObjectOperationImplementation: BehaviorOperationImplementation<\n  'insert.inline object'\n> = ({context, operation}) => {\n  const parsedInlineObject = parseInlineObject({\n    context,\n    inlineObject: {\n      _type: operation.inlineObject.name,\n      ...(operation.inlineObject.value ?? {}),\n    },\n    options: {refreshKeys: false, validateFields: true},\n  })\n\n  if (!parsedInlineObject) {\n    throw new Error(\n      `Failed to parse inline object ${JSON.stringify(operation.inlineObject)}`,\n    )\n  }\n\n  if (!operation.editor.selection) {\n    console.error('Unable to insert inline object without selection')\n    return\n  }\n\n  const [focusTextBlock] = Array.from(\n    Editor.nodes(operation.editor, {\n      at: operation.editor.selection.focus.path,\n      match: (node) => operation.editor.isTextBlock(node),\n    }),\n  ).at(0) ?? [undefined, undefined]\n\n  if (!focusTextBlock) {\n    console.error('Unable to perform action without focus text block')\n    return\n  }\n\n  const block = toSlateValue(\n    [\n      {\n        _type: context.schema.block.name,\n        _key: context.keyGenerator(),\n        children: [parsedInlineObject],\n      },\n    ],\n    {schemaTypes: context.schema},\n  ).at(0) as unknown as Element\n  const child = block?.children.at(0)\n\n  if (!child) {\n    console.error('Unable to insert inline object')\n    return\n  }\n\n  Transforms.insertNodes(operation.editor, child)\n}\n","import {Editor, Transforms} from 'slate'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const insertSpanOperationImplementation: BehaviorOperationImplementation<\n  'insert.span'\n> = ({context, operation}) => {\n  if (!operation.editor.selection) {\n    console.error('Unable to perform action without selection', operation)\n    return\n  }\n\n  const [focusBlock, focusBlockPath] = Array.from(\n    Editor.nodes(operation.editor, {\n      at: operation.editor.selection.focus.path,\n      match: (node) => operation.editor.isTextBlock(node),\n    }),\n  )[0] ?? [undefined, undefined]\n\n  if (!focusBlock || !focusBlockPath) {\n    console.error('Unable to perform action without focus block', operation)\n    return\n  }\n\n  const markDefs = focusBlock.markDefs ?? []\n  const annotations = operation.annotations\n    ? operation.annotations.map((annotation) => ({\n        _type: annotation.name,\n        _key: context.keyGenerator(),\n        ...annotation.value,\n      }))\n    : undefined\n\n  if (annotations && annotations.length > 0) {\n    Transforms.setNodes(operation.editor, {\n      markDefs: [...markDefs, ...annotations],\n    })\n  }\n\n  Transforms.insertNodes(operation.editor, {\n    _type: 'span',\n    _key: context.keyGenerator(),\n    text: operation.text,\n    marks: [\n      ...(annotations?.map((annotation) => annotation._key) ?? []),\n      ...(operation.decorators ?? []),\n    ],\n  })\n}\n","import {Editor, Path, Point, Range, Transforms, type Descendant} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport {parseBlock} from '../internal-utils/parse-blocks'\nimport {\n  getFocusBlock,\n  getFocusChild,\n  getLastBlock,\n  getSelectionEndBlock,\n  getSelectionStartBlock,\n} from '../internal-utils/slate-utils'\nimport {isEqualToEmptyEditor, toSlateValue} from '../internal-utils/values'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const insertBlockOperationImplementation: BehaviorOperationImplementation<\n  'insert.block'\n> = ({context, operation}) => {\n  const parsedBlock = parseBlock({\n    block: operation.block,\n    context,\n    options: {refreshKeys: false, validateFields: true},\n  })\n\n  if (!parsedBlock) {\n    throw new Error(`Failed to parse block ${JSON.stringify(operation.block)}`)\n  }\n\n  const fragment = toSlateValue([parsedBlock], {schemaTypes: context.schema})[0]\n\n  if (!fragment) {\n    throw new Error(\n      `Failed to convert block to Slate fragment ${JSON.stringify(parsedBlock)}`,\n    )\n  }\n\n  insertBlock({\n    block: fragment,\n    placement: operation.placement,\n    select: operation.select ?? 'start',\n    editor: operation.editor,\n    schema: context.schema,\n  })\n}\n\nexport function insertBlock({\n  block,\n  placement,\n  select,\n  editor,\n  schema,\n}: {\n  block: Descendant\n  placement: 'auto' | 'after' | 'before'\n  select: 'start' | 'end' | 'none'\n  editor: PortableTextSlateEditor\n  schema: EditorSchema\n}) {\n  const [startBlock, startBlockPath] = getSelectionStartBlock({editor})\n  const [endBlock, endBlockPath] = getSelectionEndBlock({editor})\n\n  if (\n    !editor.selection ||\n    !startBlock ||\n    !startBlockPath ||\n    !endBlock ||\n    !endBlockPath\n  ) {\n    if (select !== 'none') {\n      DOMEditor.focus(editor)\n    }\n\n    const [lastBlock, lastBlockPath] = getLastBlock({editor})\n\n    if (placement === 'before') {\n      Transforms.insertNodes(editor, [block], {at: [0]})\n\n      if (select === 'start') {\n        Transforms.select(editor, Editor.start(editor, [0]))\n      } else if (select === 'end') {\n        Transforms.select(editor, Editor.end(editor, [0]))\n      }\n    } else if (placement === 'after') {\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0]\n      Transforms.insertNodes(editor, [block], {at: nextPath})\n\n      if (select === 'start') {\n        Transforms.select(editor, Editor.start(editor, nextPath))\n      } else if (select === 'end') {\n        Transforms.select(editor, Editor.end(editor, nextPath))\n      }\n    } else {\n      // placement === 'auto'\n\n      if (lastBlock && isEqualToEmptyEditor([lastBlock], schema)) {\n        // And if the last block was an empty text block, let's remove\n        // that too\n        Transforms.removeNodes(editor, {at: lastBlockPath})\n\n        Transforms.insertNodes(editor, [block], {\n          at: lastBlockPath,\n          select: false,\n        })\n\n        Transforms.deselect(editor)\n\n        if (select === 'start') {\n          Transforms.select(editor, Editor.start(editor, lastBlockPath))\n        } else if (select === 'end') {\n          Transforms.select(editor, Editor.end(editor, lastBlockPath))\n        }\n\n        return\n      }\n\n      if (\n        editor.isTextBlock(block) &&\n        lastBlock &&\n        editor.isTextBlock(lastBlock)\n      ) {\n        const selectionBefore = Editor.end(editor, lastBlockPath)\n\n        Transforms.insertFragment(editor, [block], {\n          at: Editor.end(editor, lastBlockPath),\n        })\n\n        if (select === 'start') {\n          Transforms.select(editor, selectionBefore)\n        } else if (select === 'none') {\n          Transforms.deselect(editor)\n        }\n\n        return\n      }\n\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0]\n\n      Transforms.insertNodes(editor, [block], {at: nextPath, select: false})\n\n      if (select === 'start') {\n        Transforms.select(editor, Editor.start(editor, nextPath))\n      } else if (select === 'end') {\n        Transforms.select(editor, Editor.end(editor, nextPath))\n      }\n    }\n  } else {\n    if (placement === 'before') {\n      const currentSelection = editor.selection\n      const selectionStartPoint = Range.start(currentSelection)\n\n      Transforms.insertNodes(editor, [block], {\n        at: [selectionStartPoint.path[0]],\n        select: false,\n      })\n\n      if (select === 'start') {\n        Transforms.select(\n          editor,\n          Editor.start(editor, [selectionStartPoint.path[0]]),\n        )\n      } else if (select === 'end') {\n        Transforms.select(\n          editor,\n          Editor.end(editor, [selectionStartPoint.path[0]]),\n        )\n      }\n    } else if (placement === 'after') {\n      const currentSelection = editor.selection\n      const selectionEndPoint = Range.end(currentSelection)\n\n      const nextPath = [selectionEndPoint.path[0] + 1]\n\n      Transforms.insertNodes(editor, [block], {\n        at: nextPath,\n        select: false,\n      })\n\n      if (select === 'start') {\n        Transforms.select(editor, Editor.start(editor, nextPath))\n      } else if (select === 'end') {\n        Transforms.select(editor, Editor.end(editor, nextPath))\n      }\n    } else {\n      // placement === 'auto'\n\n      const currentSelection = editor.selection\n      const endBlockEndPoint = Editor.start(editor, endBlockPath)\n\n      if (Range.isExpanded(currentSelection) && !editor.isTextBlock(block)) {\n        Transforms.delete(editor, {at: currentSelection})\n\n        const newSelection = editor.selection\n\n        const [focusBlock, focusBlockPath] = getFocusBlock({editor})\n\n        Transforms.insertNodes(editor, [block], {\n          voids: true,\n        })\n\n        const adjustedSelection =\n          newSelection.anchor.offset === 0\n            ? Range.transform(newSelection, {\n                type: 'insert_node',\n                node: block,\n                path: [newSelection.anchor.path[0]],\n              })\n            : newSelection\n\n        if (select === 'none' && adjustedSelection) {\n          Transforms.select(editor, adjustedSelection)\n        }\n\n        if (focusBlock && isEqualToEmptyEditor([focusBlock], schema)) {\n          Transforms.removeNodes(editor, {at: focusBlockPath})\n        }\n\n        return\n      }\n\n      if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {\n        const selectionStartPoint = Range.start(currentSelection)\n\n        if (isEqualToEmptyEditor([endBlock], schema)) {\n          const currentSelection = editor.selection\n\n          Transforms.insertNodes(editor, [block], {\n            at: endBlockPath,\n            select: false,\n          })\n          Transforms.removeNodes(editor, {at: Path.next(endBlockPath)})\n\n          if (select === 'start') {\n            Transforms.select(editor, selectionStartPoint)\n          } else if (select === 'end') {\n            Transforms.select(editor, Editor.end(editor, endBlockPath))\n          } else {\n            Transforms.select(editor, currentSelection)\n          }\n\n          return\n        }\n\n        if (select === 'end') {\n          Transforms.insertFragment(editor, [block], {\n            voids: true,\n          })\n\n          return\n        }\n\n        Transforms.insertFragment(editor, [block], {\n          at: currentSelection,\n          voids: true,\n        })\n\n        if (select === 'start') {\n          Transforms.select(editor, selectionStartPoint)\n        } else {\n          if (!Point.equals(selectionStartPoint, endBlockEndPoint)) {\n            Transforms.select(editor, selectionStartPoint)\n          }\n        }\n      } else {\n        if (!editor.isTextBlock(endBlock)) {\n          Transforms.insertNodes(editor, [block], {select: false})\n\n          const nextPath = [endBlockPath[0] + 1]\n\n          if (select === 'start') {\n            Transforms.select(editor, Editor.start(editor, nextPath))\n          } else if (select === 'end') {\n            Transforms.select(editor, Editor.end(editor, nextPath))\n          }\n        } else {\n          const endBlockStartPoint = Editor.start(editor, endBlockPath)\n          const endBlockEndPoint = Editor.end(editor, endBlockPath)\n          const selectionStartPoint = Range.start(currentSelection)\n          const selectionEndPoint = Range.end(currentSelection)\n\n          if (\n            Range.isCollapsed(currentSelection) &&\n            Point.equals(selectionStartPoint, endBlockStartPoint)\n          ) {\n            Transforms.insertNodes(editor, [block], {\n              at: endBlockPath,\n              select: false,\n            })\n\n            if (select === 'start' || select === 'end') {\n              Transforms.select(editor, Editor.start(editor, endBlockPath))\n            }\n\n            if (isEqualToEmptyEditor([endBlock], schema)) {\n              Transforms.removeNodes(editor, {at: Path.next(endBlockPath)})\n            }\n          } else if (\n            Range.isCollapsed(currentSelection) &&\n            Point.equals(selectionEndPoint, endBlockEndPoint)\n          ) {\n            const nextPath = [endBlockPath[0] + 1]\n\n            Transforms.insertNodes(editor, [block], {\n              at: nextPath,\n              select: false,\n            })\n\n            if (select === 'start' || select === 'end') {\n              Transforms.select(editor, Editor.start(editor, nextPath))\n            }\n          } else if (\n            Range.isExpanded(currentSelection) &&\n            Point.equals(selectionStartPoint, endBlockStartPoint) &&\n            Point.equals(selectionEndPoint, endBlockEndPoint)\n          ) {\n            Transforms.insertFragment(editor, [block], {\n              at: currentSelection,\n            })\n\n            if (select === 'start') {\n              Transforms.select(editor, Editor.start(editor, endBlockPath))\n            } else if (select === 'end') {\n              Transforms.select(editor, Editor.end(editor, endBlockPath))\n            }\n          } else if (\n            Range.isExpanded(currentSelection) &&\n            Point.equals(selectionStartPoint, endBlockStartPoint)\n          ) {\n            Transforms.insertFragment(editor, [block], {\n              at: currentSelection,\n            })\n\n            if (select === 'start') {\n              Transforms.select(editor, Editor.start(editor, endBlockPath))\n            } else if (select === 'end') {\n              Transforms.select(editor, Editor.end(editor, endBlockPath))\n            }\n          } else if (\n            Range.isExpanded(currentSelection) &&\n            Point.equals(selectionEndPoint, endBlockEndPoint)\n          ) {\n            Transforms.insertFragment(editor, [block], {\n              at: currentSelection,\n            })\n\n            if (select === 'start') {\n              Transforms.select(\n                editor,\n                Editor.start(editor, Path.next(endBlockPath)),\n              )\n            } else if (select === 'end') {\n              Transforms.select(\n                editor,\n                Editor.end(editor, Path.next(endBlockPath)),\n              )\n            }\n          } else {\n            const currentSelection = editor.selection\n            const [focusChild] = getFocusChild({editor})\n\n            if (focusChild && editor.isTextSpan(focusChild)) {\n              Transforms.splitNodes(editor, {\n                at: currentSelection,\n              })\n\n              Transforms.insertFragment(editor, [block], {\n                at: currentSelection,\n              })\n\n              if (select === 'start' || select === 'end') {\n                Transforms.select(editor, [endBlockPath[0] + 1])\n              } else {\n                Transforms.select(editor, currentSelection)\n              }\n            } else {\n              const nextPath = [endBlockPath[0] + 1]\n              Transforms.insertNodes(editor, [block], {\n                at: nextPath,\n                select: false,\n              })\n              Transforms.select(editor, currentSelection)\n\n              if (select === 'start') {\n                Transforms.select(editor, Editor.start(editor, nextPath))\n              } else if (select === 'end') {\n                Transforms.select(editor, Editor.end(editor, nextPath))\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import {Transforms} from 'slate'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const moveBackwardOperationImplementation: BehaviorOperationImplementation<\n  'move.backward'\n> = ({operation}) => {\n  Transforms.move(operation.editor, {\n    unit: 'character',\n    distance: operation.distance,\n    reverse: true,\n  })\n}\n","import {Transforms} from 'slate'\nimport {toSlatePath} from '../internal-utils/paths'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const moveBlockOperationImplementation: BehaviorOperationImplementation<\n  'move.block'\n> = ({operation}) => {\n  const at = [toSlatePath(operation.at, operation.editor)[0]]\n  const to = [toSlatePath(operation.to, operation.editor)[0]]\n\n  Transforms.moveNodes(operation.editor, {\n    at,\n    to,\n    mode: 'highest',\n  })\n}\n","import {Transforms} from 'slate'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const moveForwardOperationImplementation: BehaviorOperationImplementation<\n  'move.forward'\n> = ({operation}) => {\n  Transforms.move(operation.editor, {\n    unit: 'character',\n    distance: operation.distance,\n  })\n}\n","import {Transforms} from 'slate'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport type {BehaviorOperationImplementation} from './behavior.operations'\n\nexport const selectOperationImplementation: BehaviorOperationImplementation<\n  'select'\n> = ({operation}) => {\n  const newSelection = toSlateRange(operation.at, operation.editor)\n\n  if (newSelection) {\n    Transforms.select(operation.editor, newSelection)\n  } else {\n    Transforms.deselect(operation.editor)\n  }\n}\n","import type {\n  AbstractBehaviorEventType,\n  SyntheticBehaviorEvent,\n} from '../behaviors/behavior.types.event'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {removeDecoratorOperationImplementation} from '../editor/plugins/createWithPortableTextMarkModel'\nimport {\n  historyRedoOperationImplementation,\n  historyUndoOperationImplementation,\n} from '../editor/plugins/createWithUndoRedo'\nimport type {OmitFromUnion, PickFromUnion} from '../type-utils'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {addAnnotationOperationImplementation} from './behavior.operation.annotation.add'\nimport {removeAnnotationOperationImplementation} from './behavior.operation.annotation.remove'\nimport {blockSetOperationImplementation} from './behavior.operation.block.set'\nimport {blockUnsetOperationImplementation} from './behavior.operation.block.unset'\nimport {decoratorAddOperationImplementation} from './behavior.operation.decorator.add'\nimport {deleteOperationImplementation} from './behavior.operation.delete'\nimport {insertInlineObjectOperationImplementation} from './behavior.operation.insert-inline-object'\nimport {insertSpanOperationImplementation} from './behavior.operation.insert-span'\nimport {insertBlockOperationImplementation} from './behavior.operation.insert.block'\nimport {insertTextOperationImplementation} from './behavior.operation.insert.text'\nimport {moveBackwardOperationImplementation} from './behavior.operation.move.backward'\nimport {moveBlockOperationImplementation} from './behavior.operation.move.block'\nimport {moveForwardOperationImplementation} from './behavior.operation.move.forward'\nimport {selectOperationImplementation} from './behavior.operation.select'\n\nexport type BehaviorOperationImplementationContext = Pick<\n  EditorContext,\n  'keyGenerator' | 'schema'\n>\n\nexport type BehaviorOperationImplementation<\n  TBehaviorOperationType extends BehaviorOperation['type'],\n  TReturnType = void,\n> = ({\n  context,\n  operation,\n}: {\n  context: BehaviorOperationImplementationContext\n  operation: PickFromUnion<BehaviorOperation, 'type', TBehaviorOperationType>\n}) => TReturnType\n\ntype BehaviorOperation = OmitFromUnion<\n  SyntheticBehaviorEvent,\n  'type',\n  AbstractBehaviorEventType\n> & {\n  editor: PortableTextSlateEditor\n}\n\ntype BehaviorOperationImplementations = {\n  [TBehaviorOperationType in BehaviorOperation['type']]: BehaviorOperationImplementation<TBehaviorOperationType>\n}\n\nconst behaviorOperationImplementations: BehaviorOperationImplementations = {\n  'annotation.add': addAnnotationOperationImplementation,\n  'annotation.remove': removeAnnotationOperationImplementation,\n  'block.set': blockSetOperationImplementation,\n  'block.unset': blockUnsetOperationImplementation,\n  'decorator.add': decoratorAddOperationImplementation,\n  'decorator.remove': removeDecoratorOperationImplementation,\n  'delete': deleteOperationImplementation,\n  'history.redo': historyRedoOperationImplementation,\n  'history.undo': historyUndoOperationImplementation,\n  'insert.block': insertBlockOperationImplementation,\n  'insert.inline object': insertInlineObjectOperationImplementation,\n  'insert.span': insertSpanOperationImplementation,\n  'insert.text': insertTextOperationImplementation,\n  'move.backward': moveBackwardOperationImplementation,\n  'move.block': moveBlockOperationImplementation,\n  'move.forward': moveForwardOperationImplementation,\n  'select': selectOperationImplementation,\n}\n\nexport function performOperation({\n  context,\n  operation,\n}: {\n  context: BehaviorOperationImplementationContext\n  operation: BehaviorOperation\n}) {\n  try {\n    switch (operation.type) {\n      case 'annotation.add': {\n        behaviorOperationImplementations['annotation.add']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'annotation.remove': {\n        behaviorOperationImplementations['annotation.remove']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'block.set': {\n        behaviorOperationImplementations['block.set']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'block.unset': {\n        behaviorOperationImplementations['block.unset']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'decorator.add': {\n        behaviorOperationImplementations['decorator.add']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'decorator.remove': {\n        behaviorOperationImplementations['decorator.remove']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'delete': {\n        behaviorOperationImplementations.delete({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'history.redo': {\n        behaviorOperationImplementations['history.redo']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'history.undo': {\n        behaviorOperationImplementations['history.undo']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'insert.block': {\n        behaviorOperationImplementations['insert.block']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'insert.inline object': {\n        behaviorOperationImplementations['insert.inline object']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'insert.span': {\n        behaviorOperationImplementations['insert.span']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'insert.text': {\n        behaviorOperationImplementations['insert.text']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'move.backward': {\n        behaviorOperationImplementations['move.backward']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'move.block': {\n        behaviorOperationImplementations['move.block']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      case 'move.forward': {\n        behaviorOperationImplementations['move.forward']({\n          context,\n          operation: operation,\n        })\n        break\n      }\n      default: {\n        behaviorOperationImplementations.select({\n          context,\n          operation: operation,\n        })\n        break\n      }\n    }\n  } catch (error) {\n    console.error(\n      new Error(\n        `Executing \"${operation.type}\" failed due to: ${error.message}`,\n      ),\n    )\n  }\n}\n","import {Editor} from 'slate'\nimport {defaultKeyGenerator} from './key-generator'\n\nconst CURRENT_OPERATION_ID: WeakMap<Editor, string | undefined> = new WeakMap()\n\nexport function withApplyingBehaviorOperations(editor: Editor, fn: () => void) {\n  CURRENT_OPERATION_ID.set(editor, defaultKeyGenerator())\n  Editor.withoutNormalizing(editor, fn)\n  CURRENT_OPERATION_ID.set(editor, undefined)\n}\n\nexport function getCurrentOperationId(editor: Editor) {\n  return CURRENT_OPERATION_ID.get(editor)\n}\n\nexport function isApplyingBehaviorOperations(editor: Editor) {\n  return getCurrentOperationId(editor) !== undefined\n}\n","import {Editor} from 'slate'\nimport {slateRangeToSelection} from '../../internal-utils/slate-utils'\nimport {insertTextOperationImplementation} from '../../operations/behavior.operation.insert.text'\nimport {performOperation} from '../../operations/behavior.operations'\nimport type {EditorActor} from '../editor-machine'\nimport {isApplyingBehaviorOperations} from '../with-applying-behavior-operations'\n\nexport function createWithEventListeners(editorActor: EditorActor) {\n  return function withEventListeners(editor: Editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== undefined) {\n      return editor\n    }\n\n    const {delete: editorDelete, select} = editor\n\n    editor.delete = (options) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        editorDelete(options)\n        return\n      }\n\n      const at = options?.at ?? editor.selection\n\n      if (!at) {\n        console.error('Unexpected call to .delete(...) without `at` option')\n        return\n      }\n\n      const range = Editor.range(editor, at)\n\n      const selection = slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor,\n        range,\n      })\n\n      if (!selection) {\n        console.error(\n          'Unexpected call to .delete(...) with invalid `at` option',\n        )\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'delete',\n          at: selection,\n          direction: options?.reverse ? 'backward' : 'forward',\n          unit: options?.unit,\n        },\n        editor,\n      })\n    }\n\n    editor.deleteBackward = (unit) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error('Unexpected call to .deleteBackward(...)')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'delete.backward',\n          unit,\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.deleteForward = (unit) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error('Unexpected call to .deleteForward(...)')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'delete.forward',\n          unit,\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertBreak = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error('Unexpected call to .insertBreak(...)')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.break',\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertData = (dataTransfer) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error('Unexpected call to .insertData(...)')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'input.*',\n          originEvent: {\n            dataTransfer,\n          },\n        },\n        editor,\n      })\n    }\n\n    editor.insertSoftBreak = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        insertTextOperationImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema,\n          },\n          operation: {type: 'insert.text', text: '\\n', editor},\n        })\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.soft break',\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertText = (text) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        insertTextOperationImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema,\n          },\n          operation: {type: 'insert.text', text, editor},\n        })\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.text',\n          text,\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.redo = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema,\n          },\n          operation: {\n            type: 'history.redo',\n            editor,\n          },\n        })\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'history.redo',\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.select = (location) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        select(location)\n        return\n      }\n\n      const range = Editor.range(editor, location)\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          at: slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range,\n          }),\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.setFragmentData = () => {\n      console.error('Unexpected call to .setFragmentData(...)')\n      return\n    }\n\n    editor.undo = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema,\n          },\n          operation: {\n            type: 'history.undo',\n            editor,\n          },\n        })\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'history.undo',\n        },\n        editor,\n      })\n      return\n    }\n\n    return editor\n  }\n}\n","import {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * This plugin makes sure that the PTE maxBlocks prop is respected\n *\n */\nexport function createWithMaxBlocks(editorActor: EditorActor) {\n  return function withMaxBlocks(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply} = editor\n    editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(operation)\n        return\n      }\n\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1\n      if (rows > 0 && editor.children.length >= rows) {\n        if (\n          (operation.type === 'insert_node' ||\n            operation.type === 'split_node') &&\n          operation.path.length === 1\n        ) {\n          return\n        }\n      }\n      apply(operation)\n    }\n    return editor\n  }\n}\n","import {Editor, Element, Node, Transforms} from 'slate'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * This plugin makes sure that every new node in the editor get a new _key prop when created\n *\n */\nexport function createWithObjectKeys(editorActor: EditorActor) {\n  return function withKeys(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply, normalizeNode} = editor\n\n    // The default behavior is to always generate a new key here.\n    // For example, when undoing and redoing we want to retain the keys, but\n    // when we create a new bold span by splitting a non-bold-span we want the produced node to get a new key.\n    editor.apply = (operation) => {\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(operation)\n        return\n      }\n\n      if (operation.type === 'split_node') {\n        const existingKeys = [...Node.descendants(editor)].map(\n          ([node]) => node._key,\n        )\n\n        apply({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key:\n              operation.properties._key === undefined ||\n              existingKeys.includes(operation.properties._key)\n                ? editorActor.getSnapshot().context.keyGenerator()\n                : operation.properties._key,\n          },\n        })\n\n        return\n      }\n\n      if (operation.type === 'insert_node') {\n        if (!Editor.isEditor(operation.node)) {\n          const existingKeys = [...Node.descendants(editor)].map(\n            ([node]) => node._key,\n          )\n\n          apply({\n            ...operation,\n            node: {\n              ...operation.node,\n              _key:\n                operation.node._key === undefined ||\n                existingKeys.includes(operation.node._key)\n                  ? editorActor.getSnapshot().context.keyGenerator()\n                  : operation.node._key,\n            },\n          })\n\n          return\n        }\n      }\n\n      apply(operation)\n    }\n\n    editor.normalizeNode = (entry) => {\n      const [node, path] = entry\n      if (\n        Element.isElement(node) &&\n        node._type === editorActor.getSnapshot().context.schema.block.name\n      ) {\n        // Set key on block itself\n        if (!node._key) {\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(\n            editor,\n            {_key: editorActor.getSnapshot().context.keyGenerator()},\n            {at: path},\n          )\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n        // Set keys on it's children\n        for (const [child, childPath] of Node.children(editor, path)) {\n          if (!child._key) {\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {_key: editorActor.getSnapshot().context.keyGenerator()},\n              {at: childPath},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n      normalizeNode(entry)\n    }\n\n    return editor\n  }\n}\n","import {\n  applyAll,\n  type DiffMatchPatch,\n  type InsertPatch,\n  type Patch,\n  type SetPatch,\n  type UnsetPatch,\n} from '@portabletext/patches'\nimport {\n  cleanupEfficiency,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  applyPatches as diffMatchPatchApplyPatches,\n  makeDiff,\n  parsePatch,\n} from '@sanity/diff-match-patch'\nimport type {Path, PortableTextBlock, PortableTextChild} from '@sanity/types'\nimport {Element, Node, Text, Transforms, type Descendant} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {isKeyedSegment} from '../utils'\nimport {isEqualToEmptyEditor, toSlateValue} from './values'\nimport {KEY_TO_SLATE_ELEMENT} from './weakMaps'\n\n/**\n * Creates a function that can apply a patch onto a PortableTextSlateEditor.\n */\nexport function createApplyPatch(\n  schema: EditorSchema,\n): (editor: PortableTextSlateEditor, patch: Patch) => boolean {\n  return (editor: PortableTextSlateEditor, patch: Patch): boolean => {\n    let changed = false\n\n    try {\n      switch (patch.type) {\n        case 'insert':\n          changed = insertPatch(editor, patch, schema)\n          break\n        case 'unset':\n          changed = unsetPatch(editor, patch)\n          break\n        case 'set':\n          changed = setPatch(editor, patch)\n          break\n        case 'diffMatchPatch':\n          changed = diffMatchPatch(editor, patch)\n          break\n      }\n    } catch (err) {\n      console.error(err)\n    }\n\n    return changed\n  }\n}\n\nfunction diffMatchPatch(\n  editor: Pick<\n    PortableTextSlateEditor,\n    'children' | 'isTextBlock' | 'apply' | 'selection' | 'onChange'\n  >,\n  patch: DiffMatchPatch,\n): boolean {\n  const block = findBlock(editor.children, patch.path)\n\n  if (!block) {\n    return false\n  }\n\n  const child = findBlockChild(block, patch.path)\n\n  if (!child) {\n    return false\n  }\n\n  const isSpanTextDiffMatchPatch =\n    block &&\n    editor.isTextBlock(block.node) &&\n    patch.path.length === 4 &&\n    patch.path[1] === 'children' &&\n    patch.path[3] === 'text'\n\n  if (!isSpanTextDiffMatchPatch || !Text.isText(child.node)) {\n    return false\n  }\n\n  const patches = parsePatch(patch.value)\n  const [newValue] = diffMatchPatchApplyPatches(patches, child.node.text, {\n    allowExceedingIndices: true,\n  })\n  const diff = cleanupEfficiency(makeDiff(child.node.text, newValue), 5)\n\n  let offset = 0\n  for (const [op, text] of diff) {\n    if (op === DIFF_INSERT) {\n      editor.apply({\n        type: 'insert_text',\n        path: [block.index, child.index],\n        offset,\n        text,\n      })\n      offset += text.length\n    } else if (op === DIFF_DELETE) {\n      editor.apply({\n        type: 'remove_text',\n        path: [block.index, child.index],\n        offset: offset,\n        text,\n      })\n    } else if (op === DIFF_EQUAL) {\n      offset += text.length\n    }\n  }\n\n  return true\n}\n\nfunction insertPatch(\n  editor: PortableTextSlateEditor,\n  patch: InsertPatch,\n  schema: EditorSchema,\n) {\n  const block = findBlock(editor.children, patch.path)\n\n  if (!block) {\n    return false\n  }\n\n  if (patch.path.length > 1 && patch.path[1] !== 'children') {\n    return false\n  }\n\n  // Insert blocks\n  if (patch.path.length === 1) {\n    const {items, position} = patch\n    const blocksToInsert = toSlateValue(\n      items as PortableTextBlock[],\n      {schemaTypes: schema},\n      KEY_TO_SLATE_ELEMENT.get(editor),\n    ) as Descendant[]\n    const targetBlockIndex = block.index\n    const normalizedIdx =\n      position === 'after' ? targetBlockIndex + 1 : targetBlockIndex\n\n    const editorWasEmptyBefore = isEqualToEmptyEditor(editor.children, schema)\n\n    Transforms.insertNodes(editor, blocksToInsert, {at: [normalizedIdx]})\n\n    if (\n      editorWasEmptyBefore &&\n      typeof patch.path[0] === 'number' &&\n      patch.path[0] === 0\n    ) {\n      Transforms.removeNodes(editor, {\n        at: [position === 'before' ? targetBlockIndex + 1 : targetBlockIndex],\n      })\n    }\n\n    return true\n  }\n\n  // Insert children\n  const {items, position} = patch\n\n  const targetChild = findBlockChild(block, patch.path)\n\n  if (!targetChild) {\n    return false\n  }\n\n  const childrenToInsert = toSlateValue(\n    [{...block.node, children: items as PortableTextChild[]}],\n    {schemaTypes: schema},\n    KEY_TO_SLATE_ELEMENT.get(editor),\n  )\n  const normalizedIdx =\n    position === 'after' ? targetChild.index + 1 : targetChild.index\n  const childInsertPath = [block.index, normalizedIdx]\n\n  if (childrenToInsert && Element.isElement(childrenToInsert[0])) {\n    Transforms.insertNodes(editor, childrenToInsert[0].children, {\n      at: childInsertPath,\n    })\n  }\n\n  return true\n}\n\nfunction setPatch(editor: PortableTextSlateEditor, patch: SetPatch) {\n  let value = patch.value\n  if (typeof patch.path[3] === 'string') {\n    value = {}\n    value[patch.path[3]] = patch.value\n  }\n\n  const block = findBlock(editor.children, patch.path)\n\n  if (!block) {\n    return false\n  }\n\n  const isTextBlock = editor.isTextBlock(block.node)\n\n  // Ignore patches targeting nested void data, like 'markDefs'\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== 'children') {\n    return false\n  }\n\n  const child = findBlockChild(block, patch.path)\n\n  // If this is targeting a text block child\n  if (isTextBlock && child) {\n    if (Text.isText(child.node)) {\n      if (Text.isText(value)) {\n        const oldText = child.node.text\n        const newText = value.text\n        if (oldText !== newText) {\n          editor.apply({\n            type: 'remove_text',\n            path: [block.index, child.index],\n            offset: 0,\n            text: oldText,\n          })\n          editor.apply({\n            type: 'insert_text',\n            path: [block.index, child.index],\n            offset: 0,\n            text: newText,\n          })\n          // call OnChange here to emit the new selection\n          // the user's selection might be interfering with\n          editor.onChange()\n        }\n      } else {\n        // Setting non-text span property\n\n        const propPath = patch.path.slice(3)\n        const propEntry = propPath.at(0)\n        const reservedProps = ['_key', '_type', 'text']\n\n        if (propEntry === undefined) {\n          return false\n        }\n\n        if (\n          typeof propEntry === 'string' &&\n          reservedProps.includes(propEntry)\n        ) {\n          return false\n        }\n\n        const newNode = applyAll(child.node, [\n          {\n            ...patch,\n            path: propPath,\n          },\n        ])\n\n        Transforms.setNodes(editor, newNode, {at: [block.index, child.index]})\n      }\n    } else {\n      // Setting inline object property\n\n      const propPath = patch.path.slice(3)\n      const reservedProps = ['_key', '_type', 'children', '__inline']\n      const propEntry = propPath.at(0)\n\n      if (propEntry === undefined) {\n        return false\n      }\n\n      if (typeof propEntry === 'string' && reservedProps.includes(propEntry)) {\n        return false\n      }\n\n      // If the child is an inline object, we need to apply the patch to the\n      // `value` property object.\n      const value =\n        'value' in child.node && typeof child.node.value === 'object'\n          ? child.node.value\n          : {}\n\n      const newValue = applyAll(value, [\n        {\n          ...patch,\n          path: patch.path.slice(3),\n        },\n      ])\n\n      Transforms.setNodes(\n        editor,\n        {...child.node, value: newValue},\n        {at: [block.index, child.index]},\n      )\n    }\n\n    return true\n  } else if (Element.isElement(block.node) && patch.path.length === 1) {\n    const {children, ...nextRest} = value as unknown as PortableTextBlock\n    const {children: prevChildren, ...prevRest} = block.node || {\n      children: undefined,\n    }\n\n    // Set any block properties\n    editor.apply({\n      type: 'set_node',\n      path: [block.index],\n      properties: {...prevRest},\n      newProperties: nextRest,\n    })\n\n    // Replace the children in the block\n    // Note that children must be explicitly inserted, and can't be set with set_node\n    const blockNode = block.node\n\n    blockNode.children.forEach((child, childIndex) => {\n      editor.apply({\n        type: 'remove_node',\n        path: [block.index, blockNode.children.length - 1 - childIndex],\n        node: child,\n      })\n    })\n\n    if (Array.isArray(children)) {\n      children.forEach((child, childIndex) => {\n        editor.apply({\n          type: 'insert_node',\n          path: [block.index, childIndex],\n          node: child,\n        })\n      })\n    }\n  } else if (block && 'value' in block.node) {\n    if (patch.path.length > 1 && patch.path[1] !== 'children') {\n      const newVal = applyAll(block.node.value, [\n        {\n          ...patch,\n          path: patch.path.slice(1),\n        },\n      ])\n\n      Transforms.setNodes(\n        editor,\n        {...block.node, value: newVal},\n        {at: [block.index]},\n      )\n    } else {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction unsetPatch(editor: PortableTextSlateEditor, patch: UnsetPatch) {\n  // Value\n  if (patch.path.length === 0) {\n    const previousSelection = editor.selection\n    Transforms.deselect(editor)\n\n    const children = Node.children(editor, [], {\n      reverse: true,\n    })\n\n    for (const [_, path] of children) {\n      Transforms.removeNodes(editor, {at: path})\n    }\n\n    Transforms.insertNodes(editor, editor.pteCreateTextBlock({decorators: []}))\n    if (previousSelection) {\n      Transforms.select(editor, {\n        anchor: {path: [0, 0], offset: 0},\n        focus: {path: [0, 0], offset: 0},\n      })\n    }\n    // call OnChange here to emit the new selection\n    editor.onChange()\n    return true\n  }\n\n  const block = findBlock(editor.children, patch.path)\n\n  if (!block) {\n    return false\n  }\n\n  // Single blocks\n  if (patch.path.length === 1) {\n    Transforms.removeNodes(editor, {at: [block.index]})\n\n    return true\n  }\n\n  const child = findBlockChild(block, patch.path)\n\n  // Unset on text block children\n  if (editor.isTextBlock(block.node) && child) {\n    if (patch.path[1] === 'children' && patch.path.length === 3) {\n      Transforms.removeNodes(editor, {at: [block.index, child.index]})\n\n      return true\n    }\n  }\n\n  if (child && !Text.isText(child.node)) {\n    // Unsetting inline object property\n\n    const propPath = patch.path.slice(3)\n    const propEntry = propPath.at(0)\n    const reservedProps = ['_key', '_type', 'children', '__inline']\n\n    if (propEntry === undefined) {\n      return false\n    }\n\n    if (typeof propEntry === 'string' && reservedProps.includes(propEntry)) {\n      // All custom properties are stored on the `value` property object.\n      // If you try to unset any of the other top-level properties it's a\n      // no-op.\n      return false\n    }\n\n    const value =\n      'value' in child.node && typeof child.node.value === 'object'\n        ? child.node.value\n        : {}\n\n    const newValue = applyAll(value, [\n      {\n        ...patch,\n        path: patch.path.slice(3),\n      },\n    ])\n\n    Transforms.setNodes(\n      editor,\n      {...child.node, value: newValue},\n      {at: [block.index, child.index]},\n    )\n\n    return true\n  }\n\n  if (child && Text.isText(child.node)) {\n    const propPath = patch.path.slice(3)\n    const propEntry = propPath.at(0)\n    const reservedProps = ['_key', '_type']\n\n    if (propEntry === undefined) {\n      return false\n    }\n\n    if (typeof propEntry === 'string' && reservedProps.includes(propEntry)) {\n      return false\n    }\n\n    if (typeof propEntry === 'string' && propEntry === 'text') {\n      editor.apply({\n        type: 'remove_text',\n        path: [block.index, child.index],\n        offset: 0,\n        text: child.node.text,\n      })\n\n      return true\n    }\n\n    const newNode = applyAll(child.node, [\n      {\n        ...patch,\n        path: propPath,\n      },\n    ])\n    const newKeys = Object.keys(newNode)\n\n    const removedProperties = Object.keys(child.node).filter(\n      (property) => !newKeys.includes(property),\n    )\n\n    Transforms.unsetNodes(editor, removedProperties, {\n      at: [block.index, child.index],\n    })\n\n    return true\n  }\n\n  if (!child) {\n    if ('value' in block.node) {\n      const newVal = applyAll(block.node.value, [\n        {\n          ...patch,\n          path: patch.path.slice(1),\n        },\n      ])\n\n      Transforms.setNodes(\n        editor,\n        {...block.node, value: newVal},\n        {at: [block.index]},\n      )\n\n      return true\n    }\n\n    return false\n  }\n\n  return false\n}\n\nfunction findBlock(\n  children: Descendant[],\n  path: Path,\n): {node: Descendant; index: number} | undefined {\n  let blockIndex = -1\n\n  const block = children.find((node: Descendant, index: number) => {\n    const isMatch = isKeyedSegment(path[0])\n      ? node._key === path[0]._key\n      : index === path[0]\n\n    if (isMatch) {\n      blockIndex = index\n    }\n\n    return isMatch\n  })\n\n  if (!block) {\n    return undefined\n  }\n\n  return {node: block, index: blockIndex}\n}\n\nfunction findBlockChild(\n  block: {node: Descendant; index: number},\n  path: Path,\n): {node: Descendant; index: number} | undefined {\n  const blockNode = block.node\n\n  if (!Element.isElement(blockNode) || path[1] !== 'children') {\n    return undefined\n  }\n\n  let childIndex = -1\n\n  const child = blockNode.children.find((node, index: number) => {\n    const isMatch = isKeyedSegment(path[2])\n      ? node._key === path[2]._key\n      : index === path[2]\n\n    if (isMatch) {\n      childIndex = index\n    }\n\n    return isMatch\n  })\n\n  if (!child) {\n    return undefined\n  }\n\n  return {\n    node: child,\n    index: childIndex,\n  }\n}\n","import {\n  diffMatchPatch,\n  insert,\n  set,\n  setIfMissing,\n  unset,\n  type InsertPosition,\n  type Patch,\n} from '@portabletext/patches'\nimport type {Path, PortableTextSpan, PortableTextTextBlock} from '@sanity/types'\nimport {get, isUndefined, omitBy} from 'lodash'\nimport {\n  Text,\n  type Descendant,\n  type InsertNodeOperation,\n  type InsertTextOperation,\n  type MergeNodeOperation,\n  type MoveNodeOperation,\n  type RemoveNodeOperation,\n  type RemoveTextOperation,\n  type SetNodeOperation,\n  type SplitNodeOperation,\n} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport {isSpan, isTextBlock} from './parse-blocks'\nimport {fromSlateValue} from './values'\n\nexport function insertTextPatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: InsertTextOperation,\n  beforeValue: Descendant[],\n): Array<Patch> {\n  const block =\n    isTextBlock({schema}, children[operation.path[0]]) &&\n    children[operation.path[0]]\n  if (!block) {\n    throw new Error('Could not find block')\n  }\n  const textChild =\n    isTextBlock({schema}, block) &&\n    isSpan({schema}, block.children[operation.path[1]]) &&\n    (block.children[operation.path[1]] as PortableTextSpan)\n  if (!textChild) {\n    throw new Error('Could not find child')\n  }\n  const path: Path = [\n    {_key: block._key},\n    'children',\n    {_key: textChild._key},\n    'text',\n  ]\n  const prevBlock = beforeValue[operation.path[0]]\n  const prevChild =\n    isTextBlock({schema}, prevBlock) && prevBlock.children[operation.path[1]]\n  const prevText = isSpan({schema}, prevChild) ? prevChild.text : ''\n  const patch = diffMatchPatch(prevText, textChild.text, path)\n  return patch.value.length ? [patch] : []\n}\n\nexport function removeTextPatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: RemoveTextOperation,\n  beforeValue: Descendant[],\n): Array<Patch> {\n  const block = children[operation.path[0]]\n  if (!block) {\n    throw new Error('Could not find block')\n  }\n  const child =\n    (isTextBlock({schema}, block) && block.children[operation.path[1]]) ||\n    undefined\n  const textChild: PortableTextSpan | undefined = isSpan({schema}, child)\n    ? child\n    : undefined\n  if (child && !textChild) {\n    throw new Error('Expected span')\n  }\n  if (!textChild) {\n    throw new Error('Could not find child')\n  }\n  const path: Path = [\n    {_key: block._key},\n    'children',\n    {_key: textChild._key},\n    'text',\n  ]\n  const beforeBlock = beforeValue[operation.path[0]]\n  const prevTextChild =\n    isTextBlock({schema}, beforeBlock) &&\n    beforeBlock.children[operation.path[1]]\n  const prevText = isSpan({schema}, prevTextChild) && prevTextChild.text\n  const patch = diffMatchPatch(prevText || '', textChild.text, path)\n  return patch.value ? [patch] : []\n}\n\nexport function setNodePatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: SetNodeOperation,\n): Array<Patch> {\n  if (operation.path.length === 1) {\n    const block = children[operation.path[0]]\n    if (typeof block._key !== 'string') {\n      throw new Error('Expected block to have a _key')\n    }\n    const setNode = omitBy(\n      {...children[operation.path[0]], ...operation.newProperties},\n      isUndefined,\n    ) as unknown as Descendant\n    return [\n      set(fromSlateValue([setNode], schema.block.name)[0], [\n        {_key: block._key},\n      ]),\n    ]\n  } else if (operation.path.length === 2) {\n    const block = children[operation.path[0]]\n    if (isTextBlock({schema}, block)) {\n      const child = block.children[operation.path[1]]\n      if (child) {\n        const blockKey = block._key\n        const childKey = child._key\n        const patches: Patch[] = []\n        const keys = Object.keys(operation.newProperties)\n        keys.forEach((keyName) => {\n          // Special case for setting _key on a child. We have to target it by index and not the _key.\n          if (keys.length === 1 && keyName === '_key') {\n            const val = get(operation.newProperties, keyName)\n            patches.push(\n              set(val, [\n                {_key: blockKey},\n                'children',\n                block.children.indexOf(child),\n                keyName,\n              ]),\n            )\n          } else {\n            const val = get(operation.newProperties, keyName)\n            patches.push(\n              set(val, [\n                {_key: blockKey},\n                'children',\n                {_key: childKey},\n                keyName,\n              ]),\n            )\n          }\n        })\n        return patches\n      }\n      throw new Error('Could not find a valid child')\n    }\n    throw new Error('Could not find a valid block')\n  } else {\n    throw new Error(\n      `Unexpected path encountered: ${JSON.stringify(operation.path)}`,\n    )\n  }\n}\n\nexport function insertNodePatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: InsertNodeOperation,\n  beforeValue: Descendant[],\n): Array<Patch> {\n  const block = beforeValue[operation.path[0]]\n  if (operation.path.length === 1) {\n    const position = operation.path[0] === 0 ? 'before' : 'after'\n    const beforeBlock = beforeValue[operation.path[0] - 1]\n    const targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key\n    if (targetKey) {\n      return [\n        insert(\n          [\n            fromSlateValue(\n              [operation.node as Descendant],\n              schema.block.name,\n            )[0],\n          ],\n          position,\n          [{_key: targetKey}],\n        ),\n      ]\n    }\n    return [\n      setIfMissing(beforeValue, []),\n      insert(\n        [fromSlateValue([operation.node as Descendant], schema.block.name)[0]],\n        'before',\n        [operation.path[0]],\n      ),\n    ]\n  } else if (\n    isTextBlock({schema}, block) &&\n    operation.path.length === 2 &&\n    children[operation.path[0]]\n  ) {\n    const position =\n      block.children.length === 0 || !block.children[operation.path[1] - 1]\n        ? 'before'\n        : 'after'\n    const node = {...operation.node} as Descendant\n    if (!node._type && Text.isText(node)) {\n      node._type = 'span'\n      node.marks = []\n    }\n    const blk = fromSlateValue(\n      [\n        {\n          _key: 'bogus',\n          _type: schema.block.name,\n          children: [node],\n        },\n      ],\n      schema.block.name,\n    )[0] as PortableTextTextBlock\n    const child = blk.children[0]\n    return [\n      insert([child], position, [\n        {_key: block._key},\n        'children',\n        block.children.length <= 1 || !block.children[operation.path[1] - 1]\n          ? 0\n          : {_key: block.children[operation.path[1] - 1]._key},\n      ]),\n    ]\n  }\n  return []\n}\n\nexport function splitNodePatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: SplitNodeOperation,\n  beforeValue: Descendant[],\n): Array<Patch> {\n  const patches: Patch[] = []\n  const splitBlock = children[operation.path[0]]\n  if (!isTextBlock({schema}, splitBlock)) {\n    throw new Error(\n      `Block with path ${JSON.stringify(\n        operation.path[0],\n      )} is not a text block and can't be split`,\n    )\n  }\n  if (operation.path.length === 1) {\n    const oldBlock = beforeValue[operation.path[0]]\n    if (isTextBlock({schema}, oldBlock)) {\n      const targetValue = fromSlateValue(\n        [children[operation.path[0] + 1]],\n        schema.block.name,\n      )[0]\n      if (targetValue) {\n        patches.push(insert([targetValue], 'after', [{_key: splitBlock._key}]))\n        const spansToUnset = oldBlock.children.slice(operation.position)\n        spansToUnset.forEach((span) => {\n          const path = [{_key: oldBlock._key}, 'children', {_key: span._key}]\n          patches.push(unset(path))\n        })\n      }\n    }\n    return patches\n  }\n  if (operation.path.length === 2) {\n    const splitSpan = splitBlock.children[operation.path[1]]\n    if (isSpan({schema}, splitSpan)) {\n      const targetSpans = (\n        fromSlateValue(\n          [\n            {\n              ...splitBlock,\n              children: splitBlock.children.slice(\n                operation.path[1] + 1,\n                operation.path[1] + 2,\n              ),\n            } as Descendant,\n          ],\n          schema.block.name,\n        )[0] as PortableTextTextBlock\n      ).children\n\n      patches.push(\n        insert(targetSpans, 'after', [\n          {_key: splitBlock._key},\n          'children',\n          {_key: splitSpan._key},\n        ]),\n      )\n      patches.push(\n        set(splitSpan.text, [\n          {_key: splitBlock._key},\n          'children',\n          {_key: splitSpan._key},\n          'text',\n        ]),\n      )\n    }\n    return patches\n  }\n  return patches\n}\n\nexport function removeNodePatch(\n  schema: EditorSchema,\n  beforeValue: Descendant[],\n  operation: RemoveNodeOperation,\n): Array<Patch> {\n  const block = beforeValue[operation.path[0]]\n  if (operation.path.length === 1) {\n    // Remove a single block\n    if (block && block._key) {\n      return [unset([{_key: block._key}])]\n    }\n    throw new Error('Block not found')\n  } else if (isTextBlock({schema}, block) && operation.path.length === 2) {\n    const spanToRemove = block.children[operation.path[1]]\n\n    if (spanToRemove) {\n      const spansMatchingKey = block.children.filter(\n        (span) => span._key === operation.node._key,\n      )\n\n      if (spansMatchingKey.length > 1) {\n        console.warn(\n          `Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`,\n          JSON.stringify(block, null, 2),\n        )\n        return []\n      }\n\n      return [\n        unset([{_key: block._key}, 'children', {_key: spanToRemove._key}]),\n      ]\n    }\n    return []\n  } else {\n    return []\n  }\n}\n\nexport function mergeNodePatch(\n  schema: EditorSchema,\n  children: Descendant[],\n  operation: MergeNodeOperation,\n  beforeValue: Descendant[],\n): Array<Patch> {\n  const patches: Patch[] = []\n\n  const block = beforeValue[operation.path[0]]\n  const updatedBlock = children[operation.path[0]]\n\n  if (operation.path.length === 1) {\n    if (block?._key) {\n      const newBlock = fromSlateValue(\n        [children[operation.path[0] - 1]],\n        schema.block.name,\n      )[0]\n      patches.push(set(newBlock, [{_key: newBlock._key}]))\n      patches.push(unset([{_key: block._key}]))\n    } else {\n      throw new Error('Target key not found!')\n    }\n  } else if (\n    isTextBlock({schema}, block) &&\n    isTextBlock({schema}, updatedBlock) &&\n    operation.path.length === 2\n  ) {\n    const updatedSpan =\n      updatedBlock.children[operation.path[1] - 1] &&\n      isSpan({schema}, updatedBlock.children[operation.path[1] - 1])\n        ? updatedBlock.children[operation.path[1] - 1]\n        : undefined\n    const removedSpan =\n      block.children[operation.path[1]] &&\n      isSpan({schema}, block.children[operation.path[1]])\n        ? block.children[operation.path[1]]\n        : undefined\n\n    if (updatedSpan) {\n      const spansMatchingKey = block.children.filter(\n        (span) => span._key === updatedSpan._key,\n      )\n\n      if (spansMatchingKey.length === 1) {\n        patches.push(\n          set(updatedSpan.text, [\n            {_key: block._key},\n            'children',\n            {_key: updatedSpan._key},\n            'text',\n          ]),\n        )\n      } else {\n        console.warn(\n          `Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`,\n          JSON.stringify(block, null, 2),\n        )\n      }\n    }\n\n    if (removedSpan) {\n      const spansMatchingKey = block.children.filter(\n        (span) => span._key === removedSpan._key,\n      )\n\n      if (spansMatchingKey.length === 1) {\n        patches.push(\n          unset([{_key: block._key}, 'children', {_key: removedSpan._key}]),\n        )\n      } else {\n        console.warn(\n          `Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`,\n          JSON.stringify(block, null, 2),\n        )\n      }\n    }\n  }\n  return patches\n}\n\nexport function moveNodePatch(\n  schema: EditorSchema,\n  beforeValue: Descendant[],\n  operation: MoveNodeOperation,\n): Array<Patch> {\n  const patches: Patch[] = []\n  const block = beforeValue[operation.path[0]]\n  const targetBlock = beforeValue[operation.newPath[0]]\n\n  if (!targetBlock) {\n    return patches\n  }\n\n  if (operation.path.length === 1) {\n    const position: InsertPosition =\n      operation.path[0] > operation.newPath[0] ? 'before' : 'after'\n    patches.push(unset([{_key: block._key}]))\n    patches.push(\n      insert([fromSlateValue([block], schema.block.name)[0]], position, [\n        {_key: targetBlock._key},\n      ]),\n    )\n  } else if (\n    operation.path.length === 2 &&\n    isTextBlock({schema}, block) &&\n    isTextBlock({schema}, targetBlock)\n  ) {\n    const child = block.children[operation.path[1]]\n    const targetChild = targetBlock.children[operation.newPath[1]]\n    const position =\n      operation.newPath[1] === targetBlock.children.length ? 'after' : 'before'\n    const childToInsert = (\n      fromSlateValue([block], schema.block.name)[0] as PortableTextTextBlock\n    ).children[operation.path[1]]\n    patches.push(unset([{_key: block._key}, 'children', {_key: child._key}]))\n    patches.push(\n      insert([childToInsert], position, [\n        {_key: targetBlock._key},\n        'children',\n        {_key: targetChild._key},\n      ]),\n    )\n  }\n  return patches\n}\n","import type {Editor} from 'slate'\n\nexport const PATCHING: WeakMap<Editor, boolean | undefined> = new WeakMap()\n\nexport function withoutPatching(editor: Editor, fn: () => void): void {\n  const prev = isPatching(editor)\n  PATCHING.set(editor, false)\n  fn()\n  PATCHING.set(editor, prev)\n}\n\nexport function isPatching(editor: Editor): boolean | undefined {\n  return PATCHING.get(editor)\n}\n","import {insert, setIfMissing, unset, type Patch} from '@portabletext/patches'\nimport {Editor, type Descendant, type Operation} from 'slate'\nimport {createApplyPatch} from '../../internal-utils/applyPatch'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  insertNodePatch,\n  insertTextPatch,\n  mergeNodePatch,\n  moveNodePatch,\n  removeNodePatch,\n  removeTextPatch,\n  setNodePatch,\n  splitNodePatch,\n} from '../../internal-utils/operation-to-patches'\nimport {fromSlateValue, isEqualToEmptyEditor} from '../../internal-utils/values'\nimport {\n  IS_PROCESSING_REMOTE_CHANGES,\n  KEY_TO_VALUE_ELEMENT,\n} from '../../internal-utils/weakMaps'\nimport {withRemoteChanges} from '../../internal-utils/withChanges'\nimport {\n  isPatching,\n  PATCHING,\n  withoutPatching,\n} from '../../internal-utils/withoutPatching'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport type {RelayActor} from '../relay-machine'\nimport {getCurrentOperationId} from '../with-applying-behavior-operations'\nimport {withoutSaving} from './createWithUndoRedo'\n\nconst debug = debugWithName('plugin:withPatches')\nconst debugVerbose = false\n\ninterface Options {\n  editorActor: EditorActor\n  relayActor: RelayActor\n  subscriptions: Array<() => () => void>\n}\n\nexport function createWithPatches({\n  editorActor,\n  relayActor,\n  subscriptions,\n}: Options): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  // The previous editor children are needed to figure out the _key of deleted nodes\n  // The editor.children would no longer contain that information if the node is already deleted.\n  let previousChildren: Descendant[]\n\n  const applyPatch = createApplyPatch(editorActor.getSnapshot().context.schema)\n\n  return function withPatches(editor: PortableTextSlateEditor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, false)\n    PATCHING.set(editor, true)\n    previousChildren = [...editor.children]\n\n    const {apply} = editor\n    let bufferedPatches: Patch[] = []\n\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0) {\n        return\n      }\n      const patches = bufferedPatches\n      bufferedPatches = []\n      let changed = false\n\n      withRemoteChanges(editor, () => {\n        Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              for (const patch of patches) {\n                if (debug.enabled)\n                  debug(`Handling remote patch ${JSON.stringify(patch)}`)\n\n                try {\n                  changed = applyPatch(editor, patch)\n                } catch (error) {\n                  console.error(\n                    `Applying patch ${JSON.stringify(patch)} failed due to: ${error.message}`,\n                  )\n                }\n              }\n            })\n          })\n        })\n        if (changed) {\n          editor.normalize()\n          editor.onChange()\n        }\n      })\n    }\n\n    const handlePatches = ({patches}: {patches: Patch[]}) => {\n      const remotePatches = patches.filter((p) => p.origin !== 'local')\n      if (remotePatches.length === 0) {\n        return\n      }\n      bufferedPatches = bufferedPatches.concat(remotePatches)\n      handleBufferedRemotePatches()\n    }\n\n    subscriptions.push(() => {\n      debug('Subscribing to remote patches')\n      const sub = editorActor.on('patches', handlePatches)\n      return () => {\n        debug('Unsubscribing to remote patches')\n        sub.unsubscribe()\n      }\n    })\n\n    editor.apply = (operation: Operation): void | Editor => {\n      let patches: Patch[] = []\n\n      // Update previous children here before we apply\n      previousChildren = editor.children\n\n      const editorWasEmpty = isEqualToEmptyEditor(\n        previousChildren,\n        editorActor.getSnapshot().context.schema,\n      )\n\n      // Apply the operation\n      apply(operation)\n\n      const editorIsEmpty = isEqualToEmptyEditor(\n        editor.children,\n        editorActor.getSnapshot().context.schema,\n      )\n\n      if (!isPatching(editor)) {\n        if (debugVerbose && debug.enabled)\n          debug(\n            `Editor is not producing patch for operation ${operation.type}`,\n            operation,\n          )\n        return editor\n      }\n\n      // If the editor was empty and now isn't, insert the placeholder into it.\n      if (\n        editorWasEmpty &&\n        !editorIsEmpty &&\n        operation.type !== 'set_selection'\n      ) {\n        patches.push(insert(previousChildren, 'before', [0]))\n      }\n\n      switch (operation.type) {\n        case 'insert_text':\n          patches = [\n            ...patches,\n            ...insertTextPatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'remove_text':\n          patches = [\n            ...patches,\n            ...removeTextPatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'remove_node':\n          patches = [\n            ...patches,\n            ...removeNodePatch(\n              editorActor.getSnapshot().context.schema,\n              previousChildren,\n              operation,\n            ),\n          ]\n          break\n        case 'split_node':\n          patches = [\n            ...patches,\n            ...splitNodePatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'insert_node':\n          patches = [\n            ...patches,\n            ...insertNodePatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'set_node':\n          patches = [\n            ...patches,\n            ...setNodePatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n            ),\n          ]\n          break\n        case 'merge_node':\n          patches = [\n            ...patches,\n            ...mergeNodePatch(\n              editorActor.getSnapshot().context.schema,\n              editor.children,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'move_node':\n          patches = [\n            ...patches,\n            ...moveNodePatch(\n              editorActor.getSnapshot().context.schema,\n              previousChildren,\n              operation,\n            ),\n          ]\n          break\n        default:\n        // Do nothing\n      }\n\n      // Unset the value if a operation made the editor empty\n      if (\n        !editorWasEmpty &&\n        editorIsEmpty &&\n        ['merge_node', 'set_node', 'remove_text', 'remove_node'].includes(\n          operation.type,\n        )\n      ) {\n        patches = [...patches, unset([])]\n        relayActor.send({\n          type: 'unset',\n          previousValue: fromSlateValue(\n            previousChildren,\n            editorActor.getSnapshot().context.schema.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          ),\n        })\n      }\n\n      // Prepend patches with setIfMissing if going from empty editor to something involving a patch.\n      if (editorWasEmpty && patches.length > 0) {\n        patches = [setIfMissing([], []), ...patches]\n      }\n\n      // Emit all patches\n      if (patches.length > 0) {\n        for (const patch of patches) {\n          editorActor.send({\n            type: 'internal.patch',\n            patch: {...patch, origin: 'local'},\n            operationId: getCurrentOperationId(editor),\n            value: fromSlateValue(\n              editor.children,\n              editorActor.getSnapshot().context.schema.block.name,\n              KEY_TO_VALUE_ELEMENT.get(editor),\n            ),\n          })\n        }\n      }\n      return editor\n    }\n    return editor\n  }\n}\n","import {Editor, Path} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {SlateTextBlock, VoidElement} from '../../types/slate'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPlaceholderBlock')\n\n/**\n * Keep a \"placeholder\" block present when the editor is empty\n *\n */\nexport function createWithPlaceholderBlock(\n  editorActor: EditorActor,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  return function withPlaceholderBlock(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply} = editor\n\n    editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      if (op.type === 'remove_node') {\n        const node = op.node as SlateTextBlock | VoidElement\n        if (op.path[0] === 0 && Editor.isVoid(editor, node)) {\n          // Check next path, if it exists, do nothing\n          const nextPath = Path.next(op.path)\n          // Is removing the first block which is a void (not a text block), add a new empty text block in it, if there is no other element in the next path\n          if (!editor.children[nextPath[0]]) {\n            debug('Adding placeholder block')\n            Editor.insertNode(\n              editor,\n              editor.pteCreateTextBlock({decorators: []}),\n            )\n          }\n        }\n      }\n      apply(op)\n    }\n    return editor\n  }\n}\n","import {Editor, Path, Text as SlateText, Transforms} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPortableTextBlockStyle')\n\nexport function createWithPortableTextBlockStyle(\n  editorActor: EditorActor,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  const defaultStyle = editorActor.getSnapshot().context.schema.styles[0].name\n  return function withPortableTextBlockStyle(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    // Extend Slate's default normalization to reset split node to normal style\n    // if there is no text at the right end of the split.\n    const {normalizeNode} = editor\n\n    editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry\n\n      for (const op of editor.operations) {\n        if (\n          op.type === 'split_node' &&\n          op.path.length === 1 &&\n          editor.isTextBlock(op.properties) &&\n          op.properties.style !== defaultStyle &&\n          op.path[0] === path[0] &&\n          !Path.equals(path, op.path)\n        ) {\n          const [child] = Editor.node(editor, [op.path[0] + 1, 0])\n          if (SlateText.isText(child) && child.text === '') {\n            debug(`Normalizing split node to ${defaultStyle} style`, op)\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {style: defaultStyle},\n              {at: [op.path[0] + 1], voids: false},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      normalizeNode(nodeEntry)\n    }\n\n    return editor\n  }\n}\n","import type {BaseRange} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {slateRangeToSelection} from '../../internal-utils/slate-utils'\nimport {SLATE_TO_PORTABLE_TEXT_RANGE} from '../../internal-utils/weakMaps'\nimport type {EditorSelection, PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPortableTextSelections')\nconst debugVerbose = debug.enabled && false\n\n// This plugin will make sure that we emit a PT selection whenever the editor has changed.\nexport function createWithPortableTextSelections(\n  editorActor: EditorActor,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  let prevSelection: BaseRange | null = null\n  return function withPortableTextSelections(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange: EditorSelection | null = null\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection)\n          if (existing) {\n            ptRange = existing\n          } else {\n            ptRange = slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor,\n              range: editor.selection,\n            })\n            SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange)\n          }\n        }\n        if (debugVerbose) {\n          debug(\n            `Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(\n              editor.selection,\n            )})`,\n          )\n        }\n        if (ptRange) {\n          editorActor.send({type: 'update selection', selection: ptRange})\n        } else {\n          editorActor.send({type: 'update selection', selection: null})\n        }\n      }\n      prevSelection = editor.selection\n    }\n\n    const {onChange} = editor\n    editor.onChange = () => {\n      onChange()\n      if (!editorActor.getSnapshot().matches({setup: 'setting up'})) {\n        emitPortableTextSelection()\n      }\n    }\n    return editor\n  }\n}\n","import type {\n  PortableTextListBlock,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {Editor, Transforms, type Element} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  isListBlock,\n  isSpan,\n  isTextBlock,\n} from '../../internal-utils/parse-blocks'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withSchemaTypes')\n/**\n * This plugin makes sure that schema types are recognized properly by Slate as blocks, voids, inlines\n *\n */\nexport function createWithSchemaTypes({\n  editorActor,\n}: {\n  editorActor: EditorActor\n}) {\n  return function withSchemaTypes(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    editor.isTextBlock = (value: unknown): value is PortableTextTextBlock => {\n      if (Editor.isEditor(value)) {\n        return false\n      }\n\n      return isTextBlock(editorActor.getSnapshot().context, value)\n    }\n    editor.isTextSpan = (value: unknown): value is PortableTextSpan => {\n      if (Editor.isEditor(value)) {\n        return false\n      }\n\n      return isSpan(editorActor.getSnapshot().context, value)\n    }\n    editor.isListBlock = (value: unknown): value is PortableTextListBlock => {\n      if (Editor.isEditor(value)) {\n        return false\n      }\n\n      return isListBlock(editorActor.getSnapshot().context, value)\n    }\n    editor.isVoid = (element: Element): boolean => {\n      if (Editor.isEditor(element)) {\n        return false\n      }\n\n      return (\n        editorActor.getSnapshot().context.schema.block.name !== element._type &&\n        (editorActor\n          .getSnapshot()\n          .context.schema.blockObjects.map((obj) => obj.name)\n          .includes(element._type) ||\n          editorActor\n            .getSnapshot()\n            .context.schema.inlineObjects.map((obj) => obj.name)\n            .includes(element._type))\n      )\n    }\n    editor.isInline = (element: Element): boolean => {\n      if (Editor.isEditor(element)) {\n        return false\n      }\n\n      const inlineSchemaTypes = editorActor\n        .getSnapshot()\n        .context.schema.inlineObjects.map((obj) => obj.name)\n      return (\n        inlineSchemaTypes.includes(element._type) &&\n        '__inline' in element &&\n        element.__inline === true\n      )\n    }\n\n    // Extend Slate's default normalization\n    const {normalizeNode} = editor\n    editor.normalizeNode = (entry) => {\n      const [node, path] = entry\n\n      // If text block children node is missing _type, set it to the span type\n      if (node._type === undefined && path.length === 2) {\n        debug('Setting span type on text node without a type')\n        const span = node as PortableTextSpan\n        const key =\n          span._key || editorActor.getSnapshot().context.keyGenerator()\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(\n          editor,\n          {\n            ...span,\n            _type: editorActor.getSnapshot().context.schema.span.name,\n            _key: key,\n          },\n          {at: path},\n        )\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      // catches cases when the children are missing keys but excludes it when the normalize is running the node as the editor object\n      if (node._key === undefined && (path.length === 1 || path.length === 2)) {\n        debug('Setting missing key on child node without a key')\n        const key = editorActor.getSnapshot().context.keyGenerator()\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {_key: key}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      normalizeNode(entry)\n    }\n    return editor\n  }\n}\n","import {toSlateValue} from '../../internal-utils/values'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\ninterface Options {\n  editorActor: EditorActor\n}\n\n/**\n * This plugin makes various util commands available in the editor\n *\n */\nexport function createWithUtils({editorActor}: Options) {\n  return function withUtils(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    editor.pteCreateTextBlock = (options: {\n      decorators: Array<string>\n      listItem?: string\n      level?: number\n    }) => {\n      const block = toSlateValue(\n        [\n          {\n            _type: editorActor.getSnapshot().context.schema.block.name,\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n            style:\n              editorActor.getSnapshot().context.schema.styles[0].name ||\n              'normal',\n            ...(options.listItem ? {listItem: options.listItem} : {}),\n            ...(options.level ? {level: options.level} : {}),\n            markDefs: [],\n            children: [\n              {\n                _type: 'span',\n                _key: editorActor.getSnapshot().context.keyGenerator(),\n                text: '',\n                marks: options.decorators.filter((decorator) =>\n                  editorActor\n                    .getSnapshot()\n                    .context.schema.decorators.find(\n                      ({name}) => name === decorator,\n                    ),\n                ),\n              },\n            ],\n          },\n        ],\n        {schemaTypes: editorActor.getSnapshot().context.schema},\n      )[0]\n      return block\n    }\n    return editor\n  }\n}\n","import {Range} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {getNextSpan, getPreviousSpan} from './sibling-utils'\nimport {getFocusBlock, getFocusSpan, getSelectedSpans} from './slate-utils'\n\nexport type MarkState = {\n  state: 'changed' | 'unchanged'\n  marks: Array<string>\n}\n\n/**\n * Given that text is inserted at the current position, what marks should\n * be applied?\n */\nexport function getMarkState({\n  schema,\n  editor,\n}: {\n  schema: EditorSchema\n  editor: PortableTextSlateEditor\n}): MarkState | undefined {\n  if (!editor.selection) {\n    return undefined\n  }\n\n  const [block, blockPath] = getFocusBlock({\n    editor,\n  })\n  const [span, spanPath] = getFocusSpan({\n    editor,\n  })\n\n  if (!block || !editor.isTextBlock(block) || !span) {\n    return undefined\n  }\n\n  if (Range.isExpanded(editor.selection)) {\n    const selectedSpans = getSelectedSpans({editor})\n\n    let index = 0\n    let marks: Array<string> = []\n\n    for (const [span] of selectedSpans) {\n      if (index === 0) {\n        marks = span.marks ?? []\n      } else {\n        if (\n          span.marks?.length === 0 ||\n          (span.marks ?? [])?.some((mark) => !marks.includes(mark))\n        ) {\n          marks = []\n        }\n      }\n\n      index++\n    }\n\n    return {\n      state: 'unchanged',\n      marks,\n    }\n  }\n\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n  const marks = span.marks ?? []\n  const marksWithoutAnnotations = marks.filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  const spanHasAnnotations = marks.length > marksWithoutAnnotations.length\n\n  const spanIsEmpty = span.text.length === 0\n\n  const atTheBeginningOfSpan = editor.selection.anchor.offset === 0\n  const atTheEndOfSpan = editor.selection.anchor.offset === span.text.length\n\n  const previousSpan = getPreviousSpan({editor, blockPath, spanPath})\n  const nextSpan = getNextSpan({editor, blockPath, spanPath})\n  const nextSpanAnnotations =\n    nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n  const spanAnnotations = marks.filter((mark) => !decorators.includes(mark))\n\n  const previousSpanHasAnnotations = previousSpan\n    ? previousSpan.marks?.some((mark) => !decorators.includes(mark))\n    : false\n  const previousSpanHasSameAnnotations = previousSpan\n    ? previousSpan.marks\n        ?.filter((mark) => !decorators.includes(mark))\n        .every((mark) => marks.includes(mark))\n    : false\n  const previousSpanHasSameAnnotation = previousSpan\n    ? previousSpan.marks?.some(\n        (mark) => !decorators.includes(mark) && marks.includes(mark),\n      )\n    : false\n\n  const previousSpanHasSameMarks = previousSpan\n    ? previousSpan.marks?.every((mark) => marks.includes(mark))\n    : false\n  const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n    nextSpanAnnotations?.includes(mark),\n  )\n\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks) {\n        return {\n          state: 'changed',\n          marks: previousSpan?.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotations) {\n        return {\n          state: 'changed',\n          marks: previousSpan?.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotation) {\n        return {\n          state: 'unchanged',\n          marks: span.marks ?? [],\n        }\n      } else if (!previousSpan) {\n        return {\n          state: 'changed',\n          marks: [],\n        }\n      }\n    }\n\n    if (atTheEndOfSpan) {\n      if (\n        (nextSpan &&\n          nextSpanSharesSomeAnnotations &&\n          nextSpanAnnotations.length < spanAnnotations.length) ||\n        !nextSpanSharesSomeAnnotations\n      ) {\n        return {\n          state: 'changed',\n          marks: nextSpan?.marks ?? [],\n        }\n      }\n\n      if (!nextSpan) {\n        return {\n          state: 'changed',\n          marks: [],\n        }\n      }\n    }\n  }\n\n  if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n    if (previousSpanHasAnnotations) {\n      return {\n        state: 'changed',\n        marks: [],\n      }\n    } else {\n      return {\n        state: 'changed',\n        marks: (previousSpan?.marks ?? []).filter((mark) =>\n          decorators.includes(mark),\n        ),\n      }\n    }\n  }\n\n  return {\n    state: 'unchanged',\n    marks: span.marks ?? [],\n  }\n}\n","import {getMarkState} from '../../internal-utils/mark-state'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorContext} from '../editor-snapshot'\n\nexport function pluginUpdateMarkState(\n  context: Pick<EditorContext, 'schema'>,\n  editor: PortableTextSlateEditor,\n) {\n  const {apply} = editor\n\n  editor.apply = (operation) => {\n    apply(operation)\n\n    editor.markState = getMarkState({\n      editor,\n      schema: context.schema,\n    })\n  }\n\n  return editor\n}\n","import type {EditorSchema} from '../editor/editor-schema'\nimport {isTypedObject} from './asserters'\n\ntype Path = Array<number>\n\nexport type PortableTextNode<TEditorSchema extends EditorSchema> =\n  | EditorNode<TEditorSchema>\n  | TextBlockNode<TEditorSchema>\n  | SpanNode<TEditorSchema>\n  | PartialSpanNode\n  | ObjectNode\n\n//////////\n\nexport type EditorNode<TEditorSchema extends EditorSchema> = {\n  children: Array<TextBlockNode<TEditorSchema> | ObjectNode>\n}\n\nexport function isEditorNode<TEditorSchema extends EditorSchema>(\n  node: unknown,\n): node is EditorNode<TEditorSchema> {\n  if (typeof node === 'object' && node !== null) {\n    return (\n      !('_type' in node) && 'children' in node && Array.isArray(node.children)\n    )\n  }\n\n  return false\n}\n\n//////////\n\nexport type TextBlockNode<TEditorSchema extends EditorSchema> = {\n  _key: string\n  _type: TEditorSchema['block']['name']\n  children: Array<SpanNode<TEditorSchema> | ObjectNode>\n  [other: string]: unknown\n}\n\nexport function isTextBlockNode<TEditorSchema extends EditorSchema>(\n  context: {schema: TEditorSchema},\n  node: unknown,\n): node is TextBlockNode<TEditorSchema> {\n  return isTypedObject(node) && node._type === context.schema.block.name\n}\n\n//////////\n\nexport type SpanNode<TEditorSchema extends EditorSchema> = {\n  _key: string\n  _type?: TEditorSchema['span']['name']\n  text: string\n  [other: string]: unknown\n}\n\nexport function isSpanNode<TEditorSchema extends EditorSchema>(\n  context: {schema: TEditorSchema},\n  node: unknown,\n): node is SpanNode<TEditorSchema> {\n  if (typeof node !== 'object' || node === null) {\n    return false\n  }\n\n  if ('children' in node) {\n    return false\n  }\n\n  if ('_type' in node) {\n    return node._type === context.schema.span.name\n  }\n\n  return 'text' in node\n}\n\n//////////\n\nexport type PartialSpanNode = {\n  text: string\n  [other: string]: unknown\n}\n\nexport function isPartialSpanNode(node: unknown): node is PartialSpanNode {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    'text' in node &&\n    typeof node.text === 'string'\n  )\n}\n\n//////////\n\nexport type ObjectNode = {\n  _type: string\n  _key: string\n  [other: string]: unknown\n}\n\nexport function isObjectNode(\n  context: {schema: EditorSchema},\n  node: unknown,\n): node is ObjectNode {\n  return (\n    !isEditorNode(node) &&\n    !isTextBlockNode(context, node) &&\n    !isSpanNode(context, node) &&\n    !isPartialSpanNode(node)\n  )\n}\n\n/**\n *\n */\nexport function getBlock<TEditorSchema extends EditorSchema>(\n  root: EditorNode<TEditorSchema>,\n  path: Path,\n): TextBlockNode<TEditorSchema> | ObjectNode | undefined {\n  const index = path.at(0)\n\n  if (index === undefined || path.length !== 1) {\n    return undefined\n  }\n\n  return root.children.at(index)\n}\n\n/**\n * A \"node\" can either be\n * 1. The root (path length is 0)\n * 2. A block (path length is 1)\n * 3. A span (path length is 2)\n * 4. Or an inline object (path length is 2)\n */\nexport function getNode<TEditorSchema extends EditorSchema>(\n  context: {schema: TEditorSchema},\n  root: EditorNode<TEditorSchema>,\n  path: Path,\n): PortableTextNode<TEditorSchema> | undefined {\n  if (path.length === 0) {\n    return root\n  }\n\n  if (path.length === 1) {\n    return getBlock(root, path)\n  }\n\n  if (path.length === 2) {\n    const block = getBlock(root, path.slice(0, 1))\n\n    if (!block || !isTextBlockNode(context, block)) {\n      return undefined\n    }\n\n    const child = block.children.at(path[1])\n\n    if (!child) {\n      return undefined\n    }\n\n    return child\n  }\n}\n\nexport function getSpan<TEditorSchema extends EditorSchema>(\n  context: {schema: TEditorSchema},\n  root: EditorNode<TEditorSchema>,\n  path: Path,\n) {\n  const node = getNode(context, root, path)\n\n  if (node && isSpanNode(context, node)) {\n    return node\n  }\n\n  return undefined\n}\n\n/**\n * A parent can either be the root or a text block\n */\nexport function getParent<TEditorSchema extends EditorSchema>(\n  context: {schema: TEditorSchema},\n  root: EditorNode<TEditorSchema>,\n  path: Path,\n) {\n  if (path.length === 0) {\n    return undefined\n  }\n\n  const parentPath = path.slice(0, -1)\n\n  if (parentPath.length === 0) {\n    return root\n  }\n\n  const blockIndex = parentPath.at(0)\n\n  if (blockIndex === undefined || parentPath.length !== 1) {\n    return undefined\n  }\n\n  const block = root.children.at(blockIndex)\n\n  if (block && isTextBlockNode(context, block)) {\n    return block\n  }\n\n  return undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport {createDraft, finishDraft, type WritableDraft} from 'immer'\nimport {Element, Path, type Node, type Operation} from 'slate'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {OmitFromUnion} from '../type-utils'\nimport {\n  getBlock,\n  getNode,\n  getParent,\n  getSpan,\n  isEditorNode,\n  isObjectNode,\n  isPartialSpanNode,\n  isSpanNode,\n  isTextBlockNode,\n  type PortableTextNode,\n  type SpanNode,\n  type TextBlockNode,\n} from './portable-text-node'\n\nexport function applyOperationToPortableText(\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>,\n  value: Array<PortableTextBlock>,\n  operation: OmitFromUnion<Operation, 'type', 'set_selection'>,\n) {\n  const draft = createDraft({children: value})\n\n  try {\n    applyOperationToPortableTextDraft(context, draft, operation)\n  } catch (e) {\n    console.error(e)\n  }\n\n  return finishDraft(draft).children\n}\n\nfunction applyOperationToPortableTextDraft(\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>,\n  root: WritableDraft<{\n    children: Array<PortableTextBlock>\n  }>,\n  operation: OmitFromUnion<Operation, 'type', 'set_selection'>,\n) {\n  switch (operation.type) {\n    case 'insert_node': {\n      const {path, node: insertedNode} = operation\n      const parent = getParent(context, root, path)\n      const index = path[path.length - 1]\n\n      if (!parent) {\n        break\n      }\n\n      if (index > parent.children.length) {\n        break\n      }\n\n      if (path.length === 1) {\n        // Inserting block at the root\n\n        if (isTextBlockNode(context, insertedNode)) {\n          // Text blocks can be inserted as is\n\n          parent.children.splice(index, 0, {\n            ...insertedNode,\n            children: insertedNode.children.map((child) => {\n              if ('__inline' in child) {\n                // Except for inline object children which need to have their\n                // `value` spread onto the block\n                return {\n                  _key: child._key,\n                  _type: child._type,\n                  ...('value' in child && typeof child.value === 'object'\n                    ? child.value\n                    : {}),\n                }\n              }\n\n              return child\n            }),\n          })\n\n          break\n        }\n\n        if (Element.isElement(insertedNode) && !('__inline' in insertedNode)) {\n          // Void blocks have to have their `value` spread onto the block\n\n          parent.children.splice(index, 0, {\n            _key: insertedNode._key,\n            _type: insertedNode._type,\n            ...('value' in insertedNode &&\n            typeof insertedNode.value === 'object'\n              ? insertedNode.value\n              : {}),\n          })\n          break\n        }\n      }\n\n      if (path.length === 2) {\n        // Inserting children into blocks\n\n        if (!isTextBlockNode(context, parent)) {\n          // Only text blocks can have children\n          break\n        }\n\n        if (isPartialSpanNode(insertedNode)) {\n          // Text nodes can be inserted as is\n\n          parent.children.splice(index, 0, insertedNode)\n          break\n        }\n\n        if ('__inline' in insertedNode) {\n          // Void children have to have their `value` spread onto the block\n\n          parent.children.splice(index, 0, {\n            _key: insertedNode._key,\n            _type: insertedNode._type,\n            ...('value' in insertedNode &&\n            typeof insertedNode.value === 'object'\n              ? insertedNode.value\n              : {}),\n          })\n          break\n        }\n      }\n\n      break\n    }\n\n    case 'insert_text': {\n      const {path, offset, text} = operation\n      if (text.length === 0) break\n      const span = getSpan(context, root, path)\n\n      if (!span) {\n        break\n      }\n\n      const before = span.text.slice(0, offset)\n      const after = span.text.slice(offset)\n      span.text = before + text + after\n\n      break\n    }\n\n    case 'merge_node': {\n      const {path} = operation\n      const node = getNode(context, root, path)\n      const prevPath = Path.previous(path)\n      const prev = getNode(context, root, prevPath)\n      const parent = getParent(context, root, path)\n\n      if (!node || !prev || !parent) {\n        break\n      }\n\n      const index = path[path.length - 1]\n\n      if (isPartialSpanNode(node) && isPartialSpanNode(prev)) {\n        prev.text += node.text\n      } else if (\n        isTextBlockNode(context, node) &&\n        isTextBlockNode(context, prev)\n      ) {\n        prev.children.push(...node.children)\n      } else {\n        break\n      }\n\n      parent.children.splice(index, 1)\n\n      break\n    }\n\n    case 'move_node': {\n      const {path, newPath} = operation\n\n      if (Path.isAncestor(path, newPath)) {\n        break\n      }\n\n      const node = getNode(context, root, path)\n      const parent = getParent(context, root, path)\n      const index = path[path.length - 1]\n\n      if (!node || !parent) {\n        break\n      }\n\n      // This is tricky, but since the `path` and `newPath` both refer to\n      // the same snapshot in time, there's a mismatch. After either\n      // removing the original position, the second step's path can be out\n      // of date. So instead of using the `op.newPath` directly, we\n      // transform `op.path` to ascertain what the `newPath` would be after\n      // the operation was applied.\n      parent.children.splice(index, 1)\n      const truePath = Path.transform(path, operation)!\n      const newParent = getNode(context, root, Path.parent(truePath))\n      const newIndex = truePath[truePath.length - 1]\n\n      if (!newParent) {\n        break\n      }\n\n      if (!('children' in newParent)) {\n        break\n      }\n\n      if (!Array.isArray(newParent.children)) {\n        break\n      }\n\n      newParent.children.splice(newIndex, 0, node)\n\n      break\n    }\n\n    case 'remove_node': {\n      const {path} = operation\n      const index = path[path.length - 1]\n      const parent = getParent(context, root, path)\n      parent?.children.splice(index, 1)\n\n      break\n    }\n\n    case 'remove_text': {\n      const {path, offset, text} = operation\n\n      if (text.length === 0) {\n        break\n      }\n\n      const span = getSpan(context, root, path)\n\n      if (!span) {\n        break\n      }\n\n      const before = span.text.slice(0, offset)\n      const after = span.text.slice(offset + text.length)\n      span.text = before + after\n\n      break\n    }\n\n    case 'set_node': {\n      const {path, properties, newProperties} = operation\n\n      const node = getNode(context, root, path)\n\n      if (!node) {\n        break\n      }\n\n      if (isEditorNode(node)) {\n        break\n      }\n\n      if (isObjectNode(context, node)) {\n        const valueBefore = (\n          'value' in properties && typeof properties.value === 'object'\n            ? properties.value\n            : {}\n        ) as Partial<Node>\n        const valueAfter = (\n          'value' in newProperties && typeof newProperties.value === 'object'\n            ? newProperties.value\n            : {}\n        ) as Partial<Node>\n\n        for (const key in newProperties) {\n          if (key === 'value') {\n            continue\n          }\n\n          const value = newProperties[key as keyof Partial<Node>]\n\n          if (value == null) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          } else {\n            node[<keyof PortableTextNode<EditorSchema>>key] = value\n          }\n        }\n\n        for (const key in properties) {\n          if (key === 'value') {\n            continue\n          }\n\n          if (!newProperties.hasOwnProperty(key)) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          }\n        }\n\n        for (const key in valueAfter) {\n          const value = valueAfter[key as keyof Partial<Node>]\n\n          if (value == null) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          } else {\n            node[<keyof PortableTextNode<EditorSchema>>key] = value\n          }\n        }\n\n        for (const key in valueBefore) {\n          if (!valueAfter.hasOwnProperty(key)) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          }\n        }\n\n        break\n      }\n\n      if (isTextBlockNode(context, node)) {\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            break\n          }\n\n          const value = newProperties[key as keyof Partial<Node>]\n\n          if (value == null) {\n            delete node[<keyof Partial<Node>>key]\n          } else {\n            node[<keyof Partial<Node>>key] = value\n          }\n        }\n\n        // properties that were previously defined, but are now missing, must be deleted\n        for (const key in properties) {\n          if (!newProperties.hasOwnProperty(key)) {\n            delete node[<keyof Partial<Node>>key]\n          }\n        }\n\n        break\n      }\n\n      if (isPartialSpanNode(node)) {\n        for (const key in newProperties) {\n          if (key === 'text') {\n            break\n          }\n\n          const value = newProperties[key as keyof Partial<Node>]\n\n          if (value == null) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          } else {\n            node[<keyof PortableTextNode<EditorSchema>>key] = value\n          }\n        }\n\n        // properties that were previously defined, but are now missing, must be deleted\n        for (const key in properties) {\n          if (!newProperties.hasOwnProperty(key)) {\n            delete node[<keyof PortableTextNode<EditorSchema>>key]\n          }\n        }\n\n        break\n      }\n\n      break\n    }\n\n    case 'split_node': {\n      const {path, position, properties} = operation\n\n      if (path.length === 0) {\n        break\n      }\n\n      const parent = getParent(context, root, path)\n      const index = path[path.length - 1]\n\n      if (!parent) {\n        break\n      }\n\n      if (isEditorNode(parent)) {\n        const block = getBlock(root, path)\n\n        if (!block || !isTextBlockNode(context, block)) {\n          break\n        }\n\n        const before = block.children.slice(0, position)\n        const after = block.children.slice(position)\n        block.children = before\n\n        // _key is deliberately left out\n        const newTextBlockNode = {\n          ...properties,\n          children: after,\n          _type: context.schema.block.name,\n        } as unknown as TextBlockNode<EditorSchema>\n\n        parent.children.splice(index + 1, 0, newTextBlockNode)\n\n        break\n      }\n\n      if (isTextBlockNode(context, parent)) {\n        const node = getNode(context, root, path)\n\n        if (!node || !isSpanNode(context, node)) {\n          break\n        }\n\n        const before = node.text.slice(0, position)\n        const after = node.text.slice(position)\n        node.text = before\n\n        // _key is deliberately left out\n        const newSpanNode = {\n          ...properties,\n          text: after,\n        } as unknown as SpanNode<EditorSchema>\n\n        parent.children.splice(index + 1, 0, newSpanNode)\n      }\n\n      break\n    }\n  }\n\n  return root\n}\n","import {applyOperationToPortableText} from '../../internal-utils/apply-operation-to-portable-text'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorContext} from '../editor-snapshot'\n\nexport function pluginUpdateValue(\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>,\n  editor: PortableTextSlateEditor,\n) {\n  const {apply} = editor\n\n  editor.apply = (operation) => {\n    if (operation.type === 'set_selection') {\n      apply(operation)\n      return\n    }\n\n    editor.value = applyOperationToPortableText(\n      context,\n      editor.value,\n      operation,\n    )\n\n    apply(operation)\n  }\n\n  return editor\n}\n","import type {BaseOperation, Editor, Node, NodeEntry} from 'slate'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport type {RelayActor} from '../relay-machine'\nimport {createWithEventListeners} from './create-with-event-listeners'\nimport {createWithMaxBlocks} from './createWithMaxBlocks'\nimport {createWithObjectKeys} from './createWithObjectKeys'\nimport {createWithPatches} from './createWithPatches'\nimport {createWithPlaceholderBlock} from './createWithPlaceholderBlock'\nimport {createWithPortableTextBlockStyle} from './createWithPortableTextBlockStyle'\nimport {createWithPortableTextMarkModel} from './createWithPortableTextMarkModel'\nimport {createWithPortableTextSelections} from './createWithPortableTextSelections'\nimport {createWithSchemaTypes} from './createWithSchemaTypes'\nimport {createWithUndoRedo} from './createWithUndoRedo'\nimport {createWithUtils} from './createWithUtils'\nimport {pluginUpdateMarkState} from './slate-plugin.update-mark-state'\nimport {pluginUpdateValue} from './slate-plugin.update-value'\n\nexport interface OriginalEditorFunctions {\n  apply: (operation: BaseOperation) => void\n  onChange: () => void\n  normalizeNode: (entry: NodeEntry<Node>) => void\n}\n\ntype PluginsOptions = {\n  editorActor: EditorActor\n  relayActor: RelayActor\n  subscriptions: Array<() => () => void>\n}\n\nexport const withPlugins = <T extends Editor>(\n  editor: T,\n  options: PluginsOptions,\n): PortableTextSlateEditor => {\n  const e = editor as T & PortableTextSlateEditor\n  const {editorActor, relayActor} = options\n  const withObjectKeys = createWithObjectKeys(editorActor)\n  const withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n  })\n  const withPatches = createWithPatches({\n    editorActor,\n    relayActor,\n    subscriptions: options.subscriptions,\n  })\n  const withMaxBlocks = createWithMaxBlocks(editorActor)\n  const withUndoRedo = createWithUndoRedo({\n    editorActor,\n    subscriptions: options.subscriptions,\n  })\n  const withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor)\n  const withPortableTextBlockStyle =\n    createWithPortableTextBlockStyle(editorActor)\n\n  const withPlaceholderBlock = createWithPlaceholderBlock(editorActor)\n\n  const withUtils = createWithUtils({\n    editorActor,\n  })\n  const withPortableTextSelections =\n    createWithPortableTextSelections(editorActor)\n  const withEventListeners = createWithEventListeners(editorActor)\n\n  // Ordering is important here, selection dealing last, data manipulation in the middle and core model stuff first.\n  return withEventListeners(\n    withSchemaTypes(\n      withObjectKeys(\n        withPortableTextMarkModel(\n          withPortableTextBlockStyle(\n            withPlaceholderBlock(\n              withUtils(\n                withMaxBlocks(\n                  withUndoRedo(\n                    withPatches(\n                      withPortableTextSelections(\n                        pluginUpdateValue(\n                          editorActor.getSnapshot().context,\n                          pluginUpdateMarkState(\n                            editorActor.getSnapshot().context,\n                            e,\n                          ),\n                        ),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n}\n","import {createEditor, type Descendant} from 'slate'\nimport {withReact} from 'slate-react'\nimport {createPlaceholderBlock} from '../internal-utils/create-placeholder-block'\nimport {debugWithName} from '../internal-utils/debug'\nimport {toSlateValue} from '../internal-utils/values'\nimport {\n  KEY_TO_SLATE_ELEMENT,\n  KEY_TO_VALUE_ELEMENT,\n} from '../internal-utils/weakMaps'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\nimport {withPlugins} from './plugins/with-plugins'\nimport type {RelayActor} from './relay-machine'\n\nconst debug = debugWithName('setup')\n\ntype SlateEditorConfig = {\n  editorActor: EditorActor\n  relayActor: RelayActor\n  subscriptions: Array<() => () => void>\n}\n\nexport type SlateEditor = {\n  instance: PortableTextSlateEditor\n  initialValue: Array<Descendant>\n}\n\nexport function createSlateEditor(config: SlateEditorConfig): SlateEditor {\n  debug('Creating new Slate editor instance')\n\n  const instance = withPlugins(withReact(createEditor()), {\n    editorActor: config.editorActor,\n    relayActor: config.relayActor,\n    subscriptions: config.subscriptions,\n  })\n\n  KEY_TO_VALUE_ELEMENT.set(instance, {})\n  KEY_TO_SLATE_ELEMENT.set(instance, {})\n\n  instance.decoratorState = {}\n  instance.markState = undefined\n  instance.value = [\n    createPlaceholderBlock(config.editorActor.getSnapshot().context),\n  ]\n\n  const initialValue = toSlateValue(instance.value, {\n    schemaTypes: config.editorActor.getSnapshot().context.schema,\n  })\n\n  const slateEditor: SlateEditor = {\n    instance,\n    initialValue,\n  }\n\n  return slateEditor\n}\n","import * as selectors from '../selectors'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nconst addAnnotationOnCollapsedSelection = defineBehavior({\n  on: 'annotation.add',\n  guard: ({snapshot}) => {\n    if (!selectors.isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const caretWordSelection = selectors.getCaretWordSelection(snapshot)\n\n    if (\n      !caretWordSelection ||\n      !selectors.isSelectionExpanded({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: caretWordSelection,\n        },\n      })\n    ) {\n      return false\n    }\n\n    return {caretWordSelection}\n  },\n  actions: [\n    ({event}, {caretWordSelection}) => [\n      raise({type: 'select', at: caretWordSelection}),\n      raise({type: 'annotation.add', annotation: event.annotation}),\n    ],\n  ],\n})\n\nexport const coreAnnotationBehaviors = {\n  addAnnotationOnCollapsedSelection,\n}\n","export interface KeyboardEventLike {\n  key: string\n  keyCode?: number\n  altKey: boolean\n  ctrlKey: boolean\n  metaKey: boolean\n  shiftKey: boolean\n}\n\ninterface HotKey {\n  keyCode?: number | undefined\n  key?: string | undefined\n  altKey: boolean | null\n  ctrlKey: boolean | null\n  metaKey: boolean | null\n  shiftKey: boolean | null\n}\n\nconst IS_MAC =\n  typeof window !== 'undefined' &&\n  /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent)\n\ntype Modifier = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n\nconst modifiers: Record<string, Modifier | undefined> = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey',\n}\n\nconst aliases: Record<string, string | undefined> = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta',\n}\n\nconst keyCodes: Record<string, number | undefined> = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'control': 17,\n  'alt': 18,\n  'pause': 19,\n  'capslock': 20,\n  'escape': 27,\n  ' ': 32,\n  'pageup': 33,\n  'pagedown': 34,\n  'end': 35,\n  'home': 36,\n  'arrowleft': 37,\n  'arrowup': 38,\n  'arrowright': 39,\n  'arrowdown': 40,\n  'insert': 45,\n  'delete': 46,\n  'meta': 91,\n  'numlock': 144,\n  'scrolllock': 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  \"'\": 222,\n  'f1': 112,\n  'f2': 113,\n  'f3': 114,\n  'f4': 115,\n  'f5': 116,\n  'f6': 117,\n  'f7': 118,\n  'f8': 119,\n  'f9': 120,\n  'f10': 121,\n  'f11': 122,\n  'f12': 123,\n  'f13': 124,\n  'f14': 125,\n  'f15': 126,\n  'f16': 127,\n  'f17': 128,\n  'f18': 129,\n  'f19': 130,\n  'f20': 131,\n}\n\nexport function isHotkey(hotkey: string, event: KeyboardEventLike): boolean {\n  return compareHotkey(parseHotkey(hotkey), event)\n}\n\nfunction parseHotkey(hotkey: string): HotKey {\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n  const parsedHotkey: HotKey = {\n    altKey: false,\n    ctrlKey: false,\n    metaKey: false,\n    shiftKey: false,\n  }\n\n  // Special case to handle the `+` key since we use it as a separator.\n  const hotkeySegments = hotkey.replace('++', '+add').split('+')\n\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional =\n      rawHotkeySegment.endsWith('?') && rawHotkeySegment.length > 1\n    const hotkeySegment = optional\n      ? rawHotkeySegment.slice(0, -1)\n      : rawHotkeySegment\n    const keyName = toKeyName(hotkeySegment)\n    const modifier = modifiers[keyName]\n    const alias = aliases[hotkeySegment]\n    const code = keyCodes[keyName]\n\n    if (\n      hotkeySegment.length > 1 &&\n      modifier === undefined &&\n      alias === undefined &&\n      code === undefined\n    ) {\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`)\n    }\n\n    if (hotkeySegments.length === 1 || modifier === undefined) {\n      parsedHotkey.key = keyName\n      parsedHotkey.keyCode = toKeyCode(hotkeySegment)\n    }\n\n    if (modifier !== undefined) {\n      parsedHotkey[modifier] = optional ? null : true\n    }\n  }\n\n  return parsedHotkey\n}\n\nfunction compareHotkey(\n  parsedHotkey: HotKey,\n  event: KeyboardEventLike,\n): boolean {\n  const matchingModifiers =\n    (parsedHotkey.altKey != null\n      ? parsedHotkey.altKey === event.altKey\n      : true) &&\n    (parsedHotkey.ctrlKey != null\n      ? parsedHotkey.ctrlKey === event.ctrlKey\n      : true) &&\n    (parsedHotkey.metaKey != null\n      ? parsedHotkey.metaKey === event.metaKey\n      : true) &&\n    (parsedHotkey.shiftKey != null\n      ? parsedHotkey.shiftKey === event.shiftKey\n      : true)\n\n  if (!matchingModifiers) {\n    return false\n  }\n\n  if (parsedHotkey.keyCode !== undefined && event.keyCode !== undefined) {\n    if (parsedHotkey.keyCode === 91 && event.keyCode === 93) {\n      return true\n    }\n\n    return parsedHotkey.keyCode === event.keyCode\n  }\n\n  return (\n    parsedHotkey.keyCode === event.keyCode ||\n    parsedHotkey.key === event.key.toLowerCase()\n  )\n}\n\nfunction toKeyCode(name: string): number {\n  const keyName = toKeyName(name)\n  const keyCode = keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0)\n\n  return keyCode\n}\n\nfunction toKeyName(name: string): string {\n  const keyName = name.toLowerCase()\n\n  return aliases[keyName] ?? keyName\n}\n","import {isHotkey} from '../internal-utils/is-hotkey'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport * as selectors from '../selectors'\nimport {isEmptyTextBlock} from '../utils/util.is-empty-text-block'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nconst arrowDownOnLonelyBlockObject = defineBehavior({\n  on: 'keyboard.keydown',\n  guard: ({snapshot, event}) => {\n    const isArrowDown = isHotkey('ArrowDown', event.originEvent)\n\n    if (!isArrowDown) {\n      return false\n    }\n\n    const collapsedSelection = selectors.isSelectionCollapsed(snapshot)\n\n    if (!collapsedSelection) {\n      return false\n    }\n\n    const focusBlockObject = selectors.getFocusBlockObject(snapshot)\n    const nextBlock = selectors.getNextBlock(snapshot)\n\n    return focusBlockObject && !nextBlock\n  },\n  actions: [\n    ({snapshot}) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n        },\n        placement: 'after',\n      }),\n    ],\n  ],\n})\n\nconst arrowUpOnLonelyBlockObject = defineBehavior({\n  on: 'keyboard.keydown',\n  guard: ({snapshot, event}) => {\n    const isArrowUp = isHotkey('ArrowUp', event.originEvent)\n\n    if (!isArrowUp) {\n      return false\n    }\n\n    const collapsedSelection = selectors.isSelectionCollapsed(snapshot)\n\n    if (!collapsedSelection) {\n      return false\n    }\n\n    const focusBlockObject = selectors.getFocusBlockObject(snapshot)\n    const previousBlock = selectors.getPreviousBlock(snapshot)\n\n    return focusBlockObject && !previousBlock\n  },\n  actions: [\n    ({snapshot}) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n        },\n        placement: 'before',\n      }),\n    ],\n  ],\n})\n\nconst breakingBlockObject = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    const focusBlockObject = selectors.getFocusBlockObject(snapshot)\n    const collapsedSelection = selectors.isSelectionCollapsed(snapshot)\n\n    return collapsedSelection && focusBlockObject !== undefined\n  },\n  actions: [\n    ({snapshot}) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n        },\n        placement: 'after',\n      }),\n    ],\n  ],\n})\n\nconst clickingAboveLonelyBlockObject = defineBehavior({\n  on: 'mouse.click',\n  guard: ({snapshot, event}) => {\n    if (snapshot.context.readOnly) {\n      return false\n    }\n\n    if (\n      snapshot.context.selection &&\n      !selectors.isSelectionCollapsed(snapshot)\n    ) {\n      return false\n    }\n\n    const focusBlockObject = selectors.getFocusBlockObject({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection,\n      },\n    })\n    const previousBlock = selectors.getPreviousBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection,\n      },\n    })\n\n    return (\n      event.position.isEditor &&\n      event.position.block === 'start' &&\n      focusBlockObject &&\n      !previousBlock\n    )\n  },\n  actions: [\n    ({snapshot, event}) => [\n      raise({\n        type: 'select',\n        at: event.position.selection,\n      }),\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n        },\n        placement: 'before',\n        select: 'start',\n      }),\n    ],\n  ],\n})\n\nconst clickingBelowLonelyBlockObject = defineBehavior({\n  on: 'mouse.click',\n  guard: ({snapshot, event}) => {\n    if (snapshot.context.readOnly) {\n      return false\n    }\n\n    if (\n      snapshot.context.selection &&\n      !selectors.isSelectionCollapsed(snapshot)\n    ) {\n      return false\n    }\n\n    const focusBlockObject = selectors.getFocusBlockObject({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection,\n      },\n    })\n    const nextBlock = selectors.getNextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection,\n      },\n    })\n\n    return (\n      event.position.isEditor &&\n      event.position.block === 'end' &&\n      focusBlockObject &&\n      !nextBlock\n    )\n  },\n  actions: [\n    ({snapshot, event}) => [\n      raise({\n        type: 'select',\n        at: event.position.selection,\n      }),\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n        },\n        placement: 'after',\n        select: 'start',\n      }),\n    ],\n  ],\n})\n\nconst deletingEmptyTextBlockAfterBlockObject = defineBehavior({\n  on: 'delete.backward',\n  guard: ({snapshot}) => {\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n    const previousBlock = selectors.getPreviousBlock(snapshot)\n\n    if (!focusTextBlock || !selectionCollapsed || !previousBlock) {\n      return false\n    }\n\n    if (\n      isEmptyTextBlock(snapshot.context, focusTextBlock.node) &&\n      !isTextBlock(snapshot.context, previousBlock.node)\n    ) {\n      return {focusTextBlock, previousBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, previousBlock}) => [\n      raise({\n        type: 'delete.block',\n        at: focusTextBlock.path,\n      }),\n      raise({\n        type: 'select',\n        at: {\n          anchor: {path: previousBlock.path, offset: 0},\n          focus: {path: previousBlock.path, offset: 0},\n        },\n      }),\n    ],\n  ],\n})\n\nconst deletingEmptyTextBlockBeforeBlockObject = defineBehavior({\n  on: 'delete.forward',\n  guard: ({snapshot}) => {\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n    const nextBlock = selectors.getNextBlock(snapshot)\n\n    if (!focusTextBlock || !selectionCollapsed || !nextBlock) {\n      return false\n    }\n\n    if (\n      isEmptyTextBlock(snapshot.context, focusTextBlock.node) &&\n      !isTextBlock(snapshot.context, nextBlock.node)\n    ) {\n      return {focusTextBlock, nextBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, nextBlock}) => [\n      raise({\n        type: 'delete.block',\n        at: focusTextBlock.path,\n      }),\n      raise({\n        type: 'select',\n        at: {\n          anchor: {path: nextBlock.path, offset: 0},\n          focus: {path: nextBlock.path, offset: 0},\n        },\n      }),\n    ],\n  ],\n})\n\nexport const coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  clickingAboveLonelyBlockObject,\n  clickingBelowLonelyBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject,\n}\n","import {isHotkey} from '../internal-utils/is-hotkey'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const coreDecoratorBehaviors = {\n  strongShortcut: defineBehavior({\n    on: 'keyboard.keydown',\n    guard: ({snapshot, event}) =>\n      isHotkey('mod+b', event.originEvent) &&\n      snapshot.context.schema.decorators.some(\n        (decorator) => decorator.name === 'strong',\n      ),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'strong'})]],\n  }),\n  emShortcut: defineBehavior({\n    on: 'keyboard.keydown',\n    guard: ({snapshot, event}) =>\n      isHotkey('mod+i', event.originEvent) &&\n      snapshot.context.schema.decorators.some(\n        (decorator) => decorator.name === 'em',\n      ),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'em'})]],\n  }),\n  underlineShortcut: defineBehavior({\n    on: 'keyboard.keydown',\n    guard: ({snapshot, event}) =>\n      isHotkey('mod+u', event.originEvent) &&\n      snapshot.context.schema.decorators.some(\n        (decorator) => decorator.name === 'underline',\n      ),\n    actions: [\n      () => [raise({type: 'decorator.toggle', decorator: 'underline'})],\n    ],\n  }),\n  codeShortcut: defineBehavior({\n    on: 'keyboard.keydown',\n    guard: ({snapshot, event}) =>\n      isHotkey(\"mod+'\", event.originEvent) &&\n      snapshot.context.schema.decorators.some(\n        (decorator) => decorator.name === 'code',\n      ),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'code'})]],\n  }),\n}\n","export function getCompoundClientRect(nodes: Array<Node>): DOMRect {\n  if (nodes.length === 0) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  const elements = nodes.filter((node) => node instanceof Element)\n\n  const firstRect = elements.at(0)?.getBoundingClientRect()\n\n  if (!firstRect) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  let left = firstRect.left\n  let top = firstRect.top\n  let right = firstRect.right\n  let bottom = firstRect.bottom\n\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect()\n    left = Math.min(left, rect.left)\n    top = Math.min(top, rect.top)\n    right = Math.max(right, rect.right)\n    bottom = Math.max(bottom, rect.bottom)\n  }\n\n  return new DOMRect(left, top, right - left, bottom - top)\n}\n","import {getCompoundClientRect} from '../internal-utils/compound-client-rect'\nimport {getDragSelection} from '../internal-utils/drag-selection'\nimport * as selectors from '../selectors'\nimport {effect, forward, raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const coreDndBehaviors = [\n  /**\n   * Core Behavior that:\n   * 1. Calculates and selects a \"drag selection\"\n   * 2. Constructs and sets a drag ghost element\n   * 3. Forwards the dragstart event\n   */\n  defineBehavior({\n    on: 'drag.dragstart',\n    guard: ({snapshot, dom, event}) => {\n      const dragSelection = getDragSelection({\n        snapshot,\n        eventSelection: event.position.selection,\n      })\n      const selectingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n      const draggedDomNodes = {\n        blockNodes: dom.getBlockNodes({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        }),\n        childNodes: dom.getChildNodes({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        }),\n      }\n\n      return {\n        dragSelection,\n        draggedDomNodes,\n        selectingEntireBlocks,\n      }\n    },\n    actions: [\n      (\n        {dom, event},\n        {dragSelection, draggedDomNodes, selectingEntireBlocks},\n      ) => {\n        const dragGhost = document.createElement('div')\n\n        if (selectingEntireBlocks) {\n          // Clone the DOM Nodes so they won't be visually clipped by scroll-containers etc.\n          const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) =>\n            node.cloneNode(true),\n          )\n\n          for (const block of clonedBlockNodes) {\n            if (block instanceof HTMLElement) {\n              block.style.position = 'relative'\n            }\n            dragGhost.appendChild(block)\n          }\n\n          // A custom drag ghost element can be configured using this data attribute\n          const customGhost = dragGhost.querySelector(\n            '[data-pt-drag-ghost-element]',\n          )\n          if (customGhost) {\n            dragGhost.replaceChildren(customGhost)\n          }\n\n          // Setting the `data-dragged` attribute so the consumer can style the element while it’s dragged\n          dragGhost.setAttribute('data-dragged', '')\n\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n\n          if (customGhost) {\n            const customGhostRect = customGhost.getBoundingClientRect()\n            const x = event.originEvent.clientX - customGhostRect.left\n            const y = event.originEvent.clientY - customGhostRect.top\n            dragGhost.style.width = `${customGhostRect.width}px`\n            dragGhost.style.height = `${customGhostRect.height}px`\n\n            return [\n              raise({\n                type: 'select',\n                at: dragSelection,\n              }),\n              effect(() => {\n                dom.setDragGhost({\n                  event,\n                  ghost: {\n                    element: dragGhost,\n                    x,\n                    y,\n                  },\n                })\n              }),\n              forward(event),\n            ]\n          } else {\n            const blocksDomRect = getCompoundClientRect(\n              draggedDomNodes.blockNodes,\n            )\n            const x = event.originEvent.clientX - blocksDomRect.left\n            const y = event.originEvent.clientY - blocksDomRect.top\n            dragGhost.style.width = `${blocksDomRect.width}px`\n            dragGhost.style.height = `${blocksDomRect.height}px`\n\n            return [\n              raise({\n                type: 'select',\n                at: dragSelection,\n              }),\n              effect(() => {\n                dom.setDragGhost({\n                  event,\n                  ghost: {element: dragGhost, x, y},\n                })\n              }),\n              forward(event),\n            ]\n          }\n        } else {\n          const clonedChildNodes = draggedDomNodes.childNodes.map((node) =>\n            node.cloneNode(true),\n          )\n\n          for (const child of clonedChildNodes) {\n            dragGhost.appendChild(child)\n          }\n\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n\n          const childrenDomRect = getCompoundClientRect(\n            draggedDomNodes.childNodes,\n          )\n          const x = event.originEvent.clientX - childrenDomRect.left\n          const y = event.originEvent.clientY - childrenDomRect.top\n          dragGhost.style.width = `${childrenDomRect.width}px`\n          dragGhost.style.height = `${childrenDomRect.height}px`\n\n          return [\n            raise({\n              type: 'select',\n              at: dragSelection,\n            }),\n            effect(() => {\n              dom.setDragGhost({\n                event,\n                ghost: {element: dragGhost, x, y},\n              })\n            }),\n            forward(event),\n          ]\n        }\n      },\n    ],\n  }),\n\n  /**\n   * When dragging over the drag origin, we don't want to show the caret in the\n   * text.\n   */\n  defineBehavior({\n    on: 'drag.dragover',\n    guard: ({snapshot, event}) => {\n      const dragOrigin = event.dragOrigin\n      const draggingOverDragOrigin = dragOrigin\n        ? selectors.isOverlappingSelection(event.position.selection)({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragOrigin.selection,\n            },\n          })\n        : false\n\n      return draggingOverDragOrigin\n    },\n    actions: [],\n  }),\n\n  /**\n   * If the drop position overlaps the drag origin, then the event should be\n   * cancelled.\n   */\n  defineBehavior({\n    on: 'drag.drop',\n    guard: ({snapshot, event}) => {\n      const dragOrigin = event.dragOrigin\n      const dropPosition = event.position.selection\n      const droppingOnDragOrigin = dragOrigin\n        ? selectors.isOverlappingSelection(dropPosition)({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragOrigin.selection,\n            },\n          })\n        : false\n      return droppingOnDragOrigin\n    },\n    actions: [],\n  }),\n  /**\n   * If we drop and have access to a drag origin, then we can deserialize\n   * without creating a new selection.\n   */\n  defineBehavior({\n    on: 'drag.drop',\n    guard: ({event}) => event.dragOrigin !== undefined,\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'deserialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  /**\n   * Otherwise, we should to create a new selection.\n   */\n  defineBehavior({\n    on: 'drag.drop',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'select',\n          at: event.position.selection,\n        }),\n        raise({\n          type: 'deserialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n\n  /**\n   * Core Behavior that uses the drag origin to mimic a move operation during\n   * internal dragging.\n   */\n  defineBehavior({\n    on: 'deserialization.success',\n    guard: ({snapshot, event}) => {\n      if (\n        event.originEvent.type !== 'drag.drop' ||\n        event.originEvent.dragOrigin === undefined\n      ) {\n        return false\n      }\n\n      const dragOrigin = event.originEvent.dragOrigin\n      const dragSelection = getDragSelection({\n        eventSelection: dragOrigin.selection,\n        snapshot,\n      })\n      const dropPosition = event.originEvent.position.selection\n      const droppingOnDragOrigin = dragOrigin\n        ? selectors.isOverlappingSelection(dropPosition)({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragSelection,\n            },\n          })\n        : false\n\n      const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      const draggedBlocks = selectors.getSelectedBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      if (!droppingOnDragOrigin) {\n        return {\n          dropPosition,\n          draggingEntireBlocks,\n          draggedBlocks,\n          dragOrigin,\n          originEvent: event.originEvent,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      (\n        {event},\n        {\n          draggingEntireBlocks,\n          draggedBlocks,\n          dragOrigin,\n          dropPosition,\n          originEvent,\n        },\n      ) => [\n        ...(draggingEntireBlocks\n          ? draggedBlocks.map((block) =>\n              raise({\n                type: 'delete.block',\n                at: block.path,\n              }),\n            )\n          : [\n              raise({\n                type: 'delete',\n                at: dragOrigin.selection,\n              }),\n            ]),\n        raise({\n          type: 'select',\n          at: dropPosition,\n        }),\n        raise({\n          type: 'insert.blocks',\n          blocks: event.data,\n          placement: draggingEntireBlocks\n            ? originEvent.position.block === 'start'\n              ? 'before'\n              : originEvent.position.block === 'end'\n                ? 'after'\n                : 'auto'\n            : 'auto',\n        }),\n      ],\n    ],\n  }),\n]\n","import * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nconst breakingAtTheEndOfTextBlock = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed) {\n      return false\n    }\n\n    const atTheEndOfBlock =\n      selectors.isAtTheEndOfBlock(focusTextBlock)(snapshot)\n\n    const focusListItem = focusTextBlock.node.listItem\n    const focusLevel = focusTextBlock.node.level\n\n    if (atTheEndOfBlock) {\n      return {focusListItem, focusLevel}\n    }\n\n    return false\n  },\n  actions: [\n    ({snapshot}, {focusListItem, focusLevel}) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n          children: [\n            {\n              _type: snapshot.context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n          markDefs: [],\n          listItem: focusListItem,\n          level: focusLevel,\n          style: snapshot.context.schema.styles[0]?.name,\n        },\n        placement: 'after',\n      }),\n    ],\n  ],\n})\n\nconst breakingAtTheStartOfTextBlock = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed) {\n      return false\n    }\n\n    const focusSpan = selectors.getFocusSpan(snapshot)\n\n    const focusDecorators = focusSpan?.node.marks?.filter(\n      (mark) =>\n        snapshot.context.schema.decorators.some(\n          (decorator) => decorator.name === mark,\n        ) ?? [],\n    )\n    const focusAnnotations =\n      focusSpan?.node.marks?.filter(\n        (mark) =>\n          !snapshot.context.schema.decorators.some(\n            (decorator) => decorator.name === mark,\n          ),\n      ) ?? []\n    const focusListItem = focusTextBlock.node.listItem\n    const focusLevel = focusTextBlock.node.level\n\n    const atTheStartOfBlock =\n      selectors.isAtTheStartOfBlock(focusTextBlock)(snapshot)\n\n    if (atTheStartOfBlock) {\n      return {focusAnnotations, focusDecorators, focusListItem, focusLevel}\n    }\n\n    return false\n  },\n  actions: [\n    (\n      {snapshot},\n      {focusAnnotations, focusDecorators, focusListItem, focusLevel},\n    ) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n          children: [\n            {\n              _type: snapshot.context.schema.span.name,\n              marks: focusAnnotations.length === 0 ? focusDecorators : [],\n              text: '',\n            },\n          ],\n          listItem: focusListItem,\n          level: focusLevel,\n          style: snapshot.context.schema.styles[0]?.name,\n        },\n        placement: 'before',\n        select: 'none',\n      }),\n    ],\n  ],\n})\n\nconst breakingEntireDocument = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    if (!selectors.isSelectionExpanded(snapshot)) {\n      return false\n    }\n\n    const firstBlock = selectors.getFirstBlock(snapshot)\n    const lastBlock = selectors.getLastBlock(snapshot)\n\n    if (!firstBlock || !lastBlock) {\n      return false\n    }\n\n    const firstBlockStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block: firstBlock,\n    })\n    const selectionStartPoint = utils.getSelectionStartPoint(\n      snapshot.context.selection,\n    )\n    const lastBlockEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block: lastBlock,\n    })\n    const selectionEndPoint = utils.getSelectionEndPoint(\n      snapshot.context.selection,\n    )\n\n    if (\n      utils.isEqualSelectionPoints(firstBlockStartPoint, selectionStartPoint) &&\n      utils.isEqualSelectionPoints(lastBlockEndPoint, selectionEndPoint)\n    ) {\n      return {selection: snapshot.context.selection}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {selection}) => [\n      raise({\n        type: 'delete',\n        at: selection,\n      }),\n    ],\n  ],\n})\n\nconst breakingEntireBlocks = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    if (!selectors.isSelectionExpanded(snapshot)) {\n      return false\n    }\n\n    const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return false\n    }\n\n    const startBlockStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block: selectionStartBlock,\n    })\n    const selectionStartPoint = utils.getSelectionStartPoint(\n      snapshot.context.selection,\n    )\n    const endBlockEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block: selectionEndBlock,\n    })\n    const selectionEndPoint = utils.getSelectionEndPoint(\n      snapshot.context.selection,\n    )\n\n    if (\n      utils.isEqualSelectionPoints(selectionStartPoint, startBlockStartPoint) &&\n      utils.isEqualSelectionPoints(selectionEndPoint, endBlockEndPoint)\n    ) {\n      return {selectedBlocks}\n    }\n\n    return false\n  },\n  actions: [\n    ({snapshot}, {selectedBlocks}) => [\n      raise({\n        type: 'insert.block',\n        block: {\n          _type: snapshot.context.schema.block.name,\n          children: [\n            {\n              _type: snapshot.context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n        },\n        placement: 'before',\n        select: 'start',\n      }),\n      ...selectedBlocks.map((block) =>\n        raise({\n          type: 'delete.block',\n          at: block.path,\n        }),\n      ),\n    ],\n  ],\n})\n\nexport const coreInsertBreakBehaviors = {\n  breakingAtTheEndOfTextBlock,\n  breakingAtTheStartOfTextBlock,\n  breakingEntireDocument,\n  breakingEntireBlocks,\n}\n","import {isHotkey} from '../internal-utils/is-hotkey'\nimport {isListBlock} from '../internal-utils/parse-blocks'\nimport * as selectors from '../selectors'\nimport {isEmptyTextBlock} from '../utils/util.is-empty-text-block'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nconst MAX_LIST_LEVEL = 10\n\nconst clearListOnBackspace = defineBehavior({\n  on: 'delete.backward',\n  guard: ({snapshot}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const focusSpan = selectors.getFocusSpan(snapshot)\n\n    if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n      return false\n    }\n\n    const atTheBeginningOfBLock =\n      focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n      snapshot.context.selection?.focus.offset === 0\n\n    if (atTheBeginningOfBLock && focusTextBlock.node.level === 1) {\n      return {focusTextBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock}) => [\n      raise({\n        type: 'block.unset',\n        props: ['listItem', 'level'],\n        at: focusTextBlock.path,\n      }),\n    ],\n  ],\n})\n\nconst unindentListOnBackspace = defineBehavior({\n  on: 'delete.backward',\n  guard: ({snapshot}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n    const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n    const focusSpan = selectors.getFocusSpan(snapshot)\n\n    if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n      return false\n    }\n\n    const atTheBeginningOfBLock =\n      focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n      snapshot.context.selection?.focus.offset === 0\n\n    if (\n      atTheBeginningOfBLock &&\n      focusTextBlock.node.level !== undefined &&\n      focusTextBlock.node.level > 1\n    ) {\n      return {focusTextBlock, level: focusTextBlock.node.level - 1}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, level}) => [\n      raise({\n        type: 'block.set',\n        props: {level},\n        at: focusTextBlock.path,\n      }),\n    ],\n  ],\n})\n\nconst clearListOnEnter = defineBehavior({\n  on: 'insert.break',\n  guard: ({snapshot}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n    const focusListBlock = selectors.getFocusListBlock(snapshot)\n\n    if (\n      !selectionCollapsed ||\n      !focusListBlock ||\n      !isEmptyTextBlock(snapshot.context, focusListBlock.node)\n    ) {\n      return false\n    }\n\n    return {focusListBlock}\n  },\n  actions: [\n    (_, {focusListBlock}) => [\n      raise({\n        type: 'block.unset',\n        props: ['listItem', 'level'],\n        at: focusListBlock.path,\n      }),\n    ],\n  ],\n})\n\nconst indentListOnTab = defineBehavior({\n  on: 'keyboard.keydown',\n  guard: ({snapshot, event}) => {\n    const isTab = isHotkey('Tab', event.originEvent)\n\n    if (!isTab) {\n      return false\n    }\n\n    const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n    const selectedListBlocks = selectedBlocks.flatMap((block) =>\n      isListBlock(snapshot.context, block.node)\n        ? [\n            {\n              node: block.node,\n              path: block.path,\n            },\n          ]\n        : [],\n    )\n\n    if (selectedListBlocks.length === selectedBlocks.length) {\n      return {selectedListBlocks}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {selectedListBlocks}) =>\n      selectedListBlocks.map((selectedListBlock) =>\n        raise({\n          type: 'block.set',\n          props: {\n            level: Math.min(\n              MAX_LIST_LEVEL,\n              Math.max(1, selectedListBlock.node.level + 1),\n            ),\n          },\n          at: selectedListBlock.path,\n        }),\n      ),\n  ],\n})\n\nconst unindentListOnShiftTab = defineBehavior({\n  on: 'keyboard.keydown',\n  guard: ({snapshot, event}) => {\n    const isShiftTab = isHotkey('Shift+Tab', event.originEvent)\n\n    if (!isShiftTab) {\n      return false\n    }\n\n    const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n    const selectedListBlocks = selectedBlocks.flatMap((block) =>\n      isListBlock(snapshot.context, block.node)\n        ? [\n            {\n              node: block.node,\n              path: block.path,\n            },\n          ]\n        : [],\n    )\n\n    if (selectedListBlocks.length === selectedBlocks.length) {\n      return {selectedListBlocks}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {selectedListBlocks}) =>\n      selectedListBlocks.map((selectedListBlock) =>\n        raise({\n          type: 'block.set',\n          props: {\n            level: Math.min(\n              MAX_LIST_LEVEL,\n              Math.max(1, selectedListBlock.node.level - 1),\n            ),\n          },\n          at: selectedListBlock.path,\n        }),\n      ),\n  ],\n})\n\nexport const coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab,\n}\n","import {corePriority} from '../priority/priority.core'\nimport {coreAnnotationBehaviors} from './behavior.core.annotations'\nimport {coreBlockObjectBehaviors} from './behavior.core.block-objects'\nimport {coreDecoratorBehaviors} from './behavior.core.decorators'\nimport {coreDndBehaviors} from './behavior.core.dnd'\nimport {coreInsertBreakBehaviors} from './behavior.core.insert-break'\nimport {coreListBehaviors} from './behavior.core.lists'\n\nexport const coreBehaviorsConfig = [\n  coreAnnotationBehaviors.addAnnotationOnCollapsedSelection,\n  coreDecoratorBehaviors.strongShortcut,\n  coreDecoratorBehaviors.emShortcut,\n  coreDecoratorBehaviors.underlineShortcut,\n  coreDecoratorBehaviors.codeShortcut,\n  ...coreDndBehaviors,\n  coreBlockObjectBehaviors.clickingAboveLonelyBlockObject,\n  coreBlockObjectBehaviors.clickingBelowLonelyBlockObject,\n  coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject,\n  coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject,\n  coreBlockObjectBehaviors.breakingBlockObject,\n  coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject,\n  coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject,\n  coreListBehaviors.clearListOnBackspace,\n  coreListBehaviors.unindentListOnBackspace,\n  coreListBehaviors.clearListOnEnter,\n  coreListBehaviors.indentListOnTab,\n  coreListBehaviors.unindentListOnShiftTab,\n  coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock,\n  coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock,\n  coreInsertBreakBehaviors.breakingEntireDocument,\n  coreInsertBreakBehaviors.breakingEntireBlocks,\n].map((behavior) => ({\n  behavior,\n  priority: corePriority,\n}))\n","import {Editor} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSnapshot} from '..'\nimport type {BehaviorEvent} from '../behaviors'\nimport type {PickFromUnion} from '../type-utils'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {toSlateRange} from './ranges'\n\nexport type EditorDom = {\n  getBlockNodes: (snapshot: EditorSnapshot) => Array<Node>\n  getChildNodes: (snapshot: EditorSnapshot) => Array<Node>\n  /**\n   * Let the Editor set the drag ghost. This is to be sure that it will get\n   * properly removed again when the drag ends.\n   */\n  setDragGhost: ({\n    event,\n    ghost,\n  }: {\n    event: PickFromUnion<BehaviorEvent, 'type', 'drag.dragstart'>\n    ghost: {\n      element: HTMLElement\n      x: number\n      y: number\n    }\n  }) => void\n}\n\nexport function createEditorDom(\n  sendBack: (event: {type: 'set drag ghost'; ghost: HTMLElement}) => void,\n  slateEditor: PortableTextSlateEditor,\n): EditorDom {\n  return {\n    getBlockNodes: (snapshot) => getBlockNodes(slateEditor, snapshot),\n    getChildNodes: (snapshot) => getChildNodes(slateEditor, snapshot),\n    setDragGhost: ({event, ghost}) => setDragGhost({sendBack, event, ghost}),\n  }\n}\n\nfunction getBlockNodes(\n  slateEditor: PortableTextSlateEditor,\n  snapshot: EditorSnapshot,\n) {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return []\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  return blockEntries.map(([blockNode]) =>\n    DOMEditor.toDOMNode(slateEditor, blockNode),\n  )\n}\n\nfunction getChildNodes(\n  slateEditor: PortableTextSlateEditor,\n  snapshot: EditorSnapshot,\n) {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return []\n  }\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  return childEntries.map(([childNode]) =>\n    DOMEditor.toDOMNode(slateEditor, childNode),\n  )\n}\n\nexport type SelectionDomNodes = {\n  blockNodes: Array<Node>\n  childNodes: Array<Node>\n}\n\nexport function getSelectionDomNodes({\n  slateEditor,\n  snapshot,\n}: {\n  slateEditor: PortableTextSlateEditor\n  snapshot: EditorSnapshot\n}): SelectionDomNodes {\n  if (!snapshot.context.selection) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) =>\n        (!Editor.isEditor(n) && slateEditor.isTextSpan(n)) ||\n        !slateEditor.isBlock(n),\n    }),\n  )\n\n  return {\n    blockNodes: blockEntries.map(([blockNode]) =>\n      DOMEditor.toDOMNode(slateEditor, blockNode),\n    ),\n    childNodes: childEntries.map(([childNode]) =>\n      DOMEditor.toDOMNode(slateEditor, childNode),\n    ),\n  }\n}\n\nfunction setDragGhost({\n  sendBack,\n  event,\n  ghost,\n}: {\n  sendBack: (event: {type: 'set drag ghost'; ghost: HTMLElement}) => void\n  event: PickFromUnion<BehaviorEvent, 'type', 'drag.dragstart'>\n  ghost: {\n    element: HTMLElement\n    x: number\n    y: number\n  }\n}) {\n  event.originEvent.dataTransfer.setDragImage(ghost.element, ghost.x, ghost.y)\n\n  sendBack({\n    type: 'set drag ghost',\n    ghost: ghost.element,\n  })\n}\n","import {isActiveAnnotation} from '../selectors'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractAnnotationBehaviors = [\n  defineBehavior({\n    on: 'annotation.toggle',\n    guard: ({snapshot, event}) =>\n      isActiveAnnotation(event.annotation.name)(snapshot),\n    actions: [\n      ({event}) => [\n        raise({type: 'annotation.remove', annotation: event.annotation}),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'annotation.toggle',\n    guard: ({snapshot, event}) =>\n      !isActiveAnnotation(event.annotation.name)(snapshot),\n    actions: [\n      ({event}) => [\n        raise({type: 'annotation.add', annotation: event.annotation}),\n      ],\n    ],\n  }),\n]\n","import {isActiveDecorator} from '../selectors'\nimport {blockOffsetsToSelection} from '../utils'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractDecoratorBehaviors = [\n  defineBehavior({\n    on: 'decorator.toggle',\n    guard: ({snapshot, event}) => isActiveDecorator(event.decorator)(snapshot),\n    actions: [\n      ({event}) => [\n        raise({type: 'decorator.remove', decorator: event.decorator}),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'decorator.toggle',\n    guard: ({snapshot, event}) => {\n      const manualSelection = event.at\n        ? blockOffsetsToSelection({\n            context: snapshot.context,\n            offsets: event.at,\n          })\n        : null\n\n      if (manualSelection) {\n        return !isActiveDecorator(event.decorator)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: manualSelection,\n          },\n        })\n      }\n\n      return !isActiveDecorator(event.decorator)(snapshot)\n    },\n    actions: [\n      ({event}) => [\n        raise({\n          ...event,\n          type: 'decorator.add',\n        }),\n      ],\n    ],\n  }),\n]\n","import * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractDeleteBehaviors = [\n  defineBehavior({\n    on: 'delete.backward',\n    guard: ({snapshot}) => {\n      if (!snapshot.context.selection) {\n        return false\n      }\n\n      return {selection: snapshot.context.selection}\n    },\n    actions: [\n      ({event}, {selection}) => [\n        raise({\n          type: 'delete',\n          direction: 'backward',\n          unit: event.unit,\n          at: selection,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'delete.forward',\n    guard: ({snapshot}) => {\n      if (!snapshot.context.selection) {\n        return false\n      }\n\n      return {selection: snapshot.context.selection}\n    },\n    actions: [\n      ({event}, {selection}) => [\n        raise({\n          type: 'delete',\n          direction: 'forward',\n          unit: event.unit,\n          at: selection,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'delete.block',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'delete',\n          at: {\n            anchor: {\n              path: event.at,\n              offset: 0,\n            },\n            focus: {\n              path: event.at,\n              offset: 0,\n            },\n          },\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'delete.text',\n    guard: ({snapshot, event}) => {\n      const selection = utils.blockOffsetsToSelection({\n        context: snapshot.context,\n        offsets: event.at,\n      })\n\n      if (!selection) {\n        return false\n      }\n\n      const trimmedSelection = selectors.getTrimmedSelection({\n        beta: {\n          activeAnnotations: [],\n          activeDecorators: [],\n        },\n        context: {\n          converters: [],\n          schema: snapshot.context.schema,\n          keyGenerator: snapshot.context.keyGenerator,\n          readOnly: false,\n          value: snapshot.context.value,\n          selection,\n        },\n      })\n\n      if (!trimmedSelection) {\n        return false\n      }\n\n      return {\n        selection: trimmedSelection,\n      }\n    },\n    actions: [(_, {selection}) => [raise({type: 'delete', at: selection})]],\n  }),\n]\n","import {getFocusTextBlock} from '../selectors'\nimport {isEmptyTextBlock} from '../utils'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractInsertBehaviors = [\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({event}) => event.placement === 'before',\n    actions: [\n      ({event}) =>\n        event.blocks.map((block, index) =>\n          raise({\n            type: 'insert.block',\n            block,\n            placement: index === 0 ? 'before' : 'after',\n            select: event.select ?? 'end',\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({event}) => event.placement === 'after',\n    actions: [\n      ({event}) =>\n        event.blocks.map((block) =>\n          raise({\n            type: 'insert.block',\n            block,\n            placement: 'after',\n            select: event.select ?? 'end',\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({snapshot, event}) => {\n      if (event.placement !== 'auto') {\n        return false\n      }\n\n      const focusTextBlock = getFocusTextBlock(snapshot)\n\n      if (!focusTextBlock) {\n        return false\n      }\n\n      return {focusTextBlock}\n    },\n    actions: [\n      ({snapshot, event}, {focusTextBlock}) =>\n        event.blocks.length === 1\n          ? [\n              raise({\n                type: 'insert.block',\n                block: event.blocks[0],\n                placement: 'auto',\n                select: event.select ?? 'end',\n              }),\n            ]\n          : isEmptyTextBlock(snapshot.context, focusTextBlock.node)\n            ? event.blocks.map((block, index) =>\n                raise({\n                  type: 'insert.block',\n                  block,\n                  placement: index === 0 ? 'auto' : 'after',\n                  select: event.select ?? 'end',\n                }),\n              )\n            : event.blocks.flatMap((block, index) =>\n                index === 0\n                  ? [\n                      raise({\n                        type: 'split',\n                      }),\n                      raise({\n                        type: 'select.previous block',\n                        select: 'end',\n                      }),\n                      raise({\n                        type: 'insert.block',\n                        block,\n                        placement: 'auto',\n                        select: event.select ?? 'end',\n                      }),\n                    ]\n                  : index === event.blocks.length - 1\n                    ? [\n                        raise({\n                          type: 'select.next block',\n                          select: 'start',\n                        }),\n                        raise({\n                          type: 'insert.block',\n                          block,\n                          placement: 'auto',\n                          select: event.select ?? 'end',\n                        }),\n                      ]\n                    : [\n                        raise({\n                          type: 'insert.block',\n                          block,\n                          placement: 'after',\n                          select: event.select ?? 'end',\n                        }),\n                      ],\n              ),\n    ],\n  }),\n  defineBehavior({\n    on: 'insert.blocks',\n    guard: ({event}) => event.placement === 'auto',\n    actions: [\n      ({event}) =>\n        event.blocks.map((block, index) =>\n          raise({\n            type: 'insert.block',\n            block,\n            placement: index === 0 ? 'auto' : 'after',\n            select: event.select ?? 'end',\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'insert.break',\n    actions: [() => [raise({type: 'split'})]],\n  }),\n  defineBehavior({\n    on: 'insert.soft break',\n    actions: [() => [raise({type: 'insert.text', text: '\\n'})]],\n  }),\n]\n","export const keyIs = {\n  lineBreak: (event) => event.key === 'Enter' && event.shiftKey,\n} satisfies Record<string, KeyboardEventPredicate>\n\ntype KeyboardEventPredicate = (\n  event: Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n) => boolean\n","import {keyIs} from '../internal-utils/key-is'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractKeyboardBehaviors = [\n  /**\n   * On WebKit, Shift+Enter results in an `insertParagraph` input event rather\n   * than an `insertLineBreak` input event. This Behavior makes sure we catch\n   * that `keyboard.keydown` event beforehand and raise an `insert.soft break` manually.\n   */\n  defineBehavior({\n    on: 'keyboard.keydown',\n    guard: ({event}) => keyIs.lineBreak(event.originEvent),\n    actions: [() => [raise({type: 'insert.soft break'})]],\n  }),\n]\n","import {getSelectedTextBlocks, isActiveListItem} from '../selectors'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractListItemBehaviors = [\n  defineBehavior({\n    on: 'list item.add',\n    guard: ({snapshot}) => {\n      const selectedTextBlocks = getSelectedTextBlocks(snapshot)\n\n      return {selectedTextBlocks}\n    },\n    actions: [\n      ({event}, {selectedTextBlocks}) =>\n        selectedTextBlocks.map((block) =>\n          raise({\n            type: 'block.set',\n            at: block.path,\n            props: {\n              level: 1,\n              listItem: event.listItem,\n            },\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'list item.remove',\n    guard: ({snapshot}) => {\n      const selectedTextBlocks = getSelectedTextBlocks(snapshot)\n\n      return {selectedTextBlocks}\n    },\n    actions: [\n      (_, {selectedTextBlocks}) =>\n        selectedTextBlocks.map((block) =>\n          raise({\n            type: 'block.unset',\n            at: block.path,\n            props: ['level', 'listItem'],\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'list item.toggle',\n    guard: ({snapshot, event}) => isActiveListItem(event.listItem)(snapshot),\n    actions: [\n      ({event}) => [\n        raise({type: 'list item.remove', listItem: event.listItem}),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'list item.toggle',\n    guard: ({snapshot, event}) => !isActiveListItem(event.listItem)(snapshot),\n    actions: [\n      ({event}) => [raise({type: 'list item.add', listItem: event.listItem})],\n    ],\n  }),\n]\n","import {getNextBlock, getPreviousBlock} from '../selectors'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractMoveBehaviors = [\n  defineBehavior({\n    on: 'move.block up',\n    guard: ({snapshot, event}) => {\n      const previousBlock = getPreviousBlock({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: {\n            anchor: {\n              path: event.at,\n              offset: 0,\n            },\n            focus: {\n              path: event.at,\n              offset: 0,\n            },\n          },\n        },\n      })\n\n      if (previousBlock) {\n        return {previousBlock}\n      }\n\n      return false\n    },\n    actions: [\n      ({event}, {previousBlock}) => [\n        raise({\n          type: 'move.block',\n          at: event.at,\n          to: previousBlock.path,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'move.block down',\n    guard: ({snapshot, event}) => {\n      const nextBlock = getNextBlock({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: {\n            anchor: {\n              path: event.at,\n              offset: 0,\n            },\n            focus: {\n              path: event.at,\n              offset: 0,\n            },\n          },\n        },\n      })\n\n      if (nextBlock) {\n        return {nextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      ({event}, {nextBlock}) => [\n        raise({\n          type: 'move.block',\n          at: event.at,\n          to: nextBlock.path,\n        }),\n      ],\n    ],\n  }),\n]\n","import {getNextBlock, getPreviousBlock} from '../selectors'\nimport {getBlockEndPoint, getBlockStartPoint} from '../utils'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractSelectBehaviors = [\n  defineBehavior({\n    on: 'select.previous block',\n    guard: ({snapshot, event}) => {\n      const previousBlock = getPreviousBlock(snapshot)\n\n      if (!previousBlock) {\n        return false\n      }\n\n      const point =\n        event.select === 'end'\n          ? getBlockEndPoint({\n              context: snapshot.context,\n              block: previousBlock,\n            })\n          : getBlockStartPoint({\n              context: snapshot.context,\n              block: previousBlock,\n            })\n\n      return {\n        selection: {\n          anchor: point,\n          focus: point,\n        },\n      }\n    },\n    actions: [\n      (_, {selection}) => [\n        raise({\n          type: 'select',\n          at: selection,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'select.next block',\n    guard: ({snapshot, event}) => {\n      const nextBlock = getNextBlock(snapshot)\n\n      if (!nextBlock) {\n        return false\n      }\n\n      const point =\n        event.select === 'end'\n          ? getBlockEndPoint({\n              context: snapshot.context,\n              block: nextBlock,\n            })\n          : getBlockStartPoint({\n              context: snapshot.context,\n              block: nextBlock,\n            })\n\n      return {selection: {anchor: point, focus: point}}\n    },\n    actions: [\n      (_, {selection}) => [\n        raise({\n          type: 'select',\n          at: selection,\n        }),\n      ],\n    ],\n  }),\n]\n","import {isTextBlock, parseBlock} from '../internal-utils/parse-blocks'\nimport * as selectors from '../selectors'\nimport {getSelectionStartPoint, isSelectionCollapsed} from '../utils'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {sliceBlocks} from '../utils/util.slice-blocks'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractSplitBehaviors = [\n  defineBehavior({\n    on: 'split',\n    guard: ({snapshot}) => {\n      if (!snapshot.context.selection) {\n        return false\n      }\n\n      const selectionStartPoint = getSelectionStartPoint(\n        snapshot.context.selection,\n      )\n      const selectionEndPoint = getSelectionEndPoint(snapshot.context.selection)\n\n      const focusTextBlock = selectors.getFocusTextBlock({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: {\n            anchor: selectionStartPoint,\n            focus: selectionEndPoint,\n          },\n        },\n      })\n\n      if (focusTextBlock) {\n        const blockEndPoint = getBlockEndPoint({\n          context: snapshot.context,\n          block: focusTextBlock,\n        })\n        const newTextBlockSelection = {\n          anchor: selectionEndPoint,\n          focus: blockEndPoint,\n        }\n        const newTextBlock = parseBlock({\n          block: sliceBlocks({\n            context: {\n              ...snapshot.context,\n              selection: newTextBlockSelection,\n            },\n            blocks: [focusTextBlock.node],\n          }).at(0),\n          context: snapshot.context,\n          options: {refreshKeys: true, validateFields: true},\n        })\n\n        if (!newTextBlock || !isTextBlock(snapshot.context, newTextBlock)) {\n          return false\n        }\n\n        return {\n          newTextBlock,\n          newTextBlockSelection,\n          selection: {\n            anchor: selectionStartPoint,\n            focus: blockEndPoint,\n          },\n        }\n      }\n\n      const focusBlockObject = selectors.getFocusBlockObject({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: {\n            anchor: selectionStartPoint,\n            focus: selectionEndPoint,\n          },\n        },\n      })\n\n      if (focusBlockObject) {\n        const newTextBlock = parseBlock({\n          block: {\n            _type: snapshot.context.schema.block.name,\n            children: [],\n          },\n          context: snapshot.context,\n          options: {refreshKeys: true, validateFields: true},\n        })\n\n        if (!newTextBlock) {\n          return false\n        }\n\n        return {\n          newTextBlock,\n          newTextBlockSelection: {\n            anchor: selectionEndPoint,\n            focus: selectionEndPoint,\n          },\n          selection: snapshot.context.selection,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      (_, {newTextBlock, selection}) =>\n        isSelectionCollapsed(selection)\n          ? [\n              raise({\n                type: 'insert.block',\n                block: newTextBlock,\n                placement: 'after',\n                select: 'start',\n              }),\n            ]\n          : [\n              raise({\n                type: 'delete',\n                at: selection,\n              }),\n              raise({\n                type: 'insert.block',\n                block: newTextBlock,\n                placement: 'after',\n                select: 'start',\n              }),\n            ],\n    ],\n  }),\n]\n","import {getSelectedTextBlocks, isActiveStyle} from '../selectors'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport const abstractStyleBehaviors = [\n  defineBehavior({\n    on: 'style.add',\n    guard: ({snapshot}) => {\n      const selectedTextBlocks = getSelectedTextBlocks(snapshot)\n\n      return {selectedTextBlocks}\n    },\n    actions: [\n      ({event}, {selectedTextBlocks}) =>\n        selectedTextBlocks.map((block) =>\n          raise({\n            type: 'block.set',\n            at: block.path,\n            props: {\n              style: event.style,\n            },\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'style.remove',\n    guard: ({snapshot}) => {\n      const selectedTextBlocks = getSelectedTextBlocks(snapshot)\n\n      return {selectedTextBlocks}\n    },\n    actions: [\n      (_, {selectedTextBlocks}) =>\n        selectedTextBlocks.map((block) =>\n          raise({\n            type: 'block.unset',\n            at: block.path,\n            props: ['style'],\n          }),\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'style.toggle',\n    guard: ({snapshot, event}) => isActiveStyle(event.style)(snapshot),\n    actions: [({event}) => [raise({type: 'style.remove', style: event.style})]],\n  }),\n  defineBehavior({\n    on: 'style.toggle',\n    guard: ({snapshot, event}) => !isActiveStyle(event.style)(snapshot),\n    actions: [({event}) => [raise({type: 'style.add', style: event.style})]],\n  }),\n]\n","import type {ConverterEvent} from '../converters/converter.types'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport * as selectors from '../selectors'\nimport type {PickFromUnion} from '../type-utils'\nimport {getTextBlockText} from '../utils'\nimport {abstractAnnotationBehaviors} from './behavior.abstract.annotation'\nimport {abstractDecoratorBehaviors} from './behavior.abstract.decorator'\nimport {abstractDeleteBehaviors} from './behavior.abstract.delete'\nimport {abstractInsertBehaviors} from './behavior.abstract.insert'\nimport {abstractKeyboardBehaviors} from './behavior.abstract.keyboard'\nimport {abstractListItemBehaviors} from './behavior.abstract.list-item'\nimport {abstractMoveBehaviors} from './behavior.abstract.move'\nimport {abstractSelectBehaviors} from './behavior.abstract.select'\nimport {abstractSplitBehaviors} from './behavior.abstract.split'\nimport {abstractStyleBehaviors} from './behavior.abstract.style'\nimport {raise} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nconst raiseDeserializationSuccessOrFailure = defineBehavior({\n  on: 'deserialize',\n  guard: ({snapshot, event}) => {\n    let success:\n      | PickFromUnion<ConverterEvent, 'type', 'deserialization.success'>\n      | undefined\n    const failures: Array<\n      PickFromUnion<ConverterEvent, 'type', 'deserialization.failure'>\n    > = []\n\n    for (const converter of snapshot.context.converters) {\n      const data = event.originEvent.originEvent.dataTransfer.getData(\n        converter.mimeType,\n      )\n\n      if (!data) {\n        continue\n      }\n\n      const deserializeEvent = converter.deserialize({\n        snapshot,\n        event: {type: 'deserialize', data},\n      })\n\n      if (deserializeEvent.type === 'deserialization.success') {\n        success = deserializeEvent\n        break\n      } else {\n        failures.push(deserializeEvent)\n      }\n    }\n\n    if (!success) {\n      return {\n        type: 'deserialization.failure',\n        mimeType: '*/*',\n        reason: failures.map((failure) => failure.reason).join(', '),\n      } as const\n    }\n\n    return success\n  },\n  actions: [\n    ({event}, deserializeEvent) => [\n      raise({\n        ...deserializeEvent,\n        originEvent: event.originEvent,\n      }),\n    ],\n  ],\n})\n\nconst raiseSerializationSuccessOrFailure = defineBehavior({\n  on: 'serialize',\n  guard: ({snapshot, event}) => {\n    if (snapshot.context.converters.length === 0) {\n      return false\n    }\n\n    const serializeEvents = snapshot.context.converters.map((converter) =>\n      converter.serialize({\n        snapshot,\n        event: {\n          ...event,\n          originEvent: event.originEvent.type,\n        },\n      }),\n    )\n\n    if (serializeEvents.length === 0) {\n      return false\n    }\n\n    return serializeEvents\n  },\n  actions: [\n    ({event}, serializeEvents) =>\n      serializeEvents.map((serializeEvent) => {\n        return raise({\n          ...serializeEvent,\n          originEvent: event.originEvent,\n        })\n      }),\n  ],\n})\n\nexport const abstractBehaviors = [\n  defineBehavior({\n    on: 'clipboard.copy',\n    guard: ({snapshot}) => {\n      const focusSpan = selectors.getFocusSpan(snapshot)\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      return focusSpan && selectionCollapsed\n    },\n    actions: [],\n  }),\n  defineBehavior({\n    on: 'clipboard.copy',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'serialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'clipboard.cut',\n    guard: ({snapshot}) => {\n      const focusSpan = selectors.getFocusSpan(snapshot)\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      return focusSpan && selectionCollapsed\n    },\n    actions: [],\n  }),\n  defineBehavior({\n    on: 'clipboard.cut',\n    guard: ({snapshot}) => {\n      return snapshot.context.selection\n        ? {\n            selection: snapshot.context.selection,\n          }\n        : false\n    },\n    actions: [\n      ({event}, {selection}) => [\n        raise({\n          type: 'serialize',\n          originEvent: event,\n        }),\n        raise({\n          type: 'delete',\n          at: selection,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'drag.dragstart',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'serialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'serialization.success',\n    actions: [\n      ({event}) => [\n        {\n          type: 'effect',\n          effect: () => {\n            event.originEvent.originEvent.dataTransfer.setData(\n              event.mimeType,\n              event.data,\n            )\n          },\n        },\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'serialization.failure',\n    actions: [\n      ({event}) => [\n        {\n          type: 'effect',\n          effect: () => {\n            console.warn(\n              `Serialization of ${event.mimeType} failed with reason \"${event.reason}\"`,\n            )\n          },\n        },\n      ],\n    ],\n  }),\n\n  /**\n   * If we are pasting text/plain into a text block then we can probably\n   * assume that the intended behavior is that the pasted text inherits\n   * formatting from the text it's pasted into.\n   */\n  defineBehavior({\n    on: 'deserialization.success',\n    guard: ({snapshot, event}) => {\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n\n      if (\n        focusTextBlock &&\n        event.mimeType === 'text/plain' &&\n        event.originEvent.type === 'clipboard.paste'\n      ) {\n        const activeDecorators = snapshot.beta.activeDecorators\n        const activeAnnotations = selectors.getActiveAnnotations(snapshot)\n\n        return {\n          activeAnnotations,\n          activeDecorators,\n          textRuns: event.data.flatMap((block) =>\n            isTextBlock(snapshot.context, block)\n              ? [getTextBlockText(block)]\n              : [],\n          ),\n        }\n      }\n\n      return false\n    },\n    actions: [\n      (_, {activeAnnotations, activeDecorators, textRuns}) =>\n        textRuns.flatMap((textRun, index) =>\n          index !== textRuns.length - 1\n            ? [\n                raise({\n                  type: 'insert.span',\n                  text: textRun,\n                  decorators: activeDecorators,\n                  annotations: activeAnnotations.map(\n                    ({_key, _type, ...value}) => ({\n                      name: _type,\n                      value,\n                    }),\n                  ),\n                }),\n                raise({type: 'insert.break'}),\n              ]\n            : [\n                raise({\n                  type: 'insert.span',\n                  text: textRun,\n                  decorators: activeDecorators,\n                  annotations: activeAnnotations.map(\n                    ({_key, _type, ...value}) => ({\n                      name: _type,\n                      value,\n                    }),\n                  ),\n                }),\n              ],\n        ),\n    ],\n  }),\n  defineBehavior({\n    on: 'deserialization.success',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'insert.blocks',\n          blocks: event.data,\n          placement: 'auto',\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'deserialization.failure',\n    actions: [\n      ({event}) => [\n        {\n          type: 'effect',\n          effect: () => {\n            console.warn(\n              `Deserialization of ${event.mimeType} failed with reason \"${event.reason}\"`,\n            )\n          },\n        },\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'clipboard.paste',\n    guard: ({snapshot}) => {\n      return snapshot.context.selection &&\n        selectors.isSelectionExpanded(snapshot)\n        ? {selection: snapshot.context.selection}\n        : false\n    },\n    actions: [\n      ({event}, {selection}) => [\n        raise({\n          type: 'delete',\n          at: selection,\n        }),\n        raise({\n          type: 'deserialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'clipboard.paste',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'deserialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  defineBehavior({\n    on: 'input.*',\n    actions: [\n      ({event}) => [\n        raise({\n          type: 'deserialize',\n          originEvent: event,\n        }),\n      ],\n    ],\n  }),\n  ...abstractAnnotationBehaviors,\n  ...abstractDecoratorBehaviors,\n  ...abstractDeleteBehaviors,\n  ...abstractInsertBehaviors,\n  ...abstractKeyboardBehaviors,\n  ...abstractListItemBehaviors,\n  ...abstractMoveBehaviors,\n  ...abstractStyleBehaviors,\n  ...abstractSelectBehaviors,\n  ...abstractSplitBehaviors,\n  raiseDeserializationSuccessOrFailure,\n  raiseSerializationSuccessOrFailure,\n]\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EventPosition} from '../internal-utils/event-position'\nimport type {MIMEType} from '../internal-utils/mime-type'\nimport type {OmitFromUnion, PickFromUnion, StrictExtract} from '../type-utils'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {BlockWithOptionalKey} from '../types/block-with-optional-key'\nimport type {EditorSelection} from '../types/editor'\n\n/**\n * @beta\n */\nexport type BehaviorEvent =\n  | SyntheticBehaviorEvent\n  | NativeBehaviorEvent\n  | CustomBehaviorEvent\n\nexport type BehaviorEventTypeNamespace =\n  | SyntheticBehaviorEventNamespace\n  | NativeBehaviorEventNamespace\n  | CustomBehaviorEventNamespace\n\ntype NamespacedBehaviorEventType<\n  TNamespace extends BehaviorEventTypeNamespace | '',\n> = TNamespace extends ''\n  ? BehaviorEvent['type']\n  : Extract<BehaviorEvent['type'], TNamespace | `${TNamespace}.${string}`>\n\n/**************************************\n * External events\n **************************************/\n\ntype ExternalBehaviorEventNamespace = 'blur' | 'focus' | 'insert'\n\ntype ExternalBehaviorEventType<\n  TNamespace extends ExternalBehaviorEventNamespace,\n  TType extends string = '',\n> = TType extends '' ? `${TNamespace}` : `${TNamespace}.${TType}`\n\nexport type ExternalBehaviorEvent =\n  | {\n      type: ExternalBehaviorEventType<'blur'>\n    }\n  | {\n      type: ExternalBehaviorEventType<'focus'>\n    }\n  | {\n      type: ExternalBehaviorEventType<'insert', 'block object'>\n      placement: InsertPlacement\n      blockObject: {\n        name: string\n        value?: {[prop: string]: unknown}\n      }\n    }\n  | SyntheticBehaviorEvent\n  | CustomBehaviorEvent\n\n/**************************************\n * Synthetic events\n **************************************/\n\nconst syntheticBehaviorEventTypes = [\n  'annotation.add',\n  'annotation.remove',\n  'block.set',\n  'block.unset',\n  'decorator.add',\n  'decorator.remove',\n  'delete',\n  'history.redo',\n  'history.undo',\n  'insert.inline object',\n  'insert.block',\n  'insert.span',\n  'insert.text',\n  'move.backward',\n  'move.block',\n  'move.forward',\n  'select',\n] as const\n\ntype SyntheticBehaviorEventType =\n  | (typeof syntheticBehaviorEventTypes)[number]\n  | (typeof abstractBehaviorEventTypes)[number]\n\ntype SyntheticBehaviorEventNamespace =\n  ExtractNamespace<SyntheticBehaviorEventType>\n\n/**\n * @beta\n */\nexport type SyntheticBehaviorEvent =\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'annotation.add'>\n      annotation: {\n        name: string\n        value: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'annotation.remove'>\n      annotation: {\n        name: string\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'block.set'>\n      at: [KeyedSegment]\n      props: Record<string, unknown>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'block.unset'>\n      at: [KeyedSegment]\n      props: Array<string>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'decorator.add'>\n      decorator: string\n      at?: {\n        anchor: BlockOffset\n        focus: BlockOffset\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'decorator.remove'>\n      decorator: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'delete'>\n      at: NonNullable<EditorSelection>\n      /**\n       * Defaults to forward deletion.\n       */\n      direction?: 'backward' | 'forward'\n      /**\n       * Defaults to character deletion.\n       */\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'history.redo'>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'history.undo'>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.inline object'>\n      inlineObject: {\n        name: string\n        value?: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.block'>\n      block: BlockWithOptionalKey\n      placement: InsertPlacement\n      select?: 'start' | 'end' | 'none'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.span'>\n      text: string\n      annotations?: Array<{\n        name: string\n        value: {[prop: string]: unknown}\n      }>\n      decorators?: Array<string>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.text'>\n      text: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'move.backward'>\n      distance: number\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'move.block'>\n      at: [KeyedSegment]\n      to: [KeyedSegment]\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'move.forward'>\n      distance: number\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'select'>\n      at: EditorSelection\n    }\n  | AbstractBehaviorEvent\n\nexport type InsertPlacement = 'auto' | 'after' | 'before'\n\nexport function isSyntheticBehaviorEvent(\n  event: BehaviorEvent,\n): event is OmitFromUnion<\n  SyntheticBehaviorEvent,\n  'type',\n  AbstractBehaviorEventType\n> {\n  return (\n    !isCustomBehaviorEvent(event) &&\n    !isNativeBehaviorEvent(event) &&\n    !isAbstractBehaviorEvent(event)\n  )\n}\n\n/**************************************\n * Abstract events\n **************************************/\n\nconst abstractBehaviorEventTypes = [\n  'annotation.toggle',\n  'decorator.toggle',\n  'delete.backward',\n  'delete.block',\n  'delete.forward',\n  'delete.text',\n  'deserialize',\n  'deserialization.success',\n  'deserialization.failure',\n  'insert.blocks',\n  'insert.break',\n  'insert.soft break',\n  'list item.add',\n  'list item.remove',\n  'list item.toggle',\n  'move.block down',\n  'move.block up',\n  'select.previous block',\n  'select.next block',\n  'serialize',\n  'serialization.success',\n  'serialization.failure',\n  'split',\n  'style.add',\n  'style.remove',\n  'style.toggle',\n] as const\n\nexport type AbstractBehaviorEventType =\n  (typeof abstractBehaviorEventTypes)[number]\n\ntype AbstractBehaviorEvent =\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'annotation.toggle'>\n      annotation: {\n        name: string\n        value: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'decorator.toggle'>\n      decorator: string\n      at?: {anchor: BlockOffset; focus: BlockOffset}\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'delete.backward'>\n      unit: 'character' | 'word' | 'line' | 'block'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'delete.block'>\n      at: [KeyedSegment]\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'delete.forward'>\n      unit: 'character' | 'word' | 'line' | 'block'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'delete.text'>\n      at: {\n        anchor: BlockOffset\n        focus: BlockOffset\n      }\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'deserialize'>\n      originEvent:\n        | PickFromUnion<\n            NativeBehaviorEvent,\n            'type',\n            'drag.drop' | 'clipboard.paste'\n          >\n        | InputBehaviorEvent\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'serialize'>\n      originEvent: PickFromUnion<\n        NativeBehaviorEvent,\n        'type',\n        'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'\n      >\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'deserialization.success'>\n      mimeType: MIMEType\n      data: Array<PortableTextBlock>\n      originEvent:\n        | PickFromUnion<\n            NativeBehaviorEvent,\n            'type',\n            'drag.drop' | 'clipboard.paste'\n          >\n        | InputBehaviorEvent\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'deserialization.failure'>\n      mimeType: MIMEType\n      reason: string\n      originEvent:\n        | PickFromUnion<\n            NativeBehaviorEvent,\n            'type',\n            'drag.drop' | 'clipboard.paste'\n          >\n        | InputBehaviorEvent\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'serialization.success'>\n      mimeType: MIMEType\n      data: string\n      originEvent: PickFromUnion<\n        NativeBehaviorEvent,\n        'type',\n        'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'\n      >\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'serialization.failure'>\n      mimeType: MIMEType\n      reason: string\n      originEvent: PickFromUnion<\n        NativeBehaviorEvent,\n        'type',\n        'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'\n      >\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.blocks'>\n      blocks: Array<BlockWithOptionalKey>\n      placement: InsertPlacement\n      select?: 'start' | 'end' | 'none'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.break'>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'insert.soft break'>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'list item.add'>\n      listItem: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'list item.remove'>\n      listItem: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'list item.toggle'>\n      listItem: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'move.block down'>\n      at: [KeyedSegment]\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'move.block up'>\n      at: [KeyedSegment]\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'select.previous block'>\n      select?: 'start' | 'end'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'select.next block'>\n      select?: 'start' | 'end'\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'split'>\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'style.add'>\n      style: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'style.remove'>\n      style: string\n    }\n  | {\n      type: StrictExtract<SyntheticBehaviorEventType, 'style.toggle'>\n      style: string\n    }\n\nexport function isAbstractBehaviorEvent(\n  event: BehaviorEvent,\n): event is AbstractBehaviorEvent {\n  return (abstractBehaviorEventTypes as readonly string[]).includes(event.type)\n}\n\n/**************************************\n * Native events\n **************************************/\n\nconst nativeBehaviorEventTypes = [\n  'clipboard.copy',\n  'clipboard.cut',\n  'clipboard.paste',\n  'drag.dragstart',\n  'drag.drag',\n  'drag.dragend',\n  'drag.dragenter',\n  'drag.dragover',\n  'drag.dragleave',\n  'drag.drop',\n  'input.*',\n  'keyboard.keydown',\n  'keyboard.keyup',\n  'mouse.click',\n] as const\n\ntype NativeBehaviorEventType = (typeof nativeBehaviorEventTypes)[number]\n\ntype NativeBehaviorEventNamespace = ExtractNamespace<NativeBehaviorEventType>\n\nexport function isNativeBehaviorEvent(\n  event: BehaviorEvent,\n): event is NativeBehaviorEvent {\n  return (nativeBehaviorEventTypes as readonly string[]).includes(event.type)\n}\n\n/**\n * @beta\n */\nexport type NativeBehaviorEvent =\n  | ClipboardBehaviorEvent\n  | DragBehaviorEvent\n  | InputBehaviorEvent\n  | KeyboardBehaviorEvent\n  | MouseBehaviorEvent\n\ntype ClipboardBehaviorEvent =\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'clipboard.copy'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      position: Pick<EventPosition, 'selection'>\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'clipboard.cut'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      position: Pick<EventPosition, 'selection'>\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'clipboard.paste'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      position: Pick<EventPosition, 'selection'>\n    }\n\ntype DragBehaviorEvent =\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.dragstart'>\n      originEvent: {\n        clientX: number\n        clientY: number\n        dataTransfer: DataTransfer\n      }\n      position: Pick<EventPosition, 'selection'>\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.drag'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.dragend'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.dragenter'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      position: EventPosition\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.dragover'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      dragOrigin?: Pick<EventPosition, 'selection'>\n      position: EventPosition\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.drop'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n      dragOrigin?: Pick<EventPosition, 'selection'>\n      position: EventPosition\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'drag.dragleave'>\n      originEvent: {\n        dataTransfer: DataTransfer\n      }\n    }\n\n/**\n * Used to represent native InputEvents that hold a DataTransfer object.\n *\n * These can either be one of:\n *\n * - insertFromPaste\n * - insertFromPasteAsQuotation\n * - insertFromDrop\n * - insertReplacementText\n * - insertFromYank\n */\nexport type InputBehaviorEvent = {\n  type: StrictExtract<NativeBehaviorEventType, 'input.*'>\n  originEvent: {\n    dataTransfer: DataTransfer\n  }\n}\n\nexport type KeyboardBehaviorEvent =\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'keyboard.keydown'>\n      originEvent: Pick<\n        KeyboardEvent,\n        'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n      >\n    }\n  | {\n      type: StrictExtract<NativeBehaviorEventType, 'keyboard.keyup'>\n      originEvent: Pick<\n        KeyboardEvent,\n        'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n      >\n    }\n\nexport type MouseBehaviorEvent = {\n  type: StrictExtract<NativeBehaviorEventType, 'mouse.click'>\n  position: EventPosition\n}\n\n/**************************************\n * Custom events\n **************************************/\n\ntype CustomBehaviorEventNamespace = 'custom'\n\ntype CustomBehaviorEventType<\n  TNamespace extends CustomBehaviorEventNamespace,\n  TType extends string = '',\n> = TType extends '' ? `${TNamespace}` : `${TNamespace}.${TType}`\n\n/**\n * @beta\n */\nexport type CustomBehaviorEvent<\n  TPayload extends Record<string, unknown> = Record<string, unknown>,\n  TType extends string = string,\n  TInternalType extends CustomBehaviorEventType<\n    'custom',\n    TType\n  > = CustomBehaviorEventType<'custom', TType>,\n> = {\n  type: TInternalType\n} & TPayload\n\nexport function isCustomBehaviorEvent(\n  event: BehaviorEvent,\n): event is CustomBehaviorEvent {\n  return event.type.startsWith('custom.')\n}\n\n/**************************************\n * Resolve behavior event\n **************************************/\n\nexport type ResolveBehaviorEvent<\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'],\n  TPayload extends Record<string, unknown> = Record<string, unknown>,\n> = TBehaviorEventType extends '*'\n  ? BehaviorEvent\n  : TBehaviorEventType extends `${infer TNamespace}.*`\n    ? TNamespace extends BehaviorEventTypeNamespace\n      ? PickFromUnion<\n          BehaviorEvent,\n          'type',\n          NamespacedBehaviorEventType<TNamespace>\n        >\n      : never\n    : TBehaviorEventType extends `custom.${infer TType}`\n      ? CustomBehaviorEvent<TPayload, TType>\n      : TBehaviorEventType extends BehaviorEvent['type']\n        ? PickFromUnion<BehaviorEvent, 'type', TBehaviorEventType>\n        : never\n\ntype ExtractNamespace<TType extends string> =\n  TType extends `${infer Namespace}.${string}` ? Namespace : TType\n","import type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {withApplyingBehaviorOperations} from '../editor/with-applying-behavior-operations'\nimport {withUndoStep} from '../editor/with-undo-step'\nimport {debugWithName} from '../internal-utils/debug'\nimport {createEditorDom} from '../internal-utils/selection-elements'\nimport {performOperation} from '../operations/behavior.operations'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {abstractBehaviors} from './behavior.abstract'\nimport type {BehaviorAction} from './behavior.types.action'\nimport type {Behavior} from './behavior.types.behavior'\nimport {\n  isAbstractBehaviorEvent,\n  isCustomBehaviorEvent,\n  isNativeBehaviorEvent,\n  isSyntheticBehaviorEvent,\n  type BehaviorEvent,\n} from './behavior.types.event'\n\nconst debug = debugWithName('behaviors:event')\n\nfunction eventCategory(event: BehaviorEvent) {\n  return isNativeBehaviorEvent(event)\n    ? 'native'\n    : isAbstractBehaviorEvent(event)\n      ? 'synthetic'\n      : isCustomBehaviorEvent(event)\n        ? 'custom'\n        : 'synthetic'\n}\n\nexport function performEvent({\n  mode,\n  behaviors,\n  remainingEventBehaviors,\n  event,\n  editor,\n  keyGenerator,\n  schema,\n  getSnapshot,\n  nativeEvent,\n  sendBack,\n}: {\n  mode: 'raise' | 'execute' | 'forward'\n  behaviors: Array<Behavior>\n  remainingEventBehaviors: Array<Behavior>\n  event: BehaviorEvent\n  editor: PortableTextSlateEditor\n  keyGenerator: () => string\n  schema: EditorSchema\n  getSnapshot: () => EditorSnapshot\n  nativeEvent:\n    | {\n        preventDefault: () => void\n      }\n    | undefined\n  sendBack: (event: {type: 'set drag ghost'; ghost: HTMLElement}) => void\n}) {\n  debug(`(${mode}:${eventCategory(event)})`, JSON.stringify(event, null, 2))\n\n  const eventBehaviors = [\n    ...remainingEventBehaviors,\n    ...abstractBehaviors,\n  ].filter((behavior) => {\n    // Catches all events\n    if (behavior.on === '*') {\n      return true\n    }\n\n    const [listenedNamespace] =\n      behavior.on.includes('*') && behavior.on.includes('.')\n        ? behavior.on.split('.')\n        : [undefined]\n    const [eventNamespace] = event.type.includes('.')\n      ? event.type.split('.')\n      : [undefined]\n\n    // Handles scenarios like a Behavior listening for `select.*` and the event\n    // `select.block` is fired.\n    if (\n      listenedNamespace !== undefined &&\n      eventNamespace !== undefined &&\n      listenedNamespace === eventNamespace\n    ) {\n      return true\n    }\n\n    // Handles scenarios like a Behavior listening for `select.*` and the event\n    // `select` is fired.\n    if (\n      listenedNamespace !== undefined &&\n      eventNamespace === undefined &&\n      listenedNamespace === event.type\n    ) {\n      return true\n    }\n\n    return behavior.on === event.type\n  })\n\n  if (eventBehaviors.length === 0 && isSyntheticBehaviorEvent(event)) {\n    nativeEvent?.preventDefault()\n\n    withApplyingBehaviorOperations(editor, () => {\n      debug(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2))\n\n      performOperation({\n        context: {\n          keyGenerator,\n          schema,\n        },\n        operation: {\n          ...event,\n          editor,\n        },\n      })\n    })\n\n    editor.onChange()\n\n    return\n  }\n\n  const guardSnapshot = getSnapshot()\n\n  let nativeEventPrevented = false\n  let defaultBehaviorOverwritten = false\n  let eventBehaviorIndex = -1\n\n  for (const eventBehavior of eventBehaviors) {\n    eventBehaviorIndex++\n\n    let shouldRun = false\n\n    try {\n      shouldRun =\n        eventBehavior.guard === undefined ||\n        eventBehavior.guard({\n          snapshot: guardSnapshot,\n          event,\n          dom: createEditorDom(sendBack, editor),\n        })\n    } catch (error) {\n      console.error(\n        new Error(\n          `Evaluating guard for \"${event.type}\" failed due to: ${error.message}`,\n        ),\n      )\n    }\n\n    if (!shouldRun) {\n      continue\n    }\n\n    // This Behavior now \"owns\" the event and we can consider the default\n    // action prevented\n    defaultBehaviorOverwritten = true\n\n    for (const actionSet of eventBehavior.actions) {\n      const actionsSnapshot = getSnapshot()\n\n      let actions: Array<BehaviorAction> = []\n\n      try {\n        actions = actionSet(\n          {\n            snapshot: actionsSnapshot,\n            event,\n            dom: createEditorDom(sendBack, editor),\n          },\n          shouldRun,\n        )\n      } catch (error) {\n        console.error(\n          new Error(\n            `Evaluating actions for \"${event.type}\" failed due to: ${error.message}`,\n          ),\n        )\n      }\n\n      if (actions.length === 0) {\n        continue\n      }\n\n      if (actions.some((action) => action.type === 'execute')) {\n        // Since at least one action is about to `execute` changes in the editor,\n        // we set up a new undo step.\n        // All actions performed recursively from now will be squashed into this\n        // undo step\n        withUndoStep(editor, () => {\n          for (const action of actions) {\n            if (action.type === 'effect') {\n              nativeEventPrevented = true\n\n              try {\n                action.effect()\n              } catch (error) {\n                console.error(\n                  new Error(\n                    `Executing effect as a result of \"${event.type}\" failed due to: ${error.message}`,\n                  ),\n                )\n              }\n\n              continue\n            }\n\n            if (action.type === 'forward') {\n              const remainingEventBehaviors = eventBehaviors.slice(\n                eventBehaviorIndex + 1,\n              )\n\n              performEvent({\n                mode: 'forward',\n                behaviors,\n                remainingEventBehaviors: remainingEventBehaviors,\n                event: action.event,\n                editor,\n                keyGenerator,\n                schema,\n                getSnapshot,\n                nativeEvent,\n                sendBack,\n              })\n\n              continue\n            }\n\n            if (action.type === 'raise') {\n              nativeEventPrevented = true\n\n              performEvent({\n                mode: 'raise',\n                behaviors,\n                remainingEventBehaviors: behaviors,\n                event: action.event,\n                editor,\n                keyGenerator,\n                schema,\n                getSnapshot,\n                nativeEvent,\n                sendBack,\n              })\n\n              continue\n            }\n\n            nativeEventPrevented = true\n\n            performEvent({\n              mode: 'execute',\n              behaviors,\n              remainingEventBehaviors: isAbstractBehaviorEvent(action.event)\n                ? behaviors\n                : [],\n              event: action.event,\n              editor,\n              keyGenerator,\n              schema,\n              getSnapshot,\n              nativeEvent: undefined,\n              sendBack,\n            })\n          }\n        })\n\n        continue\n      }\n\n      for (const action of actions) {\n        if (action.type === 'effect') {\n          nativeEventPrevented = true\n\n          try {\n            action.effect()\n          } catch (error) {\n            console.error(\n              new Error(\n                `Executing effect as a result of \"${event.type}\" failed due to: ${error.message}`,\n              ),\n            )\n          }\n\n          continue\n        }\n\n        if (action.type === 'forward') {\n          const remainingEventBehaviors = eventBehaviors.slice(\n            eventBehaviorIndex + 1,\n          )\n\n          performEvent({\n            mode: 'forward',\n            behaviors,\n            remainingEventBehaviors: remainingEventBehaviors,\n            event: action.event,\n            editor,\n            keyGenerator,\n            schema,\n            getSnapshot,\n            nativeEvent,\n            sendBack,\n          })\n\n          continue\n        }\n\n        if (action.type === 'raise') {\n          nativeEventPrevented = true\n\n          performEvent({\n            mode: 'raise',\n            behaviors,\n            remainingEventBehaviors: behaviors,\n            event: action.event,\n            editor,\n            keyGenerator,\n            schema,\n            getSnapshot,\n            nativeEvent,\n            sendBack,\n          })\n\n          continue\n        }\n\n        if (action.type === 'execute') {\n          console.error('Unexpected action type: `execute`')\n        }\n      }\n    }\n\n    break\n  }\n\n  if (!defaultBehaviorOverwritten && isSyntheticBehaviorEvent(event)) {\n    nativeEvent?.preventDefault()\n\n    withApplyingBehaviorOperations(editor, () => {\n      debug(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2))\n\n      performOperation({\n        context: {keyGenerator, schema},\n        operation: {\n          ...event,\n          editor,\n        },\n      })\n    })\n\n    editor.onChange()\n  } else if (nativeEventPrevented) {\n    nativeEvent?.preventDefault()\n  }\n}\n","import type {EditorPriority} from './priority.types'\n\nexport function sortByPriority<\n  T extends {\n    priority?: EditorPriority\n  },\n>(items: Array<T>): Array<T> {\n  if (items.length === 0) {\n    return []\n  }\n\n  // Separate items with and without priority\n  const itemsWithPriority = items.filter(\n    (item): item is T & {priority: EditorPriority} =>\n      item.priority !== undefined,\n  )\n  const itemsWithoutPriority = items.filter(\n    (item) => item.priority === undefined,\n  )\n\n  if (itemsWithPriority.length === 0) {\n    return items\n  }\n\n  // Create a map of items by their priority ID\n  const itemsByPriorityId = new Map(\n    itemsWithPriority.map((item) => [item.priority.id, item]),\n  )\n\n  // Build the dependency graph\n  const graph = new Map<string, Set<string>>()\n  const inDegree = new Map<string, number>()\n\n  // Helper function to ensure a node exists in the graph\n  function ensureNode(id: string) {\n    if (!graph.has(id)) {\n      graph.set(id, new Set())\n      inDegree.set(id, 0)\n    }\n  }\n\n  // Initialize graph and in-degree for all items\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id\n    ensureNode(id)\n  }\n\n  // Helper function to add an edge to the graph\n  function addEdge(fromId: string, toId: string) {\n    if (!graph.has(fromId) || !graph.has(toId)) return\n    graph.get(fromId)?.add(toId)\n    inDegree.set(toId, (inDegree.get(toId) ?? 0) + 1)\n  }\n\n  // Add edges based on references\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id\n    const visited = new Set<string>()\n    let ref = item.priority.reference\n\n    while (ref) {\n      const refId = ref.priority.id\n      ensureNode(refId)\n\n      // Check for cyclic reference\n      if (visited.has(refId)) {\n        throw new Error('Circular dependency detected in priorities')\n      }\n      visited.add(refId)\n\n      if (ref.importance === 'higher') {\n        // Reference must come before current item\n        addEdge(id, refId)\n      } else {\n        // Current item must come before reference\n        addEdge(refId, id)\n      }\n\n      ref = ref.priority.reference\n    }\n  }\n\n  const queue: string[] = []\n\n  // Find all nodes with no incoming edges\n  for (const [id, degree] of inDegree) {\n    if (degree === 0) {\n      queue.push(id)\n    }\n  }\n\n  const result: T[] = []\n\n  // Perform topological sort\n  while (queue.length > 0) {\n    const currentId = queue.shift()!\n    const currentItem = itemsByPriorityId.get(currentId)\n    if (currentItem) {\n      result.push(currentItem)\n    }\n\n    // Decrease in-degree of neighbors\n    for (const neighborId of graph.get(currentId) ?? []) {\n      const newDegree = (inDegree.get(neighborId) ?? 0) - 1\n      inDegree.set(neighborId, newDegree)\n      if (newDegree === 0) {\n        queue.push(neighborId)\n      }\n    }\n  }\n\n  // Add any remaining items that weren't processed\n  for (const item of itemsWithPriority) {\n    if (!result.includes(item)) {\n      result.push(item)\n    }\n  }\n\n  // Append items without priority at the end in their original order\n  return [...result, ...itemsWithoutPriority]\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {Converter} from '../converters/converter.types'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport type {EditorSelection, PortableTextSlateEditor} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\nimport {getActiveAnnotations} from './get-active-annotations'\nimport {getActiveDecorators} from './get-active-decorators'\n\n/**\n * @public\n */\nexport type EditorContext = {\n  converters: Array<Converter>\n  keyGenerator: () => string\n  readOnly: boolean\n  schema: EditorSchema\n  selection: EditorSelection\n  value: Array<PortableTextBlock>\n}\n\n/**\n * @public\n */\nexport type EditorSnapshot = {\n  context: EditorContext\n  /**\n   * @beta\n   * Do not rely on this externally\n   */\n  beta: {\n    activeAnnotations: Array<string>\n    activeDecorators: Array<string>\n  }\n}\n\nexport function createEditorSnapshot({\n  converters,\n  editor,\n  keyGenerator,\n  readOnly,\n  schema,\n}: {\n  converters: Array<Converter>\n  editor: PortableTextSlateEditor\n  keyGenerator: () => string\n  readOnly: boolean\n  schema: EditorSchema\n}) {\n  const selection = editor.selection\n    ? slateRangeToSelection({\n        schema,\n        editor,\n        range: editor.selection,\n      })\n    : null\n\n  const context = {\n    converters,\n    keyGenerator,\n    readOnly,\n    schema,\n    selection,\n    value: editor.value,\n  } satisfies EditorContext\n\n  return {\n    context,\n    beta: {\n      activeAnnotations: getActiveAnnotations({\n        markState: editor.markState,\n        schema,\n      }),\n      activeDecorators: getActiveDecorators({\n        decoratorState: editor.decoratorState,\n        markState: editor.markState,\n        schema,\n      }),\n    },\n  } satisfies EditorSnapshot\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {Transforms} from 'slate'\nimport {ReactEditor} from 'slate-react'\nimport {\n  assertEvent,\n  assign,\n  emit,\n  enqueueActions,\n  setup,\n  type ActorRefFrom,\n} from 'xstate'\nimport type {BehaviorConfig} from '../behaviors/behavior.config'\nimport {coreBehaviorsConfig} from '../behaviors/behavior.core'\nimport {performEvent} from '../behaviors/behavior.perform-event'\nimport type {BehaviorEvent} from '../behaviors/behavior.types.event'\nimport type {Converter} from '../converters/converter.types'\nimport {debugWithName} from '../internal-utils/debug'\nimport type {EventPosition} from '../internal-utils/event-position'\nimport {sortByPriority} from '../priority/priority.sort'\nimport type {NamespaceEvent, OmitFromUnion} from '../type-utils'\nimport type {\n  EditorSelection,\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\nimport {createEditorSnapshot} from './editor-snapshot'\nimport type {\n  EditorEmittedEvent,\n  MutationEvent,\n  PatchEvent,\n} from './relay-machine'\n\nexport * from 'xstate/guards'\n\nconst debug = debugWithName('editor machine')\n\n/**\n * @public\n */\nexport type PatchesEvent = {\n  type: 'patches'\n  patches: Array<Patch>\n  snapshot: Array<PortableTextBlock> | undefined\n}\n\n/**\n * @public\n */\nexport type ExternalEditorEvent =\n  | {\n      type: 'update readOnly'\n      readOnly: boolean\n    }\n  | {\n      type: 'update maxBlocks'\n      maxBlocks: number | undefined\n    }\n  | PatchesEvent\n\ntype InternalPatchEvent = NamespaceEvent<PatchEvent, 'internal'> & {\n  operationId?: string\n  value: Array<PortableTextBlock>\n}\n\n/**\n * @internal\n */\nexport type EditorActor = ActorRefFrom<typeof editorMachine>\n\n/**\n * @internal\n */\nexport type InternalEditorEvent =\n  | ExternalEditorEvent\n  | {\n      type: 'add behavior'\n      behaviorConfig: BehaviorConfig\n    }\n  | {\n      type: 'remove behavior'\n      behaviorConfig: BehaviorConfig\n    }\n  | {\n      type: 'blur'\n      editor: PortableTextSlateEditor\n    }\n  | {\n      type: 'focus'\n      editor: PortableTextSlateEditor\n    }\n  | {\n      type: 'normalizing'\n    }\n  | {\n      type: 'update selection'\n      selection: EditorSelection\n    }\n  | {\n      type: 'done normalizing'\n    }\n  | {\n      type: 'done syncing value'\n    }\n  | {\n      type: 'syncing value'\n    }\n  | {\n      type: 'behavior event'\n      behaviorEvent: BehaviorEvent\n      editor: PortableTextSlateEditor\n      nativeEvent?: {preventDefault: () => void}\n    }\n  | MutationEvent\n  | InternalPatchEvent\n  | {\n      type: 'set drag ghost'\n      ghost: HTMLElement\n    }\n  | {\n      type: 'dragstart'\n      ghost?: HTMLElement\n      origin: Pick<EventPosition, 'selection'>\n    }\n  | {type: 'dragend'}\n  | {type: 'drop'}\n\n/**\n * @internal\n */\nexport type InternalEditorEmittedEvent =\n  | OmitFromUnion<EditorEmittedEvent, 'type', 'patch'>\n  | InternalPatchEvent\n  | PatchesEvent\n\n/**\n * @internal\n */\nexport const editorMachine = setup({\n  types: {\n    context: {} as {\n      behaviors: Set<BehaviorConfig>\n      converters: Set<Converter>\n      getLegacySchema: () => PortableTextMemberSchemaTypes\n      keyGenerator: () => string\n      pendingEvents: Array<InternalPatchEvent | MutationEvent>\n      pendingIncomingPatchesEvents: Array<PatchesEvent>\n      schema: EditorSchema\n      initialReadOnly: boolean\n      maxBlocks: number | undefined\n      selection: EditorSelection\n      initialValue: Array<PortableTextBlock> | undefined\n      internalDrag?: {\n        origin: Pick<EventPosition, 'selection'>\n      }\n      dragGhost?: HTMLElement\n      slateEditor?: PortableTextSlateEditor\n    },\n    events: {} as InternalEditorEvent,\n    emitted: {} as InternalEditorEmittedEvent,\n    input: {} as {\n      converters?: Array<Converter>\n      getLegacySchema: () => PortableTextMemberSchemaTypes\n      keyGenerator: () => string\n      maxBlocks?: number\n      readOnly?: boolean\n      schema: EditorSchema\n      initialValue?: Array<PortableTextBlock>\n    },\n    tags: {} as 'dragging internally',\n  },\n  actions: {\n    'add behavior to context': assign({\n      behaviors: ({context, event}) => {\n        assertEvent(event, 'add behavior')\n\n        return new Set([...context.behaviors, event.behaviorConfig])\n      },\n    }),\n    'remove behavior from context': assign({\n      behaviors: ({context, event}) => {\n        assertEvent(event, 'remove behavior')\n\n        context.behaviors.delete(event.behaviorConfig)\n\n        return new Set([...context.behaviors])\n      },\n    }),\n    'emit patch event': enqueueActions(({event, enqueue}) => {\n      assertEvent(event, 'internal.patch')\n\n      enqueue.emit(event)\n    }),\n    'emit mutation event': emit(({event}) => {\n      assertEvent(event, 'mutation')\n      return event\n    }),\n    'emit read only': emit({type: 'read only'}),\n    'emit editable': emit({type: 'editable'}),\n    'defer event': assign({\n      pendingEvents: ({context, event}) => {\n        assertEvent(event, ['internal.patch', 'mutation'])\n        return [...context.pendingEvents, event]\n      },\n    }),\n    'emit pending events': enqueueActions(({context, enqueue}) => {\n      for (const event of context.pendingEvents) {\n        enqueue.emit(event)\n      }\n    }),\n    'emit ready': emit({type: 'ready'}),\n    'clear pending events': assign({\n      pendingEvents: [],\n    }),\n    'defer incoming patches': assign({\n      pendingIncomingPatchesEvents: ({context, event}) => {\n        return event.type === 'patches'\n          ? [...context.pendingIncomingPatchesEvents, event]\n          : context.pendingIncomingPatchesEvents\n      },\n    }),\n    'emit pending incoming patches': enqueueActions(({context, enqueue}) => {\n      for (const event of context.pendingIncomingPatchesEvents) {\n        enqueue.emit(event)\n      }\n    }),\n    'clear pending incoming patches': assign({\n      pendingIncomingPatchesEvents: [],\n    }),\n    'handle blur': ({event}) => {\n      assertEvent(event, 'blur')\n\n      try {\n        ReactEditor.blur(event.editor)\n      } catch (error) {\n        console.error(new Error(`Failed to blur editor: ${error.message}`))\n      }\n    },\n    'handle focus': ({context}) => {\n      if (!context.slateEditor) {\n        console.error('No Slate editor found to focus')\n        return\n      }\n\n      try {\n        const currentSelection = context.slateEditor.selection\n        ReactEditor.focus(context.slateEditor)\n        if (currentSelection) {\n          Transforms.select(context.slateEditor, currentSelection)\n        }\n      } catch (error) {\n        console.error(new Error(`Failed to focus editor: ${error.message}`))\n      }\n    },\n    'handle behavior event': ({context, event, self}) => {\n      assertEvent(event, ['behavior event'])\n\n      try {\n        const behaviors = sortByPriority([\n          ...context.behaviors.values(),\n          ...coreBehaviorsConfig,\n        ]).map((config) => config.behavior)\n\n        performEvent({\n          mode: 'raise',\n          behaviors,\n          remainingEventBehaviors: behaviors,\n          event: event.behaviorEvent,\n          editor: event.editor,\n          keyGenerator: context.keyGenerator,\n          schema: context.schema,\n          getSnapshot: () =>\n            createEditorSnapshot({\n              converters: [...context.converters],\n              editor: event.editor,\n              keyGenerator: context.keyGenerator,\n              readOnly: self.getSnapshot().matches({'edit mode': 'read only'}),\n              schema: context.schema,\n            }),\n          nativeEvent: event.nativeEvent,\n          sendBack: (event) => self.send(event),\n        })\n      } catch (error) {\n        console.error(\n          new Error(\n            `Raising \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n          ),\n        )\n      }\n    },\n  },\n  guards: {\n    'slate is busy': ({context}) => {\n      if (!context.slateEditor) {\n        return false\n      }\n\n      return context.slateEditor.operations.length > 0\n    },\n  },\n}).createMachine({\n  id: 'editor',\n  context: ({input}) => ({\n    behaviors: new Set([]),\n    converters: new Set(input.converters ?? []),\n    getLegacySchema: input.getLegacySchema,\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    pendingIncomingPatchesEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? false,\n    maxBlocks: input.maxBlocks,\n    initialValue: input.initialValue,\n  }),\n  on: {\n    'add behavior': {actions: 'add behavior to context'},\n    'remove behavior': {actions: 'remove behavior from context'},\n    'update maxBlocks': {\n      actions: assign({maxBlocks: ({event}) => event.maxBlocks}),\n    },\n    'update selection': {\n      actions: [\n        assign({selection: ({event}) => event.selection}),\n        emit(({event}) => ({...event, type: 'selection'})),\n      ],\n    },\n    'set drag ghost': {\n      actions: assign({dragGhost: ({event}) => event.ghost}),\n    },\n  },\n  type: 'parallel',\n  states: {\n    'edit mode': {\n      initial: 'read only',\n      states: {\n        'read only': {\n          initial: 'determine initial edit mode',\n          on: {\n            'behavior event': {\n              actions: 'handle behavior event',\n              guard: ({event}) =>\n                event.behaviorEvent.type === 'clipboard.copy' ||\n                event.behaviorEvent.type === 'mouse.click' ||\n                event.behaviorEvent.type === 'serialize' ||\n                event.behaviorEvent.type === 'serialization.failure' ||\n                event.behaviorEvent.type === 'serialization.success' ||\n                event.behaviorEvent.type === 'select',\n            },\n          },\n          states: {\n            'determine initial edit mode': {\n              entry: [\n                () => {\n                  debug(\n                    'entry: edit mode->read only->determine initial edit mode',\n                  )\n                },\n              ],\n              exit: [\n                () => {\n                  debug(\n                    'exit: edit mode->read only->determine initial edit mode',\n                  )\n                },\n              ],\n              on: {\n                'done syncing value': [\n                  {\n                    target: '#editor.edit mode.read only.read only',\n                    guard: ({context}) => context.initialReadOnly,\n                  },\n                  {\n                    target: '#editor.edit mode.editable',\n                  },\n                ],\n              },\n            },\n            'read only': {\n              entry: [\n                () => {\n                  debug('entry: edit mode->read only->read only')\n                },\n              ],\n              exit: [\n                () => {\n                  debug('exit: edit mode->read only->read only')\n                },\n              ],\n              on: {\n                'update readOnly': {\n                  guard: ({event}) => !event.readOnly,\n                  target: '#editor.edit mode.editable',\n                  actions: ['emit editable'],\n                },\n              },\n            },\n          },\n        },\n        'editable': {\n          on: {\n            'update readOnly': {\n              guard: ({event}) => event.readOnly,\n              target: '#editor.edit mode.read only.read only',\n              actions: ['emit read only'],\n            },\n            'behavior event': {\n              actions: 'handle behavior event',\n            },\n            'blur': {\n              actions: 'handle blur',\n            },\n            'focus': {\n              target: '.focusing',\n              actions: [assign({slateEditor: ({event}) => event.editor})],\n            },\n          },\n          initial: 'idle',\n          states: {\n            'idle': {\n              entry: [\n                () => {\n                  debug('entry: edit mode->editable->idle')\n                },\n              ],\n              exit: [\n                () => {\n                  debug('exit: edit mode->editable-idle')\n                },\n              ],\n              on: {\n                dragstart: {\n                  actions: [\n                    assign({\n                      internalDrag: ({event}) => ({\n                        origin: event.origin,\n                      }),\n                    }),\n                  ],\n                  target: 'dragging internally',\n                },\n              },\n            },\n            'focusing': {\n              initial: 'checking if busy',\n              states: {\n                'checking if busy': {\n                  entry: [\n                    () => {\n                      debug(\n                        'entry: edit mode->editable->focusing->checking if busy',\n                      )\n                    },\n                  ],\n                  exit: [\n                    () => {\n                      debug(\n                        'exit: edit mode->editable->focusing->checking if busy',\n                      )\n                    },\n                  ],\n                  always: [\n                    {\n                      guard: 'slate is busy',\n                      target: 'busy',\n                    },\n                    {\n                      target: '#editor.edit mode.editable.idle',\n                      actions: ['handle focus'],\n                    },\n                  ],\n                },\n                'busy': {\n                  entry: [\n                    () => {\n                      debug('entry: edit mode->editable->focusing-busy')\n                    },\n                  ],\n                  exit: [\n                    () => {\n                      debug('exit: edit mode->editable->focusing->busy')\n                    },\n                  ],\n                  after: {\n                    10: {\n                      target: 'checking if busy',\n                    },\n                  },\n                },\n              },\n            },\n            'dragging internally': {\n              entry: [\n                () => {\n                  debug('entry: edit mode->editable->dragging internally')\n                },\n              ],\n              exit: [\n                () => {\n                  debug('exit: edit mode->editable->dragging internally')\n                },\n                ({context}) => {\n                  if (context.dragGhost) {\n                    try {\n                      context.dragGhost.parentNode?.removeChild(\n                        context.dragGhost,\n                      )\n                    } catch (error) {\n                      console.error(\n                        new Error(\n                          `Removing the drag ghost failed due to: ${error.message}`,\n                        ),\n                      )\n                    }\n                  }\n                },\n                assign({dragGhost: undefined}),\n                assign({internalDrag: undefined}),\n              ],\n              tags: ['dragging internally'],\n              on: {\n                dragend: {target: 'idle'},\n                drop: {target: 'idle'},\n              },\n            },\n          },\n        },\n      },\n    },\n    'setup': {\n      initial: 'setting up',\n      states: {\n        'setting up': {\n          entry: [\n            () => {\n              debug('entry: setup->setting up')\n            },\n          ],\n          exit: [\n            () => {\n              debug('exit: setup->setting up')\n            },\n            'emit ready',\n            'emit pending incoming patches',\n            'clear pending incoming patches',\n          ],\n          on: {\n            'internal.patch': {\n              actions: 'defer event',\n            },\n            'mutation': {\n              actions: 'defer event',\n            },\n            'done syncing value': {\n              target: 'set up',\n            },\n            'patches': {\n              actions: ['defer incoming patches'],\n            },\n          },\n        },\n        'set up': {\n          type: 'parallel',\n          states: {\n            'value sync': {\n              initial: 'idle',\n              states: {\n                'idle': {\n                  entry: [\n                    () => {\n                      debug('entry: setup->set up->value sync->idle')\n                    },\n                  ],\n                  exit: [\n                    () => {\n                      debug('exit: setup->set up->value sync->idle')\n                    },\n                  ],\n                  on: {\n                    'patches': {\n                      actions: [emit(({event}) => event)],\n                    },\n                    'syncing value': {\n                      target: 'syncing value',\n                    },\n                  },\n                },\n                'syncing value': {\n                  entry: [\n                    () => {\n                      debug('entry: setup->set up->value sync->syncing value')\n                    },\n                  ],\n                  exit: [\n                    () => {\n                      debug('exit: setup->set up->value sync->syncing value')\n                    },\n                    'emit pending incoming patches',\n                    'clear pending incoming patches',\n                  ],\n                  on: {\n                    'patches': {\n                      actions: ['defer incoming patches'],\n                    },\n                    'done syncing value': {\n                      target: 'idle',\n                    },\n                  },\n                },\n              },\n            },\n            'writing': {\n              initial: 'pristine',\n              states: {\n                pristine: {\n                  initial: 'idle',\n                  states: {\n                    idle: {\n                      entry: [\n                        () => {\n                          debug('entry: setup->set up->writing->pristine->idle')\n                        },\n                      ],\n                      exit: [\n                        () => {\n                          debug('exit: setup->set up->writing->pristine->idle')\n                        },\n                      ],\n                      on: {\n                        'normalizing': {\n                          target: 'normalizing',\n                        },\n                        'internal.patch': {\n                          actions: 'defer event',\n                          target: '#editor.setup.set up.writing.dirty',\n                        },\n                        'mutation': {\n                          actions: 'defer event',\n                          target: '#editor.setup.set up.writing.dirty',\n                        },\n                      },\n                    },\n                    normalizing: {\n                      entry: [\n                        () => {\n                          debug(\n                            'entry: setup->set up->writing->pristine->normalizing',\n                          )\n                        },\n                      ],\n                      exit: [\n                        () => {\n                          debug(\n                            'exit: setup->set up->writing->pristine->normalizing',\n                          )\n                        },\n                      ],\n                      on: {\n                        'done normalizing': {\n                          target: 'idle',\n                        },\n                        'internal.patch': {\n                          actions: 'defer event',\n                        },\n                        'mutation': {\n                          actions: 'defer event',\n                        },\n                      },\n                    },\n                  },\n                },\n                dirty: {\n                  entry: [\n                    () => {\n                      debug('entry: setup->set up->writing->dirty')\n                    },\n                    'emit pending events',\n                    'clear pending events',\n                  ],\n                  exit: [\n                    () => {\n                      debug('exit: setup->set up->writing->dirty')\n                    },\n                  ],\n                  on: {\n                    'internal.patch': {\n                      actions: 'emit patch event',\n                    },\n                    'mutation': {\n                      actions: 'emit mutation event',\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n})\n","import type {\n  ArraySchemaType,\n  BlockSchemaType,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\n\nexport function createLegacySchema(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): PortableTextMemberSchemaTypes {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import {Schema as SanitySchema} from '@sanity/schema'\nimport {defineField, defineType, type ObjectSchemaType} from '@sanity/types'\nimport startCase from 'lodash.startcase'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport {defaultKeyGenerator} from './key-generator'\nimport {createLegacySchema} from './legacy-schema'\n\n/**\n * @public\n */\nexport type BaseDefinition = {\n  name: string\n  title?: string\n}\n\nexport type FieldDefinition = {\n  name: string\n  type: 'string' | 'number' | 'boolean' | 'array' | 'object'\n}\n\n/**\n * @public\n */\nexport type SchemaDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = {\n  decorators?: ReadonlyArray<TBaseDefinition>\n  blockObjects?: ReadonlyArray<\n    TBaseDefinition & {fields?: ReadonlyArray<FieldDefinition>}\n  >\n  inlineObjects?: ReadonlyArray<\n    TBaseDefinition & {fields?: ReadonlyArray<FieldDefinition>}\n  >\n  annotations?: ReadonlyArray<\n    TBaseDefinition & {fields?: ReadonlyArray<FieldDefinition>}\n  >\n  lists?: ReadonlyArray<TBaseDefinition>\n  styles?: ReadonlyArray<TBaseDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\nconst temporaryImageName = `tmp-${defaultKeyGenerator()}-image`\nconst temporaryUrlName = `tmp-${defaultKeyGenerator()}-url`\n\nconst temporaryObjectNames: Record<string, string> = {\n  image: temporaryImageName,\n  url: temporaryUrlName,\n}\n\nconst objectNames: Record<string, string> = {\n  [temporaryImageName]: 'image',\n  [temporaryUrlName]: 'url',\n}\n\nconst defaultObjectTitles: Record<string, string> = {\n  image: 'Image',\n  url: 'URL',\n}\n\n/**\n * @public\n */\nexport type EditorSchema = {\n  annotations: ReadonlyArray<\n    BaseDefinition & {\n      fields: ReadonlyArray<{name: string; type: string}>\n    }\n  >\n  block: {\n    name: string\n  }\n  blockObjects: ReadonlyArray<\n    BaseDefinition & {\n      fields: ReadonlyArray<{name: string; type: string}>\n    }\n  >\n  decorators: ReadonlyArray<\n    BaseDefinition & {\n      /**\n       * @deprecated\n       * Use `name` instead\n       */\n      value: string\n    }\n  >\n  inlineObjects: ReadonlyArray<\n    BaseDefinition & {\n      fields: ReadonlyArray<{name: string; type: string}>\n    }\n  >\n  span: {\n    name: string\n  }\n  styles: ReadonlyArray<\n    BaseDefinition & {\n      /**\n       * @deprecated\n       * Use `name` instead\n       */\n      value: string\n    }\n  >\n  lists: ReadonlyArray<\n    BaseDefinition & {\n      /**\n       * @deprecated\n       * Use `name` instead\n       */\n      value: string\n    }\n  >\n}\n\nexport function legacySchemaToEditorSchema(\n  schema: PortableTextMemberSchemaTypes,\n): EditorSchema {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n      })),\n      title: annotation.title,\n    })),\n    block: {\n      name: schema.block.name,\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n      })),\n      title: blockObject.title,\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value,\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n      })),\n      title: inlineObject.title,\n    })),\n    span: {\n      name: schema.span.name,\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value,\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value,\n    })),\n  }\n}\n\nexport function compileSchemaDefinition<\n  TSchemaDefinition extends SchemaDefinition,\n>(definition: TSchemaDefinition): EditorSchema {\n  return legacySchemaToEditorSchema(\n    compileSchemaDefinitionToLegacySchema(definition),\n  )\n}\n\nexport function compileSchemaDefinitionToLegacySchema<\n  TSchemaDefinition extends SchemaDefinition,\n>(definition?: TSchemaDefinition): PortableTextMemberSchemaTypes {\n  const blockObjects =\n    definition?.blockObjects?.map((blockObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name: temporaryObjectNames[blockObject.name] ?? blockObject.name,\n        title:\n          blockObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[blockObject.name]\n            : blockObject.title,\n        fields:\n          blockObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const inlineObjects =\n    definition?.inlineObjects?.map((inlineObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name: temporaryObjectNames[inlineObject.name] ?? inlineObject.name,\n\n        title:\n          inlineObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[inlineObject.name]\n            : inlineObject.title,\n        fields:\n          inlineObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const portableTextSchema = defineField({\n    type: 'array',\n    name: 'portable-text',\n    of: [\n      ...blockObjects.map((blockObject) => ({type: blockObject.name})),\n      {\n        type: 'block',\n        name: 'block',\n        of: inlineObjects.map((inlineObject) => ({type: inlineObject.name})),\n        marks: {\n          decorators:\n            definition?.decorators?.map((decorator) => ({\n              title: decorator.title ?? startCase(decorator.name),\n              value: decorator.name,\n            })) ?? [],\n          annotations:\n            definition?.annotations?.map((annotation) => ({\n              name: annotation.name,\n              type: 'object',\n              title: annotation.title,\n              fields:\n                annotation.fields?.map((field) => ({\n                  name: field.name,\n                  type: field.type,\n                })) ?? [],\n            })) ?? [],\n        },\n        lists:\n          definition?.lists?.map((list) => ({\n            value: list.name,\n            title: list.title ?? startCase(list.name),\n          })) ?? [],\n        styles:\n          definition?.styles?.map((style) => ({\n            value: style.name,\n            title: style.title ?? startCase(style.name),\n          })) ?? [],\n      },\n    ],\n  })\n\n  const schema = SanitySchema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects],\n  }).get('portable-text')\n\n  const pteSchema = createLegacySchema(schema)\n\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) =>\n      objectNames[blockObject.name] !== undefined\n        ? ({\n            ...blockObject,\n            name: objectNames[blockObject.name],\n            type: {\n              ...blockObject.type,\n              name: objectNames[blockObject.name],\n            },\n          } as ObjectSchemaType)\n        : blockObject,\n    ),\n    inlineObjects: pteSchema.inlineObjects.map((inlineObject) =>\n      objectNames[inlineObject.name] !== undefined\n        ? ({\n            ...inlineObject,\n            name: objectNames[inlineObject.name],\n          } as ObjectSchemaType)\n        : inlineObject,\n    ),\n  } satisfies PortableTextMemberSchemaTypes\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {Editor} from 'slate'\nimport type {ActorRefFrom} from 'xstate'\nimport {\n  and,\n  assertEvent,\n  assign,\n  emit,\n  enqueueActions,\n  fromCallback,\n  not,\n  setup,\n  stateIn,\n  type AnyEventObject,\n} from 'xstate'\nimport {debugWithName} from '../internal-utils/debug'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\nimport type {PatchEvent} from './relay-machine'\n\nconst debug = debugWithName('mutation-machine')\n\nexport type MutationActor = ActorRefFrom<typeof mutationMachine>\n\n/**\n * Makes sure editor mutation events are debounced\n */\nexport const mutationMachine = setup({\n  types: {\n    context: {} as {\n      pendingMutations: Array<{\n        operationId?: string\n        value: Array<PortableTextBlock> | undefined\n        patches: Array<Patch>\n      }>\n      pendingPatchEvents: Array<PatchEvent>\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'mutation delay passed'\n        }\n      | {\n          type: 'patch'\n          patch: Patch\n          operationId?: string\n          value: Array<PortableTextBlock>\n        }\n      | {\n          type: 'typing'\n        }\n      | {\n          type: 'not typing'\n        }\n      | {\n          type: 'update readOnly'\n          readOnly: boolean\n        },\n    input: {} as {\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n    },\n    emitted: {} as\n      | {\n          type: 'has pending mutations'\n        }\n      | {\n          type: 'mutation'\n          patches: Array<Patch>\n          snapshot: Array<PortableTextBlock> | undefined\n        }\n      | PatchEvent,\n  },\n  actions: {\n    'assign readOnly': assign({\n      readOnly: ({context, event}) =>\n        event.type === 'update readOnly' ? event.readOnly : context.readOnly,\n    }),\n    'emit patch': enqueueActions(({event, enqueue}) => {\n      if (event.type === 'patch') {\n        enqueue.emit({type: 'patch', patch: event.patch})\n      }\n    }),\n    'emit has pending mutations': emit({type: 'has pending mutations'}),\n    'emit mutations': enqueueActions(({context, enqueue}) => {\n      for (const bulk of context.pendingMutations) {\n        enqueue.emit({\n          type: 'mutation',\n          patches: bulk.patches,\n          snapshot: bulk.value,\n        })\n      }\n    }),\n    'clear pending mutations': assign({\n      pendingMutations: [],\n    }),\n    'defer mutation': assign({\n      pendingMutations: ({context, event}) => {\n        assertEvent(event, 'patch')\n\n        if (context.pendingMutations.length === 0) {\n          return [\n            {\n              operationId: event.operationId,\n              value: event.value,\n              patches: [event.patch],\n            },\n          ]\n        }\n\n        const lastBulk = context.pendingMutations.at(-1)\n\n        if (lastBulk && lastBulk.operationId === event.operationId) {\n          return context.pendingMutations.slice(0, -1).concat({\n            value: event.value,\n            operationId: lastBulk.operationId,\n            patches: [...lastBulk.patches, event.patch],\n          })\n        }\n\n        return context.pendingMutations.concat({\n          value: event.value,\n          operationId: event.operationId,\n          patches: [event.patch],\n        })\n      },\n    }),\n    'clear pending patch events': assign({\n      pendingPatchEvents: [],\n    }),\n    'defer patch': assign({\n      pendingPatchEvents: ({context, event}) =>\n        event.type === 'patch'\n          ? [...context.pendingPatchEvents, event]\n          : context.pendingPatchEvents,\n    }),\n    'emit pending patch events': enqueueActions(({context, enqueue}) => {\n      for (const event of context.pendingPatchEvents) {\n        enqueue.emit(event)\n      }\n    }),\n  },\n  actors: {\n    'type listener': fromCallback<\n      AnyEventObject,\n      {slateEditor: PortableTextSlateEditor},\n      {type: 'typing'} | {type: 'not typing'}\n    >(({input, sendBack}) => {\n      const originalApply = input.slateEditor.apply\n\n      input.slateEditor.apply = (op) => {\n        if (op.type === 'insert_text' || op.type === 'remove_text') {\n          sendBack({type: 'typing'})\n        } else {\n          sendBack({type: 'not typing'})\n        }\n        originalApply(op)\n      }\n\n      return () => {\n        input.slateEditor.apply = originalApply\n      }\n    }),\n    'mutation debouncer': fromCallback(({sendBack}) => {\n      const interval = setInterval(\n        () => {\n          sendBack({type: 'mutation delay passed'})\n        },\n        process.env.NODE_ENV === 'test' ? 250 : 0,\n      )\n\n      return () => {\n        clearInterval(interval)\n      }\n    }),\n  },\n  guards: {\n    'is read-only': ({context}) => context.readOnly,\n    'is typing': stateIn({typing: 'typing'}),\n    'slate is normalizing': ({context}) =>\n      Editor.isNormalizing(context.slateEditor),\n  },\n  delays: {\n    'type debounce': process.env.NODE_ENV === 'test' ? 0 : 250,\n  },\n}).createMachine({\n  id: 'mutation',\n  context: ({input}) => ({\n    pendingMutations: [],\n    pendingPatchEvents: [],\n    readOnly: input.readOnly,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n  }),\n  on: {\n    'update readOnly': {\n      actions: ['assign readOnly'],\n    },\n  },\n  type: 'parallel',\n  states: {\n    typing: {\n      initial: 'idle',\n      invoke: {\n        src: 'type listener',\n        input: ({context}) => ({slateEditor: context.slateEditor}),\n      },\n      states: {\n        idle: {\n          entry: [\n            () => {\n              debug('entry: typing->idle')\n            },\n          ],\n          exit: [\n            () => {\n              debug('exit: typing->idle')\n              debug('entry: typing->typing')\n            },\n          ],\n          on: {\n            typing: {\n              target: 'typing',\n            },\n          },\n        },\n        typing: {\n          after: {\n            'type debounce': {\n              target: 'idle',\n              actions: [\n                () => {\n                  debug('exit: typing->typing')\n                },\n              ],\n            },\n          },\n          on: {\n            'not typing': {\n              target: 'idle',\n            },\n            'typing': {\n              target: 'typing',\n              reenter: true,\n            },\n          },\n        },\n      },\n    },\n    mutations: {\n      initial: 'idle',\n      states: {\n        'idle': {\n          entry: [\n            () => {\n              debug('entry: mutations->idle')\n            },\n          ],\n          exit: [\n            () => {\n              debug('exit: mutations->idle')\n            },\n          ],\n          on: {\n            patch: [\n              {\n                guard: 'is read-only',\n                actions: ['defer patch', 'defer mutation'],\n                target: 'has pending mutations',\n              },\n              {\n                actions: ['emit patch', 'defer mutation'],\n                target: 'has pending mutations',\n              },\n            ],\n          },\n        },\n        'has pending mutations': {\n          entry: [\n            () => {\n              debug('entry: mutations->has pending mutations')\n            },\n            'emit has pending mutations',\n          ],\n          exit: [\n            () => {\n              debug('exit: mutations->has pending mutations')\n            },\n          ],\n          invoke: {\n            src: 'mutation debouncer',\n          },\n          on: {\n            'mutation delay passed': {\n              guard: and([\n                not('is read-only'),\n                not('is typing'),\n                'slate is normalizing',\n              ]),\n              target: 'idle',\n              actions: [\n                'emit pending patch events',\n                'clear pending patch events',\n                'emit mutations',\n                'clear pending mutations',\n              ],\n            },\n            'patch': [\n              {\n                guard: 'is read-only',\n                actions: ['defer patch', 'defer mutation'],\n              },\n              {\n                actions: ['emit patch', 'defer mutation'],\n              },\n            ],\n          },\n        },\n      },\n    },\n  },\n})\n","import {\n  isPortableTextSpan,\n  type Path,\n  type PortableTextBlock,\n  type PortableTextChild,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  Editor,\n  Node,\n  Range,\n  Element as SlateElement,\n  Text,\n  Transforms,\n} from 'slate'\nimport type {DOMNode} from 'slate-dom'\nimport {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {toSlateRange} from '../../internal-utils/ranges'\nimport {\n  isListItemActive,\n  isStyleActive,\n  slateRangeToSelection,\n} from '../../internal-utils/slate-utils'\nimport {fromSlateValue, toSlateValue} from '../../internal-utils/values'\nimport {\n  KEY_TO_VALUE_ELEMENT,\n  SLATE_TO_PORTABLE_TEXT_RANGE,\n} from '../../internal-utils/weakMaps'\nimport {addAnnotationOperationImplementation} from '../../operations/behavior.operation.annotation.add'\nimport type {\n  EditableAPI,\n  EditableAPIDeleteOptions,\n  EditorSelection,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {getEditorSnapshot} from '../editor-selector'\n\nconst debug = debugWithName('API:editable')\n\nexport function createEditableAPI(\n  editor: PortableTextSlateEditor,\n  editorActor: EditorActor,\n) {\n  const types = editorActor.getSnapshot().context.schema\n\n  const editableApi: EditableAPI = {\n    focus: (): void => {\n      editorActor.send({\n        type: 'focus',\n        editor,\n      })\n    },\n    blur: (): void => {\n      editorActor.send({\n        type: 'blur',\n        editor,\n      })\n    },\n    toggleMark: (mark: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'decorator.toggle',\n          decorator: mark,\n        },\n        editor,\n      })\n    },\n    toggleList: (listItem: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'list item.toggle',\n          listItem,\n        },\n        editor,\n      })\n    },\n    toggleBlockStyle: (style: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'style.toggle',\n          style,\n        },\n        editor,\n      })\n    },\n    isMarkActive: (mark: string): boolean => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor,\n      })\n\n      return snapshot.beta.activeDecorators.includes(mark)\n    },\n    marks: (): string[] => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor,\n      })\n\n      return [\n        ...snapshot.beta.activeAnnotations,\n        ...snapshot.beta.activeDecorators,\n      ]\n    },\n    undo: (): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'history.undo',\n        },\n        editor,\n      })\n    },\n    redo: (): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'history.redo',\n        },\n        editor,\n      })\n    },\n    select: (selection: EditorSelection): void => {\n      const slateSelection = toSlateRange(selection, editor)\n      if (slateSelection) {\n        Transforms.select(editor, slateSelection)\n      } else {\n        Transforms.deselect(editor)\n      }\n      editor.onChange()\n    },\n    focusBlock: (): PortableTextBlock | undefined => {\n      if (editor.selection) {\n        const block = Node.descendant(\n          editor,\n          editor.selection.focus.path.slice(0, 1),\n        )\n        if (block) {\n          return fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0]\n        }\n      }\n      return undefined\n    },\n    focusChild: (): PortableTextChild | undefined => {\n      if (editor.selection) {\n        const block = Node.descendant(\n          editor,\n          editor.selection.focus.path.slice(0, 1),\n        )\n        if (block && editor.isTextBlock(block)) {\n          const ptBlock = fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0] as PortableTextTextBlock\n          return ptBlock.children[editor.selection.focus.path[1]]\n        }\n      }\n      return undefined\n    },\n    insertChild: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n      value?: {[prop: string]: any},\n    ): Path => {\n      if (type.name !== types.span.name) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'insert.inline object',\n            inlineObject: {\n              name: type.name,\n              value,\n            },\n          },\n          editor,\n        })\n\n        return editor.selection\n          ? (slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor,\n              range: editor.selection,\n            })?.focus.path ?? [])\n          : []\n      }\n\n      if (!editor.selection) {\n        throw new Error('The editor has no selection')\n      }\n      const [focusBlock] = Array.from(\n        Editor.nodes(editor, {\n          at: editor.selection.focus.path.slice(0, 1),\n          match: (n) => n._type === types.block.name,\n        }),\n      )[0] || [undefined]\n      if (!focusBlock) {\n        throw new Error('No focused text block')\n      }\n      if (\n        type.name !== types.span.name &&\n        !types.inlineObjects.some((t) => t.name === type.name)\n      ) {\n        throw new Error(\n          'This type cannot be inserted as a child to a text block',\n        )\n      }\n      const block = toSlateValue(\n        [\n          {\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n            _type: types.block.name,\n            children: [\n              {\n                _key: editorActor.getSnapshot().context.keyGenerator(),\n                _type: type.name,\n                ...(value ? value : {}),\n              },\n            ],\n          },\n        ],\n        {schemaTypes: editorActor.getSnapshot().context.schema},\n      )[0] as unknown as SlateElement\n      const child = block.children[0]\n      const focusChildPath = editor.selection.focus.path.slice(0, 2)\n      const isSpanNode = child._type === types.span.name\n      const focusNode = Node.get(editor, focusChildPath)\n\n      // If we are inserting a span, and currently have focus on an inline object,\n      // move the selection to the next span (guaranteed by normalizing rules) before inserting it.\n      if (isSpanNode && focusNode._type !== types.span.name) {\n        debug(\n          'Inserting span child next to inline object child, moving selection + 1',\n        )\n        editor.move({distance: 1, unit: 'character'})\n      }\n\n      Transforms.insertNodes(editor, child, {\n        select: true,\n        at: editor.selection,\n      })\n      editor.onChange()\n\n      return editor.selection\n        ? (slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range: editor.selection,\n          })?.focus.path ?? [])\n        : []\n    },\n    insertBlock: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n      value?: {[prop: string]: any},\n    ): Path => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.block',\n          block: {\n            _type: type.name,\n            ...(value ? value : {}),\n          },\n          placement: 'auto',\n        },\n        editor,\n      })\n\n      return editor.selection\n        ? (slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range: editor.selection,\n          })?.focus.path ?? [])\n        : []\n    },\n    hasBlockStyle: (style: string): boolean => {\n      try {\n        return isStyleActive({editor, style})\n      } catch {\n        // This is fine.\n        return false\n      }\n    },\n    hasListStyle: (listItem: string): boolean => {\n      try {\n        return isListItemActive({editor, listItem})\n      } catch {\n        // This is fine.\n        return false\n      }\n    },\n    isVoid: (element: PortableTextBlock | PortableTextChild) => {\n      return ![types.block.name, types.span.name].includes(element._type)\n    },\n    findByPath: (\n      path: Path,\n    ): [\n      PortableTextBlock | PortableTextChild | undefined,\n      Path | undefined,\n    ] => {\n      const slatePath = toSlateRange(\n        {focus: {path, offset: 0}, anchor: {path, offset: 0}},\n        editor,\n      )\n      if (slatePath) {\n        const [block, blockPath] = Editor.node(\n          editor,\n          slatePath.focus.path.slice(0, 1),\n        )\n        if (block && blockPath && typeof block._key === 'string') {\n          if (path.length === 1 && slatePath.focus.path.length === 1) {\n            return [\n              fromSlateValue([block], types.block.name)[0],\n              [{_key: block._key}],\n            ]\n          }\n          const ptBlock = fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0]\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]]\n            if (ptChild) {\n              return [\n                ptChild,\n                [{_key: block._key}, 'children', {_key: ptChild._key}],\n              ]\n            }\n          }\n        }\n      }\n      return [undefined, undefined]\n    },\n    findDOMNode: (\n      element: PortableTextBlock | PortableTextChild,\n    ): DOMNode | undefined => {\n      let node: DOMNode | undefined\n      try {\n        const [item] = Array.from(\n          Editor.nodes(editor, {\n            at: [],\n            match: (n) => n._key === element._key,\n          }) || [],\n        )[0] || [undefined]\n        node = ReactEditor.toDOMNode(editor, item)\n      } catch {\n        // Nothing\n      }\n      return node\n    },\n    activeAnnotations: (): PortableTextObject[] => {\n      if (!editor.selection || editor.selection.focus.path.length < 2) {\n        return []\n      }\n      try {\n        const activeAnnotations: PortableTextObject[] = []\n        const spans = Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) =>\n            Text.isText(node) &&\n            node.marks !== undefined &&\n            Array.isArray(node.marks) &&\n            node.marks.length > 0,\n        })\n        for (const [span, path] of spans) {\n          const [block] = Editor.node(editor, path, {depth: 1})\n          if (editor.isTextBlock(block)) {\n            block.markDefs?.forEach((def) => {\n              if (\n                Text.isText(span) &&\n                span.marks &&\n                Array.isArray(span.marks) &&\n                span.marks.includes(def._key)\n              ) {\n                activeAnnotations.push(def)\n              }\n            })\n          }\n        }\n        return activeAnnotations\n      } catch {\n        return []\n      }\n    },\n    isAnnotationActive: (\n      annotationType: PortableTextObject['_type'],\n    ): boolean => {\n      return isAnnotationActive({editor, annotation: {name: annotationType}})\n    },\n    addAnnotation: (type, value) => {\n      let paths: ReturnType<EditableAPI['addAnnotation']> = undefined\n\n      Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationOperationImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types,\n          },\n          operation: {\n            type: 'annotation.add',\n            annotation: {name: type.name, value: value ?? {}},\n            editor,\n          },\n        })\n      })\n      editor.onChange()\n\n      return paths\n    },\n    delete: (\n      selection: EditorSelection,\n      options?: EditableAPIDeleteOptions,\n    ): void => {\n      if (selection) {\n        const range = toSlateRange(selection, editor)\n        const hasRange =\n          range && range.anchor.path.length > 0 && range.focus.path.length > 0\n        if (!hasRange) {\n          throw new Error('Invalid range')\n        }\n        if (range) {\n          if (!options?.mode || options?.mode === 'selected') {\n            debug(`Deleting content in selection`)\n            Transforms.delete(editor, {\n              at: range,\n              hanging: true,\n              voids: true,\n            })\n            editor.onChange()\n            return\n          }\n          if (options?.mode === 'blocks') {\n            debug(`Deleting blocks touched by selection`)\n            Transforms.removeNodes(editor, {\n              at: range,\n              voids: true,\n              match: (node) => {\n                return (\n                  editor.isTextBlock(node) ||\n                  (!editor.isTextBlock(node) && SlateElement.isElement(node))\n                )\n              },\n            })\n          }\n          if (options?.mode === 'children') {\n            debug(`Deleting children touched by selection`)\n            Transforms.removeNodes(editor, {\n              at: range,\n              voids: true,\n              match: (node) => {\n                return (\n                  node._type === types.span.name || // Text children\n                  (!editor.isTextBlock(node) && SlateElement.isElement(node)) // inline blocks\n                )\n              },\n            })\n          }\n          // If the editor was emptied, insert a placeholder block\n          // directly into the editor's children. We don't want to do this\n          // through a Transform (because that would trigger a change event\n          // that would insert the placeholder into the actual value\n          // which should remain empty)\n          if (editor.children.length === 0) {\n            editor.children = [editor.pteCreateTextBlock({decorators: []})]\n          }\n          editor.onChange()\n        }\n      }\n    },\n    removeAnnotation: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n    ): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'annotation.remove',\n          annotation: {name: type.name},\n        },\n        editor,\n      })\n    },\n    getSelection: (): EditorSelection | null => {\n      let ptRange: EditorSelection = null\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection)\n        if (existing) {\n          return existing\n        }\n        ptRange = slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection,\n        })\n        SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange)\n      }\n      return ptRange\n    },\n    getValue: () => {\n      return fromSlateValue(\n        editor.children,\n        types.block.name,\n        KEY_TO_VALUE_ELEMENT.get(editor),\n      )\n    },\n    isCollapsedSelection: () => {\n      return !!editor.selection && Range.isCollapsed(editor.selection)\n    },\n    isExpandedSelection: () => {\n      return !!editor.selection && Range.isExpanded(editor.selection)\n    },\n    insertBreak: () => {\n      editor.insertBreak()\n      editor.onChange()\n    },\n    getFragment: () => {\n      return fromSlateValue(editor.getFragment(), types.block.name)\n    },\n    isSelectionsOverlapping: (\n      selectionA: EditorSelection,\n      selectionB: EditorSelection,\n    ) => {\n      // Convert the selections to Slate ranges\n      const rangeA = toSlateRange(selectionA, editor)\n      const rangeB = toSlateRange(selectionB, editor)\n\n      // Make sure the ranges are valid\n      const isValidRanges = Range.isRange(rangeA) && Range.isRange(rangeB)\n\n      // Check if the ranges are overlapping\n      const isOverlapping = isValidRanges && Range.includes(rangeA, rangeB)\n\n      return isOverlapping\n    },\n  }\n\n  return editableApi\n}\n\nfunction isAnnotationActive({\n  editor,\n  annotation,\n}: {\n  editor: PortableTextSlateEditor\n  annotation: {\n    name: string\n  }\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2) {\n    return false\n  }\n\n  try {\n    const spans = [\n      ...Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => Text.isText(node),\n      }),\n    ]\n\n    if (spans.length === 0) {\n      return false\n    }\n\n    if (\n      spans.some(\n        ([span]) =>\n          !isPortableTextSpan(span) || !span.marks || span.marks?.length === 0,\n      )\n    )\n      return false\n\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = Editor.node(editor, path, {depth: 1})\n      if (editor.isTextBlock(block) && block.markDefs) {\n        return [...accMarkDefs, ...block.markDefs]\n      }\n      return accMarkDefs\n    }, [] as PortableTextObject[])\n\n    return spans.every(([span]) => {\n      if (!isPortableTextSpan(span)) return false\n\n      const spanMarkDefs = span.marks?.map(\n        (markKey) =>\n          selectionMarkDefs.find((def) => def?._key === markKey)?._type,\n      )\n\n      return spanMarkDefs?.includes(annotation.name)\n    })\n  } catch {\n    return false\n  }\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport type {FocusEvent} from 'react'\nimport {emit, setup, type ActorRefFrom} from 'xstate'\nimport type {EditorSelection, InvalidValueResolution} from '../types/editor'\n\n/**\n * @public\n */\nexport type EditorEmittedEvent =\n  | {\n      type: 'blurred'\n      event: FocusEvent<HTMLDivElement, Element>\n    }\n  | {\n      /**\n       * @deprecated\n       */\n      type: 'done loading'\n    }\n  | {\n      type: 'editable'\n    }\n  | ErrorEvent\n  | {\n      type: 'focused'\n      event: FocusEvent<HTMLDivElement, Element>\n    }\n  | {\n      type: 'invalid value'\n      resolution: InvalidValueResolution | null\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      /**\n       * @deprecated\n       */\n      type: 'loading'\n    }\n  | MutationEvent\n  | PatchEvent\n  | {\n      type: 'read only'\n    }\n  | {\n      type: 'ready'\n    }\n  | {\n      type: 'selection'\n      selection: EditorSelection\n    }\n  | {\n      type: 'value changed'\n      value: Array<PortableTextBlock> | undefined\n    }\n\n/**\n * @deprecated The event is no longer emitted\n */\ntype ErrorEvent = {\n  type: 'error'\n  name: string\n  description: string\n  data: unknown\n}\n\nexport type InternalEditorEmittedEvent = EditorEmittedEvent | UnsetEvent\n\n/**\n * @public\n */\nexport type MutationEvent = {\n  type: 'mutation'\n  patches: Array<Patch>\n  /**\n   * @deprecated Use `value` instead\n   */\n  snapshot: Array<PortableTextBlock> | undefined\n  value: Array<PortableTextBlock> | undefined\n}\n\nexport type PatchEvent = {\n  type: 'patch'\n  patch: Patch\n}\n\nexport type UnsetEvent = {\n  /**\n   * @deprecated Use `'patch'` events instead\n   */\n  type: 'unset'\n  previousValue: Array<PortableTextBlock>\n}\n\nexport type RelayActor = ActorRefFrom<typeof relayMachine>\n\nexport const relayMachine = setup({\n  types: {\n    events: {} as InternalEditorEmittedEvent,\n    emitted: {} as InternalEditorEmittedEvent,\n  },\n}).createMachine({\n  id: 'relay',\n  on: {\n    '*': {\n      actions: emit(({event}) => event),\n    },\n  },\n})\n","import {insert, set, setIfMissing, unset} from '@portabletext/patches'\nimport type {\n  PortableTextBlock,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {flatten, isPlainObject, uniq} from 'lodash'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {InvalidValueResolution} from '../types/editor'\nimport {isTextBlock} from './parse-blocks'\n\nexport interface Validation {\n  valid: boolean\n  resolution: InvalidValueResolution | null\n  value: PortableTextBlock[] | undefined\n}\n\nexport function validateValue(\n  value: PortableTextBlock[] | undefined,\n  types: EditorSchema,\n  keyGenerator: () => string,\n): Validation {\n  let resolution: InvalidValueResolution | null = null\n  let valid = true\n  const validChildTypes = [\n    types.span.name,\n    ...types.inlineObjects.map((t) => t.name),\n  ]\n  const validBlockTypes = [\n    types.block.name,\n    ...types.blockObjects.map((t) => t.name),\n  ]\n\n  // Undefined is allowed\n  if (value === undefined) {\n    return {valid: true, resolution: null, value}\n  }\n  // Only lengthy arrays are allowed in the editor.\n  if (!Array.isArray(value) || value.length === 0) {\n    return {\n      valid: false,\n      resolution: {\n        patches: [unset([])],\n        description:\n          'Editor value must be an array of Portable Text blocks, or undefined.',\n        action: 'Unset the value',\n        item: value,\n\n        i18n: {\n          description:\n            'inputs.portable-text.invalid-value.not-an-array.description',\n          action: 'inputs.portable-text.invalid-value.not-an-array.action',\n        },\n      },\n      value,\n    }\n  }\n  if (\n    value.some((blk: PortableTextBlock, index: number): boolean => {\n      // Is the block an object?\n      if (!isPlainObject(blk)) {\n        resolution = {\n          patches: [unset([index])],\n          description: `Block must be an object, got ${String(blk)}`,\n          action: `Unset invalid item`,\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.not-an-object.description',\n            action: 'inputs.portable-text.invalid-value.not-an-object.action',\n            values: {index},\n          },\n        }\n        return true\n      }\n      // Test that every block has a _key prop\n      if (!blk._key || typeof blk._key !== 'string') {\n        resolution = {\n          patches: [set({...blk, _key: keyGenerator()}, [index])],\n          description: `Block at index ${index} is missing required _key.`,\n          action: 'Set the block with a random _key value',\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.missing-key.description',\n            action: 'inputs.portable-text.invalid-value.missing-key.action',\n            values: {index},\n          },\n        }\n        return true\n      }\n      // Test that every block has valid _type\n      if (!blk._type || !validBlockTypes.includes(blk._type)) {\n        // Special case where block type is set to default 'block', but the block type is named something else according to the schema.\n        if (blk._type === 'block') {\n          const currentBlockTypeName = types.block.name\n          resolution = {\n            patches: [\n              set({...blk, _type: currentBlockTypeName}, [{_key: blk._key}]),\n            ],\n            description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n            action: `Use type '${currentBlockTypeName}'`,\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.incorrect-block-type.description',\n              action:\n                'inputs.portable-text.invalid-value.incorrect-block-type.action',\n              values: {key: blk._key, expectedTypeName: currentBlockTypeName},\n            },\n          }\n          return true\n        }\n\n        // If the block has no `_type`, but aside from that is a valid Portable Text block\n        if (\n          !blk._type &&\n          isTextBlock({schema: types}, {...blk, _type: types.block.name})\n        ) {\n          resolution = {\n            patches: [\n              set({...blk, _type: types.block.name}, [{_key: blk._key}]),\n            ],\n            description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n            action: `Use type '${types.block.name}'`,\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-block-type.description',\n              action:\n                'inputs.portable-text.invalid-value.missing-block-type.action',\n              values: {key: blk._key, expectedTypeName: types.block.name},\n            },\n          }\n          return true\n        }\n\n        if (!blk._type) {\n          resolution = {\n            patches: [unset([{_key: blk._key}])],\n            description: `Block with _key '${blk._key}' is missing an _type property`,\n            action: 'Remove the block',\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-type.description',\n              action: 'inputs.portable-text.invalid-value.missing-type.action',\n              values: {key: blk._key},\n            },\n          }\n          return true\n        }\n\n        resolution = {\n          patches: [unset([{_key: blk._key}])],\n          description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n          action: 'Remove the block',\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.disallowed-type.description',\n            action: 'inputs.portable-text.invalid-value.disallowed-type.action',\n            values: {key: blk._key, typeName: blk._type},\n          },\n        }\n        return true\n      }\n\n      // Test regular text blocks\n      if (blk._type === types.block.name) {\n        const textBlock = blk as PortableTextTextBlock\n        // Test that it has a valid children property (array)\n        if (textBlock.children && !Array.isArray(textBlock.children)) {\n          resolution = {\n            patches: [set({children: []}, [{_key: textBlock._key}])],\n            description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n            action: 'Reset the children property',\n            item: textBlock,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-or-invalid-children.description',\n              action:\n                'inputs.portable-text.invalid-value.missing-or-invalid-children.action',\n              values: {key: textBlock._key},\n            },\n          }\n          return true\n        }\n        // Test that children is set and lengthy\n        if (\n          textBlock.children === undefined ||\n          (Array.isArray(textBlock.children) && textBlock.children.length === 0)\n        ) {\n          const newSpan = {\n            _type: types.span.name,\n            _key: keyGenerator(),\n            text: '',\n            marks: [],\n          }\n          resolution = {\n            autoResolve: true,\n            patches: [\n              setIfMissing([], [{_key: blk._key}, 'children']),\n              insert([newSpan], 'after', [{_key: blk._key}, 'children', 0]),\n            ],\n            description: `Children for text block with _key '${blk._key}' is empty.`,\n            action: 'Insert an empty text',\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.empty-children.description',\n              action:\n                'inputs.portable-text.invalid-value.empty-children.action',\n              values: {key: blk._key},\n            },\n          }\n          return true\n        }\n\n        const allUsedMarks = uniq(\n          flatten(\n            textBlock.children\n              .filter((cld) => cld._type === types.span.name)\n              .map((cld) => cld.marks || []),\n          ) as string[],\n        )\n\n        // Test that all markDefs are in use (remove orphaned markDefs)\n        if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n          const unusedMarkDefs: string[] = uniq(\n            blk.markDefs\n              .map((def) => def._key)\n              .filter((key) => !allUsedMarks.includes(key)),\n          )\n          if (unusedMarkDefs.length > 0) {\n            resolution = {\n              autoResolve: true,\n              patches: unusedMarkDefs.map((markDefKey) =>\n                unset([{_key: blk._key}, 'markDefs', {_key: markDefKey}]),\n              ),\n              description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\n                ', ',\n              )}.`,\n              action: 'Remove unused mark definition item',\n              item: blk,\n              i18n: {\n                description:\n                  'inputs.portable-text.invalid-value.orphaned-mark-defs.description',\n                action:\n                  'inputs.portable-text.invalid-value.orphaned-mark-defs.action',\n                values: {\n                  key: blk._key,\n                  unusedMarkDefs: unusedMarkDefs.map((m) => m.toString()),\n                },\n              },\n            }\n            return true\n          }\n        }\n\n        // Test that every annotation mark used has a definition\n        const annotationMarks = allUsedMarks.filter(\n          (mark) => !types.decorators.map((dec) => dec.name).includes(mark),\n        )\n        const orphanedMarks = annotationMarks.filter(\n          (mark) =>\n            textBlock.markDefs === undefined ||\n            !textBlock.markDefs.find((def) => def._key === mark),\n        )\n        if (orphanedMarks.length > 0) {\n          const spanChildren = textBlock.children.filter(\n            (cld) =>\n              cld._type === types.span.name &&\n              Array.isArray(cld.marks) &&\n              cld.marks.some((mark) => orphanedMarks.includes(mark)),\n          ) as PortableTextSpan[]\n          if (spanChildren) {\n            const orphaned = orphanedMarks.join(', ')\n            resolution = {\n              autoResolve: true,\n              patches: spanChildren.map((child) => {\n                return set(\n                  (child.marks || []).filter(\n                    (cMrk) => !orphanedMarks.includes(cMrk),\n                  ),\n                  [{_key: blk._key}, 'children', {_key: child._key}, 'marks'],\n                )\n              }),\n              description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n              action: 'Remove invalid marks',\n              item: blk,\n\n              i18n: {\n                description:\n                  'inputs.portable-text.invalid-value.orphaned-marks.description',\n                action:\n                  'inputs.portable-text.invalid-value.orphaned-marks.action',\n                values: {\n                  key: blk._key,\n                  orphanedMarks: orphanedMarks.map((m) => m.toString()),\n                },\n              },\n            }\n            return true\n          }\n        }\n\n        // Test every child\n        if (\n          textBlock.children.some((child, cIndex: number) => {\n            if (!isPlainObject(child)) {\n              resolution = {\n                patches: [unset([{_key: blk._key}, 'children', cIndex])],\n                description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n                action: 'Remove the item',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.non-object-child.description',\n                  action:\n                    'inputs.portable-text.invalid-value.non-object-child.action',\n                  values: {key: blk._key, index: cIndex},\n                },\n              }\n              return true\n            }\n\n            if (!child._key || typeof child._key !== 'string') {\n              const newChild = {...child, _key: keyGenerator()}\n              resolution = {\n                autoResolve: true,\n                patches: [\n                  set(newChild, [{_key: blk._key}, 'children', cIndex]),\n                ],\n                description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n                action: 'Set a new random _key on the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.missing-child-key.description',\n                  action:\n                    'inputs.portable-text.invalid-value.missing-child-key.action',\n                  values: {key: blk._key, index: cIndex},\n                },\n              }\n              return true\n            }\n\n            // Verify that children have valid types\n            if (!child._type) {\n              resolution = {\n                patches: [\n                  unset([{_key: blk._key}, 'children', {_key: child._key}]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n                action: 'Remove the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.missing-child-type.description',\n                  action:\n                    'inputs.portable-text.invalid-value.missing-child-type.action',\n                  values: {key: blk._key, childKey: child._key},\n                },\n              }\n              return true\n            }\n\n            if (!validChildTypes.includes(child._type)) {\n              resolution = {\n                patches: [\n                  unset([{_key: blk._key}, 'children', {_key: child._key}]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n                action: 'Remove the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.disallowed-child-type.description',\n                  action:\n                    'inputs.portable-text.invalid-value.disallowed-child-type.action',\n                  values: {\n                    key: blk._key,\n                    childKey: child._key,\n                    childType: child._type,\n                  },\n                },\n              }\n              return true\n            }\n\n            // Verify that spans have .text property that is a string\n            if (\n              child._type === types.span.name &&\n              typeof child.text !== 'string'\n            ) {\n              resolution = {\n                patches: [\n                  set({...child, text: ''}, [\n                    {_key: blk._key},\n                    'children',\n                    {_key: child._key},\n                  ]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n                action: `Write an empty text property to the object`,\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.invalid-span-text.description',\n                  action:\n                    'inputs.portable-text.invalid-value.invalid-span-text.action',\n                  values: {key: blk._key, childKey: child._key},\n                },\n              }\n              return true\n            }\n            return false\n          })\n        ) {\n          valid = false\n        }\n      }\n      return false\n    })\n  ) {\n    valid = false\n  }\n  return {valid, resolution, value}\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {Editor, Text, Transforms, type Descendant, type Node} from 'slate'\nimport {\n  and,\n  assertEvent,\n  assign,\n  emit,\n  fromCallback,\n  not,\n  raise,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport type {ActorRefFrom} from 'xstate'\nimport {debugWithName} from '../internal-utils/debug'\nimport {validateValue} from '../internal-utils/validateValue'\nimport {toSlateValue, VOID_CHILD_KEY} from '../internal-utils/values'\nimport {\n  isChangingRemotely,\n  withRemoteChanges,\n} from '../internal-utils/withChanges'\nimport {withoutPatching} from '../internal-utils/withoutPatching'\nimport type {PickFromUnion} from '../type-utils'\nimport type {\n  InvalidValueResolution,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\nimport {withoutSaving} from './plugins/createWithUndoRedo'\n\nconst debug = debugWithName('sync machine')\n\ntype SyncValueEvent =\n  | {\n      type: 'patch'\n      patch: Patch\n    }\n  | {\n      type: 'invalid value'\n      resolution: InvalidValueResolution | null\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'value changed'\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'done syncing'\n      value: Array<PortableTextBlock> | undefined\n    }\n\nconst syncValueCallback: CallbackLogicFunction<\n  AnyEventObject,\n  SyncValueEvent,\n  {\n    context: {\n      keyGenerator: () => string\n      previousValue: Array<PortableTextBlock> | undefined\n      readOnly: boolean\n      schema: EditorSchema\n    }\n    slateEditor: PortableTextSlateEditor\n    streamBlocks: boolean\n    value: Array<PortableTextBlock> | undefined\n  }\n> = ({sendBack, input}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks,\n  })\n}\n\nconst syncValueLogic = fromCallback(syncValueCallback)\n\nexport type SyncActor = ActorRefFrom<typeof syncMachine>\n\n/**\n * Sync value with the editor state\n *\n * Normally nothing here should apply, and the editor and the real world are perfectly aligned.\n *\n * Inconsistencies could happen though, so we need to check the editor state when the value changes.\n *\n * For performance reasons, it makes sense to also do the content validation here, as we already\n * iterate over the value and can validate only the new content that is actually changed.\n *\n * @internal\n */\nexport const syncMachine = setup({\n  types: {\n    context: {} as {\n      initialValue: Array<PortableTextBlock> | undefined\n      initialValueSynced: boolean\n      isProcessingLocalChanges: boolean\n      keyGenerator: () => string\n      schema: EditorSchema\n      readOnly: boolean\n      slateEditor: PortableTextSlateEditor\n      pendingValue: Array<PortableTextBlock> | undefined\n      previousValue: Array<PortableTextBlock> | undefined\n    },\n    input: {} as {\n      initialValue: Array<PortableTextBlock> | undefined\n      keyGenerator: () => string\n      schema: EditorSchema\n      readOnly: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'has pending mutations'\n        }\n      | {\n          type: 'mutation'\n        }\n      | {\n          type: 'update value'\n          value: Array<PortableTextBlock> | undefined\n        }\n      | {\n          type: 'update readOnly'\n          readOnly: boolean\n        }\n      | SyncValueEvent,\n    emitted: {} as\n      | PickFromUnion<\n          SyncValueEvent,\n          'type',\n          'invalid value' | 'patch' | 'value changed'\n        >\n      | {type: 'done syncing value'}\n      | {type: 'syncing value'},\n  },\n  actions: {\n    'assign initial value synced': assign({\n      initialValueSynced: true,\n    }),\n    'assign readOnly': assign({\n      readOnly: ({event}) => {\n        assertEvent(event, 'update readOnly')\n        return event.readOnly\n      },\n    }),\n    'assign pending value': assign({\n      pendingValue: ({event}) => {\n        assertEvent(event, 'update value')\n        return event.value\n      },\n    }),\n    'clear pending value': assign({\n      pendingValue: undefined,\n    }),\n    'assign previous value': assign({\n      previousValue: ({event}) => {\n        assertEvent(event, 'done syncing')\n        return event.value\n      },\n    }),\n    'emit done syncing value': emit({\n      type: 'done syncing value',\n    }),\n    'emit syncing value': emit({\n      type: 'syncing value',\n    }),\n  },\n  guards: {\n    'initial value synced': ({context}) => context.initialValueSynced,\n    'is busy': ({context}) => {\n      const editable = !context.readOnly\n      const isProcessingLocalChanges = context.isProcessingLocalChanges\n      const isChanging = isChangingRemotely(context.slateEditor) ?? false\n      const isBusy = editable && (isProcessingLocalChanges || isChanging)\n\n      debug('isBusy', {isBusy, editable, isProcessingLocalChanges, isChanging})\n\n      return isBusy\n    },\n    'is empty value': ({event}) => {\n      return event.type === 'update value' && event.value === undefined\n    },\n    'is empty array': ({event}) => {\n      return (\n        event.type === 'update value' &&\n        Array.isArray(event.value) &&\n        event.value.length === 0\n      )\n    },\n    'is new value': ({context, event}) => {\n      return (\n        event.type === 'update value' && context.previousValue !== event.value\n      )\n    },\n    'value changed while syncing': ({context, event}) => {\n      assertEvent(event, 'done syncing')\n      return context.pendingValue !== event.value\n    },\n    'pending value equals previous value': ({context}) => {\n      return isEqual(context.pendingValue, context.previousValue)\n    },\n  },\n  actors: {\n    'sync value': syncValueLogic,\n  },\n}).createMachine({\n  id: 'sync',\n  context: ({input}) => ({\n    initialValue: input.initialValue,\n    initialValueSynced: false,\n    isProcessingLocalChanges: false,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: undefined,\n    previousValue: undefined,\n  }),\n  entry: [\n    raise(({context}) => {\n      return {type: 'update value', value: context.initialValue}\n    }),\n  ],\n  on: {\n    'has pending mutations': {\n      actions: assign({\n        isProcessingLocalChanges: true,\n      }),\n    },\n    'mutation': {\n      actions: assign({\n        isProcessingLocalChanges: false,\n      }),\n    },\n    'update readOnly': {\n      actions: ['assign readOnly'],\n    },\n  },\n  initial: 'idle',\n  states: {\n    idle: {\n      entry: [\n        () => {\n          debug('entry: syncing->idle')\n        },\n      ],\n      exit: [\n        () => {\n          debug('exit: syncing->idle')\n        },\n      ],\n      on: {\n        'update value': [\n          {\n            guard: and(['is empty value', not('initial value synced')]),\n            actions: ['assign initial value synced', 'emit done syncing value'],\n          },\n          {\n            guard: and(['is empty array', not('initial value synced')]),\n            actions: [\n              'assign initial value synced',\n              emit({type: 'value changed', value: []}),\n              'emit done syncing value',\n            ],\n          },\n          {\n            guard: and(['is busy', 'is new value']),\n            target: 'busy',\n            actions: ['assign pending value'],\n          },\n          {\n            guard: 'is new value',\n            target: 'syncing',\n            actions: ['assign pending value'],\n          },\n          {\n            guard: not('initial value synced'),\n            actions: [\n              () => {\n                debug('no new value – setting initial value as synced')\n              },\n              'assign initial value synced',\n              'emit done syncing value',\n            ],\n          },\n          {\n            actions: [\n              () => {\n                debug('no new value and initial value already synced')\n              },\n            ],\n          },\n        ],\n      },\n    },\n    busy: {\n      entry: [\n        () => {\n          debug('entry: syncing->busy')\n        },\n      ],\n      exit: [\n        () => {\n          debug('exit: syncing->busy')\n        },\n      ],\n      after: {\n        1000: [\n          {\n            guard: 'is busy',\n            target: '.',\n            reenter: true,\n            actions: [\n              () => {\n                debug('reenter: syncing->busy')\n              },\n            ],\n          },\n          {\n            target: 'syncing',\n          },\n        ],\n      },\n      on: {\n        'update value': [\n          {\n            guard: 'is new value',\n            actions: ['assign pending value'],\n          },\n        ],\n      },\n    },\n    syncing: {\n      entry: [\n        () => {\n          debug('entry: syncing->syncing')\n        },\n        'emit syncing value',\n      ],\n      exit: [\n        () => {\n          debug('exit: syncing->syncing')\n        },\n        'emit done syncing value',\n      ],\n      invoke: {\n        src: 'sync value',\n        id: 'sync value',\n        input: ({context}) => {\n          return {\n            context: {\n              keyGenerator: context.keyGenerator,\n              previousValue: context.previousValue,\n              readOnly: context.readOnly,\n              schema: context.schema,\n            },\n            slateEditor: context.slateEditor,\n            streamBlocks: !context.initialValueSynced,\n            value: context.pendingValue,\n          }\n        },\n      },\n      on: {\n        'update value': {\n          guard: 'is new value',\n          actions: ['assign pending value'],\n        },\n        'patch': {\n          actions: [emit(({event}) => event)],\n        },\n        'invalid value': {\n          actions: [emit(({event}) => event)],\n        },\n        'value changed': {\n          actions: [emit(({event}) => event)],\n        },\n        'done syncing': [\n          {\n            guard: 'value changed while syncing',\n            actions: ['assign previous value', 'assign initial value synced'],\n            target: 'syncing',\n            reenter: true,\n          },\n          {\n            target: 'idle',\n            actions: [\n              'clear pending value',\n              'assign previous value',\n              'assign initial value synced',\n            ],\n          },\n        ],\n      },\n    },\n  },\n})\n\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value,\n}: {\n  context: {\n    keyGenerator: () => string\n    previousValue: Array<PortableTextBlock> | undefined\n    readOnly: boolean\n    schema: EditorSchema\n  }\n  sendBack: (event: SyncValueEvent) => void\n  slateEditor: PortableTextSlateEditor\n  streamBlocks: boolean\n  value: PortableTextBlock[] | undefined\n}) {\n  let doneSyncing = false\n  let isChanged = false\n  let isValid = true\n\n  const hadSelection = !!slateEditor.selection\n\n  // If empty value, remove everything in the editor and insert a placeholder block\n  if (!value || value.length === 0) {\n    debug('Value is empty')\n    Editor.withoutNormalizing(slateEditor, () => {\n      withoutSaving(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            if (doneSyncing) {\n              return\n            }\n\n            if (hadSelection) {\n              Transforms.deselect(slateEditor)\n            }\n\n            const childrenLength = slateEditor.children.length\n\n            slateEditor.children.forEach((_, index) => {\n              Transforms.removeNodes(slateEditor, {\n                at: [childrenLength - 1 - index],\n              })\n            })\n\n            Transforms.insertNodes(\n              slateEditor,\n              slateEditor.pteCreateTextBlock({decorators: []}),\n              {at: [0]},\n            )\n\n            // Add a new selection in the top of the document\n            if (hadSelection) {\n              Transforms.select(slateEditor, [0, 0])\n            }\n          })\n        })\n      })\n    })\n    isChanged = true\n  }\n  // Remove, replace or add nodes according to what is changed.\n  if (value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema,\n    })\n\n    if (streamBlocks) {\n      await new Promise<void>((resolve) => {\n        Editor.withoutNormalizing(slateEditor, () => {\n          withRemoteChanges(slateEditor, () => {\n            withoutPatching(slateEditor, () => {\n              if (doneSyncing) {\n                resolve()\n                return\n              }\n\n              isChanged = removeExtraBlocks({\n                slateEditor,\n                slateValueFromProps,\n              })\n\n              const processBlocks = async () => {\n                for await (const [\n                  currentBlock,\n                  currentBlockIndex,\n                ] of getStreamedBlocks({\n                  slateValue: slateValueFromProps,\n                })) {\n                  const {blockChanged, blockValid} = syncBlock({\n                    context,\n                    sendBack,\n                    block: currentBlock,\n                    index: currentBlockIndex,\n                    slateEditor,\n                    value,\n                  })\n\n                  isChanged = blockChanged || isChanged\n                  isValid = isValid && blockValid\n                }\n\n                resolve()\n              }\n\n              processBlocks()\n            })\n          })\n        })\n      })\n    } else {\n      Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            if (doneSyncing) {\n              return\n            }\n\n            isChanged = removeExtraBlocks({\n              slateEditor,\n              slateValueFromProps,\n            })\n\n            let index = 0\n\n            for (const currentBlock of slateValueFromProps) {\n              const {blockChanged, blockValid} = syncBlock({\n                context,\n                sendBack,\n                block: currentBlock,\n                index,\n                slateEditor,\n                value,\n              })\n\n              isChanged = blockChanged || isChanged\n              isValid = isValid && blockValid\n              index++\n            }\n          })\n        })\n      })\n    }\n  }\n\n  if (!isValid) {\n    debug('Invalid value, returning')\n    doneSyncing = true\n    sendBack({type: 'done syncing', value})\n    return\n  }\n\n  if (isChanged) {\n    debug('Server value changed, syncing editor')\n    try {\n      slateEditor.onChange()\n    } catch (err) {\n      console.error(err)\n      sendBack({\n        type: 'invalid value',\n        resolution: null,\n        value,\n      })\n      doneSyncing = true\n      sendBack({type: 'done syncing', value})\n      return\n    }\n    if (hadSelection && !slateEditor.selection) {\n      Transforms.select(slateEditor, {\n        anchor: {path: [0, 0], offset: 0},\n        focus: {path: [0, 0], offset: 0},\n      })\n      slateEditor.onChange()\n    }\n    sendBack({type: 'value changed', value})\n  } else {\n    debug('Server value and editor value is equal, no need to sync.')\n  }\n\n  doneSyncing = true\n  sendBack({type: 'done syncing', value})\n}\n\nfunction removeExtraBlocks({\n  slateEditor,\n  slateValueFromProps,\n}: {\n  slateEditor: PortableTextSlateEditor\n  slateValueFromProps: Array<Descendant>\n}) {\n  let isChanged = false\n  const childrenLength = slateEditor.children.length\n\n  // Remove blocks that have become superfluous\n  if (slateValueFromProps.length < childrenLength) {\n    for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--) {\n      Transforms.removeNodes(slateEditor, {\n        at: [i],\n      })\n    }\n    isChanged = true\n  }\n  return isChanged\n}\n\nasync function* getStreamedBlocks({\n  slateValue,\n}: {\n  slateValue: Array<Descendant>\n}) {\n  let index = 0\n  for await (const block of slateValue) {\n    if (index % 10 === 0) {\n      await new Promise<void>((resolve) => setTimeout(resolve, 0))\n    }\n    yield [block, index] as const\n    index++\n  }\n}\n\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value,\n}: {\n  context: {\n    keyGenerator: () => string\n    previousValue: Array<PortableTextBlock> | undefined\n    readOnly: boolean\n    schema: EditorSchema\n  }\n  sendBack: (event: SyncValueEvent) => void\n  block: Descendant\n  index: number\n  slateEditor: PortableTextSlateEditor\n  value: Array<PortableTextBlock>\n}) {\n  let blockChanged = false\n  let blockValid = true\n  const currentBlock = block\n  const currentBlockIndex = index\n  const oldBlock = slateEditor.children[currentBlockIndex]\n  const hasChanges = oldBlock && !isEqual(currentBlock, oldBlock)\n\n  Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]]\n          const validation = validateValue(\n            validationValue,\n            context.schema,\n            context.keyGenerator,\n          )\n          // Resolve validations that can be resolved automatically, without involving the user (but only if the value was changed)\n          if (\n            !validation.valid &&\n            validation.resolution?.autoResolve &&\n            validation.resolution?.patches.length > 0\n          ) {\n            // Only apply auto resolution if the value has been populated before and is different from the last one.\n            if (\n              !context.readOnly &&\n              context.previousValue &&\n              context.previousValue !== value\n            ) {\n              // Give a console warning about the fact that it did an auto resolution\n              console.warn(\n                `${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`,\n              )\n              validation.resolution.patches.forEach((patch) => {\n                sendBack({type: 'patch', patch})\n              })\n            }\n          }\n          if (validation.valid || validation.resolution?.autoResolve) {\n            if (oldBlock._key === currentBlock._key) {\n              if (debug.enabled) debug('Updating block', oldBlock, currentBlock)\n              _updateBlock(\n                slateEditor,\n                currentBlock,\n                oldBlock,\n                currentBlockIndex,\n              )\n            } else {\n              if (debug.enabled)\n                debug('Replacing block', oldBlock, currentBlock)\n              _replaceBlock(slateEditor, currentBlock, currentBlockIndex)\n            }\n            blockChanged = true\n          } else {\n            sendBack({\n              type: 'invalid value',\n              resolution: validation.resolution,\n              value,\n            })\n            blockValid = false\n          }\n        }\n\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]]\n          const validation = validateValue(\n            validationValue,\n            context.schema,\n            context.keyGenerator,\n          )\n          if (debug.enabled)\n            debug(\n              'Validating and inserting new block in the end of the value',\n              currentBlock,\n            )\n          if (validation.valid || validation.resolution?.autoResolve) {\n            Transforms.insertNodes(slateEditor, currentBlock, {\n              at: [currentBlockIndex],\n            })\n          } else {\n            debug('Invalid', validation)\n            sendBack({\n              type: 'invalid value',\n              resolution: validation.resolution,\n              value,\n            })\n            blockValid = false\n          }\n        }\n      })\n    })\n  })\n\n  return {blockChanged, blockValid}\n}\n\n/**\n * This code is moved out of the above algorithm to keep complexity down.\n * @internal\n */\nfunction _replaceBlock(\n  slateEditor: PortableTextSlateEditor,\n  currentBlock: Descendant,\n  currentBlockIndex: number,\n) {\n  // While replacing the block and the current selection focus is on the replaced block,\n  // temporarily deselect the editor then optimistically try to restore the selection afterwards.\n  const currentSelection = slateEditor.selection\n  const selectionFocusOnBlock =\n    currentSelection && currentSelection.focus.path[0] === currentBlockIndex\n  if (selectionFocusOnBlock) {\n    Transforms.deselect(slateEditor)\n  }\n  Transforms.removeNodes(slateEditor, {at: [currentBlockIndex]})\n  Transforms.insertNodes(slateEditor, currentBlock, {at: [currentBlockIndex]})\n  slateEditor.onChange()\n  if (selectionFocusOnBlock) {\n    Transforms.select(slateEditor, currentSelection)\n  }\n}\n\n/**\n * This code is moved out of the above algorithm to keep complexity down.\n * @internal\n */\nfunction _updateBlock(\n  slateEditor: PortableTextSlateEditor,\n  currentBlock: Descendant,\n  oldBlock: Descendant,\n  currentBlockIndex: number,\n) {\n  // Update the root props on the block\n  Transforms.setNodes(slateEditor, currentBlock as Partial<Node>, {\n    at: [currentBlockIndex],\n  })\n  // Text block's need to have their children updated as well (setNode does not target a node's children)\n  if (\n    slateEditor.isTextBlock(currentBlock) &&\n    slateEditor.isTextBlock(oldBlock)\n  ) {\n    const oldBlockChildrenLength = oldBlock.children.length\n    if (currentBlock.children.length < oldBlockChildrenLength) {\n      // Remove any children that have become superfluous\n      Array.from(\n        Array(oldBlockChildrenLength - currentBlock.children.length),\n      ).forEach((_, index) => {\n        const childIndex = oldBlockChildrenLength - 1 - index\n        if (childIndex > 0) {\n          debug('Removing child')\n          Transforms.removeNodes(slateEditor, {\n            at: [currentBlockIndex, childIndex],\n          })\n        }\n      })\n    }\n    currentBlock.children.forEach(\n      (currentBlockChild, currentBlockChildIndex) => {\n        const oldBlockChild = oldBlock.children[currentBlockChildIndex]\n        const isChildChanged = !isEqual(currentBlockChild, oldBlockChild)\n        const isTextChanged = !isEqual(\n          currentBlockChild.text,\n          oldBlockChild?.text,\n        )\n        const path = [currentBlockIndex, currentBlockChildIndex]\n        if (isChildChanged) {\n          // Update if this is the same child\n          if (currentBlockChild._key === oldBlockChild?._key) {\n            debug('Updating changed child', currentBlockChild, oldBlockChild)\n            Transforms.setNodes(\n              slateEditor,\n              currentBlockChild as Partial<Node>,\n              {\n                at: path,\n              },\n            )\n            const isSpanNode =\n              Text.isText(currentBlockChild) &&\n              currentBlockChild._type === 'span' &&\n              Text.isText(oldBlockChild) &&\n              oldBlockChild._type === 'span'\n            if (isSpanNode && isTextChanged) {\n              if (oldBlockChild.text.length > 0) {\n                Transforms.delete(slateEditor, {\n                  at: {\n                    focus: {path, offset: 0},\n                    anchor: {path, offset: oldBlockChild.text.length},\n                  },\n                })\n              }\n              Transforms.insertText(slateEditor, currentBlockChild.text, {\n                at: path,\n              })\n              slateEditor.onChange()\n            } else if (!isSpanNode) {\n              // If it's a inline block, also update the void text node key\n              debug('Updating changed inline object child', currentBlockChild)\n              Transforms.setNodes(\n                slateEditor,\n                {_key: VOID_CHILD_KEY},\n                {\n                  at: [...path, 0],\n                  voids: true,\n                },\n              )\n            }\n            // Replace the child if _key's are different\n          } else if (oldBlockChild) {\n            debug('Replacing child', currentBlockChild)\n            Transforms.removeNodes(slateEditor, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            Transforms.insertNodes(slateEditor, currentBlockChild as Node, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            slateEditor.onChange()\n            // Insert it if it didn't exist before\n          } else if (!oldBlockChild) {\n            debug('Inserting new child', currentBlockChild)\n            Transforms.insertNodes(slateEditor, currentBlockChild as Node, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            slateEditor.onChange()\n          }\n        }\n      },\n    )\n  }\n}\n","import {createActor} from 'xstate'\nimport {createCoreConverters} from '../converters/converters.core'\nimport type {Editor, EditorConfig} from '../editor'\nimport {debugWithName} from '../internal-utils/debug'\nimport {compileType} from '../internal-utils/schema'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport {corePriority} from '../priority/priority.core'\nimport {createEditorPriority} from '../priority/priority.types'\nimport type {EditableAPI, PortableTextSlateEditor} from '../types/editor'\nimport {createSlateEditor, type SlateEditor} from './create-slate-editor'\nimport type {EditorActor} from './editor-machine'\nimport {editorMachine} from './editor-machine'\nimport {\n  compileSchemaDefinitionToLegacySchema,\n  legacySchemaToEditorSchema,\n} from './editor-schema'\nimport {getEditorSnapshot} from './editor-selector'\nimport {defaultKeyGenerator} from './key-generator'\nimport {createLegacySchema} from './legacy-schema'\nimport {mutationMachine, type MutationActor} from './mutation-machine'\nimport {createEditableAPI} from './plugins/createWithEditableAPI'\nimport {relayMachine, type RelayActor} from './relay-machine'\nimport {syncMachine, type SyncActor} from './sync-machine'\n\nconst debug = debugWithName('setup')\n\nexport type InternalEditor = Editor & {\n  _internal: {\n    editable: EditableAPI\n    editorActor: EditorActor\n    slateEditor: SlateEditor\n  }\n}\n\nexport function createInternalEditor(config: EditorConfig): {\n  actors: {\n    editorActor: EditorActor\n    mutationActor: MutationActor\n    relayActor: RelayActor\n    syncActor: SyncActor\n  }\n  editor: InternalEditor\n  subscriptions: Array<() => () => void>\n} {\n  debug('Creating new Editor instance')\n\n  const subscriptions: Array<() => () => void> = []\n  const editorActor = createActor(editorMachine, {\n    input: editorConfigToMachineInput(config),\n  })\n  const relayActor = createActor(relayMachine)\n  const slateEditor = createSlateEditor({\n    editorActor,\n    relayActor,\n    subscriptions,\n  })\n  const editable = createEditableAPI(slateEditor.instance, editorActor)\n  const {mutationActor, syncActor} = createActors({\n    editorActor,\n    relayActor,\n    slateEditor: slateEditor.instance,\n    subscriptions,\n  })\n\n  const editor = {\n    getSnapshot: () =>\n      getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor.instance,\n      }),\n    registerBehavior: (behaviorConfig) => {\n      const priority = createEditorPriority({\n        name: 'custom',\n        reference: {\n          priority: corePriority,\n          importance: 'higher',\n        },\n      })\n      const behaviorConfigWithPriority = {\n        ...behaviorConfig,\n        priority,\n      }\n\n      editorActor.send({\n        type: 'add behavior',\n        behaviorConfig: behaviorConfigWithPriority,\n      })\n\n      return () => {\n        editorActor.send({\n          type: 'remove behavior',\n          behaviorConfig: behaviorConfigWithPriority,\n        })\n      }\n    },\n    send: (event) => {\n      switch (event.type) {\n        case 'update value':\n          syncActor.send(event)\n          break\n\n        case 'update readOnly':\n        case 'patches':\n        case 'update maxBlocks':\n          editorActor.send(event)\n          break\n\n        case 'blur':\n          editorActor.send({\n            type: 'blur',\n            editor: slateEditor.instance,\n          })\n          break\n\n        case 'focus':\n          editorActor.send({\n            type: 'focus',\n            editor: slateEditor.instance,\n          })\n          break\n\n        case 'insert.block object':\n          editorActor.send({\n            type: 'behavior event',\n            behaviorEvent: {\n              type: 'insert.block',\n              block: {\n                _type: event.blockObject.name,\n                ...(event.blockObject.value ?? {}),\n              },\n              placement: event.placement,\n            },\n            editor: slateEditor.instance,\n          })\n          break\n\n        default:\n          editorActor.send({\n            type: 'behavior event',\n            behaviorEvent: event,\n            editor: slateEditor.instance,\n          })\n      }\n    },\n    on: (event, listener) => {\n      const subscription = relayActor.on(event, (event) => {\n        switch (event.type) {\n          case 'blurred':\n          case 'done loading':\n          case 'editable':\n          case 'focused':\n          case 'invalid value':\n          case 'loading':\n          case 'mutation':\n          case 'patch':\n          case 'read only':\n          case 'ready':\n          case 'selection':\n          case 'value changed':\n            listener(event)\n            break\n        }\n      })\n\n      return subscription\n    },\n    _internal: {\n      editable,\n      editorActor,\n      slateEditor,\n    },\n  } satisfies InternalEditor\n\n  return {\n    actors: {\n      editorActor,\n      mutationActor,\n      relayActor,\n      syncActor,\n    },\n    editor,\n    subscriptions,\n  }\n}\n\nfunction editorConfigToMachineInput(config: EditorConfig) {\n  const {legacySchema, schema} = compileSchemasFromEditorConfig(config)\n\n  return {\n    converters: createCoreConverters(legacySchema),\n    getLegacySchema: () => legacySchema,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema,\n    initialValue: config.initialValue,\n  } as const\n}\n\nfunction compileSchemasFromEditorConfig(config: EditorConfig) {\n  const legacySchema = config.schemaDefinition\n    ? compileSchemaDefinitionToLegacySchema(config.schemaDefinition)\n    : createLegacySchema(\n        config.schema.hasOwnProperty('jsonType')\n          ? config.schema\n          : compileType(config.schema),\n      )\n  const schema = legacySchemaToEditorSchema(legacySchema)\n\n  return {\n    legacySchema,\n    schema,\n  }\n}\n\nfunction createActors(config: {\n  editorActor: EditorActor\n  relayActor: RelayActor\n  slateEditor: PortableTextSlateEditor\n  subscriptions: Array<() => () => void>\n}): {\n  mutationActor: MutationActor\n  syncActor: SyncActor\n} {\n  debug('Creating new Actors')\n\n  const mutationActor = createActor(mutationMachine, {\n    input: {\n      readOnly: config.editorActor\n        .getSnapshot()\n        .matches({'edit mode': 'read only'}),\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor,\n    },\n  })\n\n  const syncActor = createActor(syncMachine, {\n    input: {\n      initialValue: config.editorActor.getSnapshot().context.initialValue,\n      keyGenerator: config.editorActor.getSnapshot().context.keyGenerator,\n      readOnly: config.editorActor\n        .getSnapshot()\n        .matches({'edit mode': 'read only'}),\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor,\n    },\n  })\n\n  config.subscriptions.push(() => {\n    const subscription = mutationActor.on('*', (event) => {\n      if (event.type === 'has pending mutations') {\n        syncActor.send({type: 'has pending mutations'})\n      }\n      if (event.type === 'mutation') {\n        syncActor.send({type: 'mutation'})\n        config.editorActor.send({\n          type: 'mutation',\n          patches: event.patches,\n          snapshot: event.snapshot,\n          value: event.snapshot,\n        })\n      }\n      if (event.type === 'patch') {\n        config.relayActor.send(event)\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  })\n\n  config.subscriptions.push(() => {\n    const subscription = syncActor.on('*', (event) => {\n      switch (event.type) {\n        case 'invalid value':\n          config.relayActor.send(event)\n          break\n        case 'value changed':\n          config.relayActor.send(event)\n          break\n        case 'patch':\n          config.editorActor.send({\n            ...event,\n            type: 'internal.patch',\n            value: fromSlateValue(\n              config.slateEditor.children,\n              config.editorActor.getSnapshot().context.schema.block.name,\n              KEY_TO_VALUE_ELEMENT.get(config.slateEditor),\n            ),\n          })\n          break\n\n        default:\n          config.editorActor.send(event)\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  })\n\n  config.subscriptions.push(() => {\n    const subscription = config.editorActor.subscribe((snapshot) => {\n      if (snapshot.matches({'edit mode': 'read only'})) {\n        mutationActor.send({type: 'update readOnly', readOnly: true})\n        syncActor.send({type: 'update readOnly', readOnly: true})\n      } else {\n        mutationActor.send({type: 'update readOnly', readOnly: false})\n        syncActor.send({type: 'update readOnly', readOnly: false})\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  })\n\n  config.subscriptions.push(() => {\n    const subscription = config.editorActor.on('*', (event) => {\n      switch (event.type) {\n        case 'editable':\n        case 'mutation':\n        case 'ready':\n        case 'read only':\n        case 'selection':\n          config.relayActor.send(event)\n          break\n        case 'internal.patch':\n          mutationActor.send({...event, type: 'patch'})\n          break\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  })\n\n  return {\n    mutationActor,\n    syncActor,\n  }\n}\n","import {\n  createContext,\n  startTransition,\n  useContext,\n  useEffect,\n  useState,\n} from 'react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EditorSelection} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * A React context for sharing the editor selection.\n */\nconst PortableTextEditorSelectionContext =\n  createContext<EditorSelection | null>(null)\n\n/**\n * @deprecated Use `useEditorSelector` to get the current editor selection.\n * @public\n * Get the current editor selection from the React context.\n */\nexport const usePortableTextEditorSelection = (): EditorSelection => {\n  const selection = useContext(PortableTextEditorSelectionContext)\n\n  if (selection === undefined) {\n    throw new Error(\n      `The \\`usePortableTextEditorSelection\\` hook must be used inside the <PortableTextEditor> component's context.`,\n    )\n  }\n  return selection\n}\nconst debug = debugWithName('component:PortableTextEditor:SelectionProvider')\nconst debugVerbose = debug.enabled && false\n\n/**\n * @internal\n */\nexport function PortableTextEditorSelectionProvider(\n  props: React.PropsWithChildren<{\n    editorActor: EditorActor\n  }>,\n) {\n  const [selection, setSelection] = useState<EditorSelection>(null)\n\n  // Subscribe to, and handle changes from the editor\n  useEffect(() => {\n    debug('Subscribing to selection changes')\n    const subscription = props.editorActor.on('selection', (event) => {\n      // Set the selection state in a transition, we don't need the state immediately.\n      startTransition(() => {\n        if (debugVerbose) debug('Setting selection')\n        setSelection(event.selection)\n      })\n    })\n\n    return () => {\n      debug('Unsubscribing to selection changes')\n      subscription.unsubscribe()\n    }\n  }, [props.editorActor])\n\n  return (\n    <PortableTextEditorSelectionContext.Provider value={selection}>\n      {props.children}\n    </PortableTextEditorSelectionContext.Provider>\n  )\n}\n","import {createContext} from 'react'\nimport type {RelayActor} from './relay-machine'\n\nexport const RelayActorContext = createContext<RelayActor>({} as RelayActor)\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorChange} from '../types/editor'\nimport type {InternalEditorEmittedEvent, RelayActor} from './relay-machine'\n\nexport function RouteEventsToChanges(props: {\n  relayActor: RelayActor\n  onChange: (change: EditorChange) => void\n}) {\n  // We want to ensure that _when_ `props.onChange` is called, it uses the current value.\n  // But we don't want to have the `useEffect` run setup + teardown + setup every time the prop might change, as that's unnecessary.\n  // So we use our own polyfill that lets us use an upcoming React hook that solves this exact problem.\n  // https://19.react.dev/learn/separating-events-from-effects#declaring-an-effect-event\n  const handleChange = useEffectEvent((change: EditorChange) =>\n    props.onChange(change),\n  )\n\n  useEffect(() => {\n    const sub = props.relayActor.on('*', (event) => {\n      const change = eventToChange(event)\n\n      if (change) {\n        handleChange(change)\n      }\n    })\n    return () => {\n      sub.unsubscribe()\n    }\n  }, [props.relayActor])\n\n  return null\n}\n\nexport function eventToChange(\n  event: InternalEditorEmittedEvent,\n): EditorChange | undefined {\n  switch (event.type) {\n    case 'blurred': {\n      return {type: 'blur', event: event.event}\n    }\n    case 'patch':\n      return event\n    case 'loading': {\n      return {type: 'loading', isLoading: true}\n    }\n    case 'done loading': {\n      return {type: 'loading', isLoading: false}\n    }\n    case 'focused': {\n      return {type: 'focus', event: event.event}\n    }\n    case 'value changed': {\n      return {type: 'value', value: event.value}\n    }\n    case 'invalid value': {\n      return {\n        type: 'invalidValue',\n        resolution: event.resolution,\n        value: event.value,\n      }\n    }\n    case 'mutation': {\n      return event\n    }\n    case 'ready': {\n      return event\n    }\n    case 'selection': {\n      return event\n    }\n    case 'unset': {\n      return event\n    }\n  }\n}\n","import type {\n  ArrayDefinition,\n  ArraySchemaType,\n  Path,\n  PortableTextBlock,\n  PortableTextChild,\n  PortableTextObject,\n} from '@sanity/types'\nimport {\n  Component,\n  useEffect,\n  type MutableRefObject,\n  type PropsWithChildren,\n} from 'react'\nimport {Subject} from 'rxjs'\nimport {Slate} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {stopActor} from '../internal-utils/stop-actor'\nimport type {AddedAnnotationPaths} from '../operations/behavior.operation.annotation.add'\nimport type {\n  EditableAPI,\n  EditableAPIDeleteOptions,\n  EditorChange,\n  EditorChanges,\n  EditorSelection,\n  PatchObservable,\n  PortableTextMemberSchemaTypes,\n} from '../types/editor'\nimport {createInternalEditor, type InternalEditor} from './create-editor'\nimport {EditorActorContext} from './editor-actor-context'\nimport type {EditorActor} from './editor-machine'\nimport {PortableTextEditorContext} from './hooks/usePortableTextEditor'\nimport {PortableTextEditorSelectionProvider} from './hooks/usePortableTextEditorSelection'\nimport type {MutationActor} from './mutation-machine'\nimport {RelayActorContext} from './relay-actor-context'\nimport type {RelayActor} from './relay-machine'\nimport {eventToChange} from './route-events-to-changes'\nimport type {SyncActor} from './sync-machine'\n\nconst debug = debugWithName('component:PortableTextEditor')\n\n/**\n * Props for the PortableTextEditor component\n *\n * @public\n * @deprecated Use `EditorProvider` instead\n */\nexport type PortableTextEditorProps<\n  TEditor extends InternalEditor | undefined = undefined,\n> = PropsWithChildren<\n  TEditor extends InternalEditor\n    ? {\n        /**\n         * @internal\n         */\n        editor: TEditor\n      }\n    : {\n        editor?: undefined\n\n        /**\n         * Function that gets called when the editor changes the value\n         */\n        onChange: (change: EditorChange) => void\n\n        /**\n         * Schema type for the portable text field\n         */\n        schemaType: ArraySchemaType<PortableTextBlock> | ArrayDefinition\n\n        /**\n         * Maximum number of blocks to allow within the editor\n         */\n        maxBlocks?: number | string\n\n        /**\n         * Function used to generate keys for array items (`_key`)\n         */\n        keyGenerator?: () => string\n\n        /**\n         * Observable of local and remote patches for the edited value.\n         */\n        patches$?: PatchObservable\n\n        /**\n         * Backward compatibility (renamed to patches$).\n         */\n        incomingPatches$?: PatchObservable\n\n        /**\n         * Whether or not the editor should be in read-only mode\n         */\n        readOnly?: boolean\n\n        /**\n         * The current value of the portable text field\n         */\n        value?: PortableTextBlock[]\n\n        /**\n         * A ref to the editor instance\n         */\n        editorRef?: MutableRefObject<PortableTextEditor | null>\n      }\n>\n\n/**\n * The main Portable Text Editor component.\n * @public\n * @deprecated Use `EditorProvider` instead\n */\nexport class PortableTextEditor extends Component<\n  PortableTextEditorProps<InternalEditor | undefined>\n> {\n  public static displayName = 'PortableTextEditor'\n  /**\n   * An observable of all the editor changes.\n   */\n  public change$: EditorChanges = new Subject()\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  public schemaTypes: PortableTextMemberSchemaTypes\n  /**\n   * The editor instance\n   */\n  private editor: InternalEditor\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  private editable: EditableAPI\n\n  private actors?: {\n    editorActor: EditorActor\n    mutationActor: MutationActor\n    relayActor: RelayActor\n    syncActor: SyncActor\n  }\n\n  private subscriptions: Array<() => () => void> = []\n  private unsubscribers: Array<() => void> = []\n\n  constructor(props: PortableTextEditorProps) {\n    super(props)\n\n    if (props.editor) {\n      this.editor = props.editor as InternalEditor\n      this.schemaTypes = this.editor._internal.editorActor\n        .getSnapshot()\n        .context.getLegacySchema()\n    } else {\n      const {actors, editor, subscriptions} = createInternalEditor({\n        initialValue: props.value,\n        keyGenerator: props.keyGenerator,\n        maxBlocks:\n          props.maxBlocks === undefined\n            ? undefined\n            : Number.parseInt(props.maxBlocks.toString(), 10),\n        readOnly: props.readOnly,\n        schema: props.schemaType,\n      })\n\n      this.subscriptions = subscriptions\n      this.actors = actors\n\n      this.editor = editor\n      this.schemaTypes = actors.editorActor\n        .getSnapshot()\n        .context.getLegacySchema()\n    }\n\n    this.editable = this.editor._internal.editable\n  }\n\n  componentDidMount(): void {\n    if (!this.actors) {\n      return\n    }\n\n    for (const subscription of this.subscriptions) {\n      this.unsubscribers.push(subscription())\n    }\n\n    const relayActorSubscription = this.actors.relayActor.on('*', (event) => {\n      const change = eventToChange(event)\n\n      if (!change) {\n        return\n      }\n\n      if (!this.props.editor) {\n        this.props.onChange(change)\n      }\n\n      this.change$.next(change)\n    })\n\n    this.unsubscribers.push(relayActorSubscription.unsubscribe)\n\n    this.actors.editorActor.start()\n    this.actors.mutationActor.start()\n    this.actors.relayActor.start()\n    this.actors.syncActor.start()\n  }\n\n  componentDidUpdate(prevProps: PortableTextEditorProps) {\n    // Set up the schema type lookup table again if the source schema type changes\n    if (\n      !this.props.editor &&\n      !prevProps.editor &&\n      this.props.schemaType !== prevProps.schemaType\n    ) {\n      console.warn('Updating schema type is no longer supported')\n    }\n\n    if (!this.props.editor && !prevProps.editor) {\n      if (this.props.readOnly !== prevProps.readOnly) {\n        this.editor._internal.editorActor.send({\n          type: 'update readOnly',\n          readOnly: this.props.readOnly ?? false,\n        })\n      }\n\n      if (this.props.maxBlocks !== prevProps.maxBlocks) {\n        this.editor._internal.editorActor.send({\n          type: 'update maxBlocks',\n          maxBlocks:\n            this.props.maxBlocks === undefined\n              ? undefined\n              : Number.parseInt(this.props.maxBlocks.toString(), 10),\n        })\n      }\n\n      if (this.props.value !== prevProps.value) {\n        this.editor.send({\n          type: 'update value',\n          value: this.props.value,\n        })\n      }\n\n      if (\n        this.props.editorRef !== prevProps.editorRef &&\n        this.props.editorRef\n      ) {\n        this.props.editorRef.current = this\n      }\n    }\n  }\n\n  componentWillUnmount(): void {\n    for (const unsubscribe of this.unsubscribers) {\n      unsubscribe()\n    }\n\n    if (this.actors) {\n      stopActor(this.actors.editorActor)\n      stopActor(this.actors.mutationActor)\n      stopActor(this.actors.relayActor)\n      stopActor(this.actors.syncActor)\n    }\n  }\n\n  public setEditable = (editable: EditableAPI) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable,\n    }\n  }\n\n  render() {\n    const legacyPatches = !this.props.editor\n      ? (this.props.incomingPatches$ ?? this.props.patches$)\n      : undefined\n\n    return (\n      <>\n        {legacyPatches ? (\n          <RoutePatchesObservableToEditorActor\n            editorActor={this.editor._internal.editorActor}\n            patches$={legacyPatches}\n          />\n        ) : null}\n        <EditorActorContext.Provider value={this.editor._internal.editorActor}>\n          <RelayActorContext.Provider value={this.actors!.relayActor}>\n            <Slate\n              editor={this.editor._internal.slateEditor.instance}\n              initialValue={this.editor._internal.slateEditor.initialValue}\n            >\n              <PortableTextEditorContext.Provider value={this}>\n                <PortableTextEditorSelectionProvider\n                  editorActor={this.editor._internal.editorActor}\n                >\n                  {this.props.children}\n                </PortableTextEditorSelectionProvider>\n              </PortableTextEditorContext.Provider>\n            </Slate>\n          </RelayActorContext.Provider>\n        </EditorActorContext.Provider>\n      </>\n    )\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)\n   * ```\n   */\n  static activeAnnotations = (\n    editor: PortableTextEditor,\n  ): PortableTextObject[] => {\n    return editor && editor.editable ? editor.editable.activeAnnotations() : []\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))\n   * ```\n   */\n  static isAnnotationActive = (\n    editor: PortableTextEditor,\n    annotationType: PortableTextObject['_type'],\n  ): boolean => {\n    return editor && editor.editable\n      ? editor.editable.isAnnotationActive(annotationType)\n      : false\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.add',\n   *  annotation: {\n   *    name: '...',\n   *    value: {...},\n   *  }\n   * })\n   * ```\n   */\n  static addAnnotation = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): AddedAnnotationPaths | undefined =>\n    editor.editable?.addAnnotation(type, value)\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'blur',\n   * })\n   * ```\n   */\n  static blur = (editor: PortableTextEditor): void => {\n    debug('Host blurred')\n    editor.editable?.blur()\n  }\n\n  static delete = (\n    editor: PortableTextEditor,\n    selection: EditorSelection,\n    options?: EditableAPIDeleteOptions,\n  ) => editor.editable?.delete(selection, options)\n\n  static findDOMNode = (\n    editor: PortableTextEditor,\n    element: PortableTextBlock | PortableTextChild,\n  ) => {\n    return editor.editable?.findDOMNode(element)\n  }\n\n  static findByPath = (editor: PortableTextEditor, path: Path) => {\n    return editor.editable?.findByPath(path) || []\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'focus',\n   * })\n   * ```\n   */\n  static focus = (editor: PortableTextEditor): void => {\n    debug('Host requesting focus')\n    editor.editable?.focus()\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)\n   * ```\n   */\n  static focusBlock = (editor: PortableTextEditor) => {\n    return editor.editable?.focusBlock()\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)\n   * ```\n   */\n  static focusChild = (\n    editor: PortableTextEditor,\n  ): PortableTextChild | undefined => {\n    return editor.editable?.focusChild()\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selection = useEditorSelector(editor, selectors.getSelection)\n   * ```\n   */\n  static getSelection = (editor: PortableTextEditor) => {\n    return editor.editable ? editor.editable.getSelection() : null\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const value = useEditorSelector(editor, selectors.getValue)\n   * ```\n   */\n  static getValue = (editor: PortableTextEditor) => {\n    return editor.editable?.getValue()\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))\n   * ```\n   */\n  static hasBlockStyle = (editor: PortableTextEditor, blockStyle: string) => {\n    return editor.editable?.hasBlockStyle(blockStyle)\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))\n   * ```\n   */\n  static hasListStyle = (editor: PortableTextEditor, listStyle: string) => {\n    return editor.editable?.hasListStyle(listStyle)\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)\n   * ```\n   */\n  static isCollapsedSelection = (editor: PortableTextEditor) =>\n    editor.editable?.isCollapsedSelection()\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)\n   * ```\n   */\n  static isExpandedSelection = (editor: PortableTextEditor) =>\n    editor.editable?.isExpandedSelection()\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))\n   * ```\n   */\n  static isMarkActive = (editor: PortableTextEditor, mark: string) =>\n    editor.editable?.isMarkActive(mark)\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.span',\n   *  text: '...',\n   *  annotations: [{name: '...', value: {...}}],\n   *  decorators: ['...'],\n   * })\n   * editor.send({\n   *  type: 'insert.inline object',\n   *  inlineObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   * })\n   * ```\n   */\n  static insertChild = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): Path | undefined => {\n    debug(`Host inserting child`)\n    return editor.editable?.insertChild(type, value)\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.block object',\n   *  blockObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   *  placement: 'auto' | 'after' | 'before',\n   * })\n   * ```\n   */\n  static insertBlock = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): Path | undefined => {\n    return editor.editable?.insertBlock(type, value)\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.break',\n   * })\n   * ```\n   */\n  static insertBreak = (editor: PortableTextEditor): void => {\n    return editor.editable?.insertBreak()\n  }\n\n  static isVoid = (\n    editor: PortableTextEditor,\n    element: PortableTextBlock | PortableTextChild,\n  ) => {\n    return editor.editable?.isVoid(element)\n  }\n\n  static isObjectPath = (_editor: PortableTextEditor, path: Path): boolean => {\n    if (!path || !Array.isArray(path)) return false\n    const isChildObjectEditPath = path.length > 3 && path[1] === 'children'\n    const isBlockObjectEditPath = path.length > 1 && path[1] !== 'children'\n    return isBlockObjectEditPath || isChildObjectEditPath\n  }\n\n  static marks = (editor: PortableTextEditor) => {\n    return editor.editable?.marks()\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'select',\n   *  selection: {...},\n   * })\n   * ```\n   */\n  static select = (\n    editor: PortableTextEditor,\n    selection: EditorSelection | null,\n  ) => {\n    debug(`Host setting selection`, selection)\n    editor.editable?.select(selection)\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.remove',\n   *  annotation: {\n   *    name: '...',\n   *  },\n   * })\n   * ```\n   */\n  static removeAnnotation = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n  ) => editor.editable?.removeAnnotation(type)\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'style.toggle',\n   *  style: '...',\n   * })\n   * ```\n   */\n  static toggleBlockStyle = (\n    editor: PortableTextEditor,\n    blockStyle: string,\n  ) => {\n    debug(`Host is toggling block style`)\n    return editor.editable?.toggleBlockStyle(blockStyle)\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'list item.toggle',\n   *  listItem: '...',\n   * })\n   * ```\n   */\n  static toggleList = (editor: PortableTextEditor, listStyle: string): void => {\n    return editor.editable?.toggleList(listStyle)\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'decorator.toggle',\n   *  decorator: '...',\n   * })\n   * ```\n   */\n  static toggleMark = (editor: PortableTextEditor, mark: string): void => {\n    debug(`Host toggling mark`, mark)\n    editor.editable?.toggleMark(mark)\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)\n   * ```\n   */\n  static getFragment = (\n    editor: PortableTextEditor,\n  ): PortableTextBlock[] | undefined => {\n    return editor.editable?.getFragment()\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.undo',\n   * })\n   * ```\n   */\n  static undo = (editor: PortableTextEditor): void => {\n    debug('Host undoing')\n    editor.editable?.undo()\n  }\n\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.redo',\n   * })\n   * ```\n   */\n  static redo = (editor: PortableTextEditor): void => {\n    debug('Host redoing')\n    editor.editable?.redo()\n  }\n\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))\n   * ```\n   */\n  static isSelectionsOverlapping = (\n    editor: PortableTextEditor,\n    selectionA: EditorSelection,\n    selectionB: EditorSelection,\n  ) => {\n    return editor.editable?.isSelectionsOverlapping(selectionA, selectionB)\n  }\n}\n\nfunction RoutePatchesObservableToEditorActor(props: {\n  editorActor: EditorActor\n  patches$: PatchObservable\n}) {\n  useEffect(() => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: 'patches',\n        ...payload,\n      })\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [props.editorActor, props.patches$])\n\n  return null\n}\n","import {useSelector} from '@xstate/react'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {useSelected, useSlateStatic, type RenderLeafProps} from 'slate-react'\nimport type {\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nexport interface RenderSpanProps extends RenderLeafProps {\n  children: ReactElement<any>\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\nexport function RenderSpan(props: RenderSpanProps) {\n  const slateEditor = useSlateStatic()\n  const editorActor = useContext(EditorActorContext)\n  const legacySchema = useSelector(editorActor, (s) =>\n    s.context.getLegacySchema(),\n  )\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n\n  const parent = props.children.props.parent\n  const block = parent && slateEditor.isTextBlock(parent) ? parent : undefined\n\n  const path = useMemo(\n    () =>\n      block\n        ? [{_key: block._key}, 'children', {_key: props.leaf._key}]\n        : undefined,\n    [block, props.leaf._key],\n  )\n\n  const decoratorSchemaTypes = editorActor\n    .getSnapshot()\n    .context.schema.decorators.map((decorator) => decorator.name)\n\n  const decorators = uniq(\n    (props.leaf.marks ?? []).filter((mark) =>\n      decoratorSchemaTypes.includes(mark),\n    ),\n  )\n\n  const annotationMarkDefs = (props.leaf.marks ?? []).flatMap((mark) => {\n    if (decoratorSchemaTypes.includes(mark)) {\n      return []\n    }\n\n    const markDef = block?.markDefs?.find((markDef) => markDef._key === mark)\n\n    if (markDef) {\n      return [markDef]\n    }\n\n    return []\n  })\n\n  const shouldTrackSelectionAndFocus =\n    annotationMarkDefs.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n\n    const winSelection = window.getSelection()\n\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blurred', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focused', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  let children = props.children\n\n  /**\n   * Support `renderDecorator` render function for each Decorator\n   */\n  for (const mark of decorators) {\n    const legacyDecoratorSchemaType = legacySchema.decorators.find(\n      (dec) => dec.value === mark,\n    )\n\n    if (path && legacyDecoratorSchemaType && props.renderDecorator) {\n      children = props.renderDecorator({\n        children: children,\n        editorElementRef: spanRef,\n        focused,\n        path,\n        selected,\n        schemaType: legacyDecoratorSchemaType,\n        value: mark,\n        type: legacyDecoratorSchemaType,\n      })\n    }\n  }\n\n  /**\n   * Support `renderAnnotation` render function for each Annotation\n   */\n  for (const annotationMarkDef of annotationMarkDefs) {\n    const legacyAnnotationSchemaType = legacySchema.annotations.find(\n      (t) => t.name === annotationMarkDef._type,\n    )\n    if (legacyAnnotationSchemaType) {\n      if (block && path && props.renderAnnotation) {\n        children = (\n          <span ref={spanRef}>\n            {props.renderAnnotation({\n              block,\n              children: children,\n              editorElementRef: spanRef,\n              focused,\n              path,\n              selected,\n              schemaType: legacyAnnotationSchemaType,\n              value: annotationMarkDef,\n              type: legacyAnnotationSchemaType,\n            })}\n          </span>\n        )\n      } else {\n        children = <span ref={spanRef}>{children}</span>\n      }\n    }\n  }\n\n  /**\n   * Support `renderChild` render function for the Span itself\n   */\n  if (block && path && props.renderChild) {\n    const child = block.children.find(\n      (_child) => _child._key === props.leaf._key,\n    ) // Ensure object equality\n\n    if (child) {\n      children = props.renderChild({\n        annotations: annotationMarkDefs,\n        children: children,\n        editorElementRef: spanRef,\n        focused,\n        path,\n        schemaType: legacySchema.span,\n        selected,\n        value: child,\n        type: legacySchema.span,\n      })\n    }\n  }\n\n  return (\n    <span {...props.attributes} ref={spanRef}>\n      {children}\n    </span>\n  )\n}\n","import {useSelector} from '@xstate/react'\nimport {useContext, type CSSProperties} from 'react'\nimport type {Text} from 'slate'\nimport type {RenderLeafProps} from 'slate-react'\nimport type {\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderPlaceholderFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {RenderSpan} from './render-span'\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\nexport function RenderLeaf(\n  props: RenderLeafProps & {\n    leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n    readOnly: boolean\n    renderAnnotation?: RenderAnnotationFunction\n    renderChild?: RenderChildFunction\n    renderDecorator?: RenderDecoratorFunction\n    renderPlaceholder?: RenderPlaceholderFunction\n  },\n) {\n  const editorActor = useContext(EditorActorContext)\n  const schema = useSelector(editorActor, (s) => s.context.schema)\n\n  if (props.leaf._type !== schema.span.name) {\n    return props.children\n  }\n\n  let renderedSpan = <RenderSpan {...props} />\n\n  if (\n    props.renderPlaceholder &&\n    props.leaf.placeholder &&\n    props.text.text === ''\n  ) {\n    return (\n      <>\n        <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n          {props.renderPlaceholder()}\n        </span>\n        {renderedSpan}\n      </>\n    )\n  }\n\n  const rangeDecoration = props.leaf.rangeDecoration\n\n  if (rangeDecoration) {\n    renderedSpan = rangeDecoration.component({children: renderedSpan})\n  }\n\n  return renderedSpan\n}\n","import type {Editable} from 'slate-react'\n\nexport type RenderTextProps = Parameters<\n  NonNullable<React.ComponentProps<typeof Editable>['renderText']>\n>[0]\n\nexport function RenderText(props: RenderTextProps) {\n  return (\n    <span\n      {...props.attributes}\n      data-child-key={props.text._key}\n      data-child-name={props.text._type}\n      data-child-type=\"span\"\n    >\n      {props.children}\n    </span>\n  )\n}\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import {isEqual} from 'lodash'\nimport {\n  Element,\n  Path,\n  Range,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n} from 'slate'\nimport {\n  and,\n  assign,\n  fromCallback,\n  setup,\n  type ActorRefFrom,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {moveRangeByOperation, toSlateRange} from '../internal-utils/ranges'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {PortableTextSlateEditor, RangeDecoration} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\n\nconst slateOperationCallback: CallbackLogicFunction<\n  AnyEventObject,\n  {type: 'slate operation'; operation: Operation},\n  {slateEditor: PortableTextSlateEditor}\n> = ({input, sendBack}) => {\n  const originalApply = input.slateEditor.apply\n\n  input.slateEditor.apply = (op) => {\n    if (op.type !== 'set_selection') {\n      sendBack({type: 'slate operation', operation: op})\n    }\n\n    originalApply(op)\n  }\n\n  return () => {\n    input.slateEditor.apply = originalApply\n  }\n}\n\ntype DecoratedRange = BaseRange & {rangeDecoration: RangeDecoration}\n\nexport const rangeDecorationsMachine = setup({\n  types: {\n    context: {} as {\n      decoratedRanges: Array<DecoratedRange>\n      pendingRangeDecorations: Array<RangeDecoration>\n      skipSetup: boolean\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n      updateCount: number\n    },\n    input: {} as {\n      rangeDecorations: Array<RangeDecoration>\n      readOnly: boolean\n      schema: EditorSchema\n      skipSetup: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'ready'\n        }\n      | {\n          type: 'range decorations updated'\n          rangeDecorations: Array<RangeDecoration>\n        }\n      | {\n          type: 'slate operation'\n          operation: Operation\n        }\n      | {\n          type: 'update read only'\n          readOnly: boolean\n        },\n  },\n  actions: {\n    'update pending range decorations': assign({\n      pendingRangeDecorations: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.pendingRangeDecorations\n        }\n\n        return event.rangeDecorations\n      },\n    }),\n    'set up initial range decorations': assign({\n      decoratedRanges: ({context}) => {\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of context.pendingRangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'update range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of event.rangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'move range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'slate operation') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const decoratedRange of context.decoratedRanges) {\n          const slateRange = toSlateRange(\n            decoratedRange.rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          let newRange: BaseRange | null | undefined\n\n          newRange = moveRangeByOperation(slateRange, event.operation)\n          if (\n            (newRange && newRange !== slateRange) ||\n            (newRange === null && slateRange)\n          ) {\n            const newRangeSelection = newRange\n              ? slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                })\n              : null\n\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: newRangeSelection,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n          }\n\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            rangeDecorationState.push({\n              ...(newRange || slateRange),\n              rangeDecoration: {\n                ...decoratedRange.rangeDecoration,\n                selection: slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                }),\n              },\n            })\n          }\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'assign readOnly': assign({\n      readOnly: ({context, event}) => {\n        if (event.type !== 'update read only') {\n          return context.readOnly\n        }\n\n        return event.readOnly\n      },\n    }),\n    'increment update count': assign({\n      updateCount: ({context}) => {\n        return context.updateCount + 1\n      },\n    }),\n  },\n  actors: {\n    'slate operation listener': fromCallback(slateOperationCallback),\n  },\n  guards: {\n    'has pending range decorations': ({context}) =>\n      context.pendingRangeDecorations.length > 0,\n    'has range decorations': ({context}) => context.decoratedRanges.length > 0,\n    'has different decorations': ({context, event}) => {\n      if (event.type !== 'range decorations updated') {\n        return false\n      }\n\n      const existingRangeDecorations = context.decoratedRanges.map(\n        (decoratedRange) => ({\n          anchor: decoratedRange.rangeDecoration.selection?.anchor,\n          focus: decoratedRange.rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const newRangeDecorations = event.rangeDecorations.map(\n        (rangeDecoration) => ({\n          anchor: rangeDecoration.selection?.anchor,\n          focus: rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const different = !isEqual(existingRangeDecorations, newRangeDecorations)\n\n      return different\n    },\n    'not read only': ({context}) => !context.readOnly,\n    'should skip setup': ({context}) => context.skipSetup,\n  },\n}).createMachine({\n  id: 'range decorations',\n  context: ({input}) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    updateCount: 0,\n  }),\n  invoke: {\n    src: 'slate operation listener',\n    input: ({context}) => ({slateEditor: context.slateEditor}),\n  },\n  on: {\n    'update read only': {\n      actions: ['assign readOnly'],\n    },\n  },\n  initial: 'setting up',\n  states: {\n    'setting up': {\n      always: [\n        {\n          guard: and(['should skip setup', 'has pending range decorations']),\n          target: 'ready',\n          actions: [\n            'set up initial range decorations',\n            'increment update count',\n          ],\n        },\n        {\n          guard: 'should skip setup',\n          target: 'ready',\n        },\n      ],\n      on: {\n        'range decorations updated': {\n          actions: ['update pending range decorations'],\n        },\n        'ready': [\n          {\n            target: 'ready',\n            guard: 'has pending range decorations',\n            actions: [\n              'set up initial range decorations',\n              'increment update count',\n            ],\n          },\n          {\n            target: 'ready',\n          },\n        ],\n      },\n    },\n    'ready': {\n      initial: 'idle',\n      on: {\n        'range decorations updated': {\n          target: '.idle',\n          guard: 'has different decorations',\n          actions: ['update range decorations', 'increment update count'],\n        },\n      },\n      states: {\n        'idle': {\n          on: {\n            'slate operation': {\n              target: 'moving range decorations',\n              guard: and(['has range decorations', 'not read only']),\n            },\n          },\n        },\n        'moving range decorations': {\n          entry: ['move range decorations'],\n          always: {\n            target: 'idle',\n          },\n        },\n      },\n    },\n  },\n})\n\nexport function createDecorate(\n  rangeDecorationActor: ActorRefFrom<typeof rangeDecorationsMachine>,\n) {\n  return function decorate([node, path]: NodeEntry): Array<BaseRange> {\n    if (\n      isEqualToEmptyEditor(\n        rangeDecorationActor.getSnapshot().context.slateEditor.children,\n        rangeDecorationActor.getSnapshot().context.schema,\n      )\n    ) {\n      return [\n        {\n          anchor: {\n            path: [0, 0],\n            offset: 0,\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0,\n          },\n          placeholder: true,\n        } as BaseRange,\n      ]\n    }\n\n    // Editor node has a path length of 0 (should never be decorated)\n    if (path.length === 0) {\n      return []\n    }\n\n    if (!Element.isElement(node) || node.children.length === 0) {\n      return []\n    }\n\n    const blockIndex = path.at(0)\n\n    if (blockIndex === undefined) {\n      return []\n    }\n\n    return rangeDecorationActor\n      .getSnapshot()\n      .context.decoratedRanges.filter((decoratedRange) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (Range.isCollapsed(decoratedRange)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          return node.children.some(\n            (_, childIndex) =>\n              Path.equals(decoratedRange.anchor.path, [\n                blockIndex,\n                childIndex,\n              ]) &&\n              Path.equals(decoratedRange.focus.path, [blockIndex, childIndex]),\n          )\n        }\n\n        return (\n          Range.intersection(decoratedRange, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || Range.includes(decoratedRange, path)\n        )\n      })\n  }\n}\n","import {useActorRef, useSelector} from '@xstate/react'\nimport {noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {Editor, Transforms, type Text} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {RenderElement} from './components/render-element'\nimport {RenderLeaf} from './components/render-leaf'\nimport {RenderText, type RenderTextProps} from './components/render-text'\nimport {EditorActorContext} from './editor-actor-context'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {\n  createDecorate,\n  rangeDecorationsMachine,\n} from './range-decorations-machine'\nimport {RelayActorContext} from './relay-actor-context'\n\nconst debug = debugWithName('component:Editable')\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const editorActor = useContext(EditorActorContext)\n  const relayActor = useContext(RelayActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const slateEditor = useSlate()\n\n  const rangeDecorationsActor = useActorRef(rangeDecorationsMachine, {\n    input: {\n      rangeDecorations: rangeDecorations ?? [],\n      readOnly,\n      schema: editorActor.getSnapshot().context.schema,\n      slateEditor,\n      skipSetup: !editorActor.getSnapshot().matches({setup: 'setting up'}),\n    },\n  })\n  useSelector(rangeDecorationsActor, (s) => s.context.updateCount)\n  const decorate = useMemo(\n    () => createDecorate(rangeDecorationsActor),\n    [rangeDecorationsActor],\n  )\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'update read only',\n      readOnly,\n    })\n  }, [rangeDecorationsActor, readOnly])\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'range decorations updated',\n      rangeDecorations: rangeDecorations ?? [],\n    })\n  }, [rangeDecorationsActor, rangeDecorations])\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <RenderElement\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      leafProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => (\n      <RenderLeaf\n        {...leafProps}\n        readOnly={readOnly}\n        renderAnnotation={renderAnnotation}\n        renderChild={renderChild}\n        renderDecorator={renderDecorator}\n        renderPlaceholder={renderPlaceholder}\n      />\n    ),\n    [\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n    ],\n  )\n\n  const renderText = useCallback(\n    (props: RenderTextProps) => <RenderText {...props} />,\n    [],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(\n          slateEditor.children,\n          editorActor.getSnapshot().context.schema.block.name,\n        ),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'update selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [editorActor, propsSelection, slateEditor])\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      rangeDecorationsActor.send({\n        type: 'ready',\n      })\n\n      restoreSelectionFromProps()\n    })\n\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [rangeDecorationsActor, editorActor, restoreSelectionFromProps])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = slateEditor.selection\n          ? slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor: slateEditor,\n              range: slateEditor.selection,\n            })\n          : undefined\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = fromSlateValue(\n        slateEditor.children,\n        editorActor.getSnapshot().context.schema.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )\n      const ptRange = slateEditor.selection\n        ? slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor: slateEditor,\n            range: slateEditor.selection,\n          })\n        : null\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({\n        event,\n        value,\n        path,\n        schemaTypes: portableTextEditor.schemaTypes,\n      })\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        relayActor.send({type: 'loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const selection = editorActor.getSnapshot().context.selection\n              const position = selection ? {selection} : undefined\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                      validateFields: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            relayActor.send({type: 'done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, relayActor, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        relayActor.send({type: 'focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'update selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, slateEditor, portableTextEditor, relayActor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (position) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'mouse.click',\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        relayActor.send({type: 'blurred', event})\n      }\n    },\n    [relayActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for dragstart event')\n        return\n      }\n\n      editorActor.send({\n        type: 'dragstart',\n        origin: position,\n      })\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragstart',\n          originEvent: {\n            clientX: event.clientX,\n            clientY: event.clientY,\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drag',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragend',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragenter',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragover',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for drop event')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drop',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragleave',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      data-read-only={readOnly}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      renderText={renderText}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import React from 'react'\n\ntype ConstantRef<TConstant> = {constant: TConstant}\n\nexport default function useConstant<TConstant>(\n  factory: () => TConstant,\n): TConstant {\n  const ref = React.useRef<ConstantRef<TConstant>>(null)\n\n  if (!ref.current) {\n    ref.current = {constant: factory()}\n  }\n\n  return ref.current.constant\n}\n","import type React from 'react'\nimport {useEffect} from 'react'\nimport {Slate} from 'slate-react'\nimport type {EditorConfig} from '../editor'\nimport {stopActor} from '../internal-utils/stop-actor'\nimport useConstant from '../internal-utils/use-constant'\nimport {createInternalEditor} from './create-editor'\nimport {EditorActorContext} from './editor-actor-context'\nimport {EditorContext} from './editor-context'\nimport {PortableTextEditorContext} from './hooks/usePortableTextEditor'\nimport {PortableTextEditorSelectionProvider} from './hooks/usePortableTextEditorSelection'\nimport {\n  PortableTextEditor,\n  type PortableTextEditorProps,\n} from './PortableTextEditor'\nimport {RelayActorContext} from './relay-actor-context'\nimport {RouteEventsToChanges} from './route-events-to-changes'\n\n/**\n * @public\n */\nexport type EditorProviderProps = {\n  initialConfig: EditorConfig\n  children?: React.ReactNode\n}\n\n/**\n * @public\n * The EditorProvider component is used to set up the editor context and configure the Portable Text Editor.\n * @example\n * ```tsx\n * import {EditorProvider} from '@portabletext/editor'\n *\n * function App() {\n *  return (\n *    <EditorProvider initialConfig={{ ... }} >\n *      ...\n *    </EditorProvider>\n *  )\n * }\n *\n * ```\n * @group Components\n */\nexport function EditorProvider(props: EditorProviderProps) {\n  const {internalEditor, portableTextEditor} = useConstant(() => {\n    const internalEditor = createInternalEditor(props.initialConfig)\n    const portableTextEditor = new PortableTextEditor({\n      editor: internalEditor.editor,\n    } as unknown as PortableTextEditorProps)\n\n    return {internalEditor, portableTextEditor}\n  })\n\n  useEffect(() => {\n    const unsubscribers: Array<() => void> = []\n\n    for (const subscription of internalEditor.subscriptions) {\n      unsubscribers.push(subscription())\n    }\n\n    internalEditor.actors.editorActor.start()\n    internalEditor.actors.mutationActor.start()\n    internalEditor.actors.relayActor.start()\n    internalEditor.actors.syncActor.start()\n\n    return () => {\n      for (const unsubscribe of unsubscribers) {\n        unsubscribe()\n      }\n\n      stopActor(internalEditor.actors.editorActor)\n      stopActor(internalEditor.actors.mutationActor)\n      stopActor(internalEditor.actors.relayActor)\n      stopActor(internalEditor.actors.syncActor)\n    }\n  }, [internalEditor])\n\n  return (\n    <EditorContext.Provider value={internalEditor.editor}>\n      <RouteEventsToChanges\n        relayActor={internalEditor.actors.relayActor}\n        onChange={(change) => {\n          portableTextEditor.change$.next(change)\n        }}\n      />\n      <EditorActorContext.Provider value={internalEditor.actors.editorActor}>\n        <RelayActorContext.Provider value={internalEditor.actors.relayActor}>\n          <Slate\n            editor={internalEditor.editor._internal.slateEditor.instance}\n            initialValue={\n              internalEditor.editor._internal.slateEditor.initialValue\n            }\n          >\n            <PortableTextEditorContext.Provider value={portableTextEditor}>\n              <PortableTextEditorSelectionProvider\n                editorActor={internalEditor.actors.editorActor}\n              >\n                {props.children}\n              </PortableTextEditorSelectionProvider>\n            </PortableTextEditorContext.Provider>\n          </Slate>\n        </RelayActorContext.Provider>\n      </EditorActorContext.Provider>\n    </EditorContext.Provider>\n  )\n}\n"],"names":["EditorEventListener","props","$","_c","editor","useEditor","on","useEffectEvent","t0","subscription","unsubscribe","t1","useEffect","rootName","debug","debugWithName","name","namespace","enabled","EMPTY_MARKDEFS","VOID_CHILD_KEY","keepObjectEquality","object","keyMap","value","_key","isEqual","toSlateValue","schemaTypes","Array","isArray","map","block","_type","rest","textBlock","hasInlines","hasMissingStyle","style","hasMissingMarkDefs","markDefs","hasMissingChildren","children","child","cType","cKey","cRest","text","marks","__inline","Element","isElement","styles","fromSlateValue","textBlockType","Error","_cType","v","k","t","_i","blockValue","isEqualToEmptyEditor","undefined","length","Text","isText","join","getBlockPath","blockPath","from","Editor","nodes","at","match","n","blockIndex","getFocusBlock","selection","node","focus","path","slice","getFocusSpan","isTextSpan","getSelectedSpans","getSelectionStartBlock","selectionStartPoint","Range","start","getPointBlock","point","getSelectionEndBlock","selectionEndPoint","end","getFocusChild","focusBlock","focusBlockPath","childIndex","focusChild","Node","getPointChild","pointChild","getFirstBlock","firstBlockPath","getLastBlock","lastBlockPath","getNodeBlock","schema","isEditor","isBlockElement","elementToBlock","element","parent","mode","some","isInline","blockObjects","blockObject","isListItemActive","listItem","selectedBlocks","isTextBlock","every","isListBlock","isStyleActive","slateRangeToSelection","range","anchorBlock","anchor","anchorChild","offset","backward","isBackward","push","getEventPosition","editorActor","slateEditor","event","getSnapshot","matches","setup","eventNode","getEventNode","eventBlock","context","eventPositionBlock","getEventPositionBlock","eventSelection","getEventSelection","utils","eventSelectionFocusBlockKey","getBlockKeyFromSelectionPoint","DOMEditor","hasTarget","target","toSlateNode","firstBlock","firstBlockRect","toDOMNode","getBoundingClientRect","pageY","top","lastBlock","lastBlockRef","bottom","elementRect","height","Math","abs","getSlateRangeFromEvent","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","position","clientX","clientY","createRange","setStart","offsetNode","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","toSlatePath","isKeySegment","isVoid","childPath","findIndex","concat","moveRangeByOperation","operation","Point","transform","equals","normalizePoint","newPath","newOffset","blockKey","childKey","find","blk","cld","normalizeSelection","newAnchor","newFocus","IS_PROCESSING_REMOTE_CHANGES","WeakMap","KEY_TO_SLATE_ELEMENT","KEY_TO_VALUE_ELEMENT","SLATE_TO_PORTABLE_TEXT_RANGE","EditorActorContext","createContext","DropIndicator","Symbol","for","width","borderBottom","zIndex","RenderDefaultBlockObject","userSelect","RenderDefaultInlineObject","inlineObject","getDragSelection","snapshot","dragSelection","selectors","draggingCollapsedSelection","draggedTextBlock","draggedSpan","selectionStartBlock","selectionEndBlock","defaultKeyGenerator","randomKey","getByteHexTable","table","i","toString","whatwgRNG","rnds8","Uint8Array","getRandomValues","reduce","str","createEditorPriority","config","id","reference","corePriority","createCoreBlockElementBehaviorsConfig","key","onSetDragPositionBlock","behavior","defineBehavior","guard","dropFocusBlock","dragOrigin","draggedBlock","actions","type","effect","priority","importance","forward","useCoreBlockElementBehaviors","useContext","t2","behaviorConfigs","behaviorConfig","send","behaviorConfig_0","RenderBlockObject","dragPositionBlock","setDragPositionBlock","useState","blockObjectRef","useRef","useSlateStatic","selected","useSelected","legacySchemaType","useSelector","s","getLegacySchema","error","focused","isCollapsed","attributes","readOnly","renderBlock","editorElementRef","schemaType","RenderInlineObject","inlineObjectRef","inlineObjects","findPath","display","renderChild","annotations","RenderTextBlock","blockRef","legacySchema","legacyBlockSchemaType","renderStyle","legacyStyleSchemaType","renderListItem","legacyListItemSchemaType","lists","list","level","spellCheck","RenderElement","_temp","inlineObject_0","t3","blockObject_0","PortableTextEditorContext","usePortableTextEditor","forEachActor","actorRef","callback","Object","values","forEach","stopActor","persistedSnapshots","ref","observers","Set","systemSnapshot","system","stop","_snapshot","_processingStatus","converterJson","mimeType","serialize","portableTextConverter","converters","converter","originEvent","reason","deserialize","converterPortableText","blocks","sliceBlocks","data","JSON","stringify","parse","parsedBlocks","flatMap","parsedBlock","parseBlock","options","refreshKeys","validateFields","createConverterTextHtml","html","toHTML","onMissingComponent","components","unknownType","htmlToBlocks","portableText","keyGenerator","unstable_whitespaceOnPasteMode","createConverterTextPlain","span","inlineObjectType","title","blockObjectType","filter","textToHtml","escapeHtml","split","line","replace","entityMap","String","createCoreConverters","compileType","rawType","Schema","compile","types","get","createPlaceholderBlock","getActiveAnnotations","markState","mark","decorators","decorator","includes","getActiveDecorators","decoratorState","activeDecorators","activeDecorator","insertTextOperationImplementation","activeAnnotations","focusSpan","Transforms","insertText","state","markStateDecorators","insertNodes","isPortableTextSpan","isPortableTextBlock","def","getPreviousSpan","spanPath","previousSpan","reverse","Path","isBefore","getNextSpan","nextSpan","isAfter","withRemoteChanges","fn","prev","isChangingRemotely","set","IS_UDOING","IS_REDOING","withUndoing","isUndoing","setIsUndoing","withRedoing","isRedoing","setIsRedoing","defaultCompare","a","b","useEditorSelector","selector","compare","editorActorSnapshot","getEditorSnapshot","slateEditorInstance","_internal","instance","beta","createWithPortableTextMarkModel","apply","normalizeNode","nodeEntry","nextNode","mergeNodes","voids","setNodes","orphanedAnnotations","markDefKeys","newMarkDefs","markDef","has","add","operations","op","properties","newProperties","previousSelectionIsCollapsed","newSelectionIsCollapsed","newFocusSpan","movedToNextSpan","movedToPreviousSpan","_block","depth","previousSpanAnnotations","nextSpanAnnotations","annotationsEnding","annotation","atTheEndOfAnnotation","annotationsStarting","atTheStartOfAnnotation","nextSpanDecorators","isExpanded","spanHasAnnotations","deletingFromTheEnd","deletingAllText","previousSpanHasSameAnnotation","nextSpanHasSameAnnotation","withoutNormalizing","onChange","targetBlock","targetPath","oldDefs","uniq","removeDecoratorOperationImplementation","hanging","eMark","lonelyEmptySpan","existingMarksWithoutDecorator","existingMark","cloneDiff","diff2","patch","CURRENT_UNDO_STEP","withUndoStep","current","undoStepId","getCurrentUndoStepId","SAVING","REMOTE_PATCHES","UNDO_STEP_LIMIT","isSaving","getRemotePatches","createWithUndoRedo","previousSnapshot","remotePatches","previousUndoStepId","subscriptions","sub","patches","reset","origin","history","undos","redos","splice","time","Date","step","lastOp","overwrite","shouldOverwrite","save","currentUndoStepId","merge","shouldMerge","newStep","createSelectOperation","timestamp","shift","shouldClear","historyUndoOperationImplementation","otherPatches","item","transformedOperations","flatten","transformOperation","reversedOperations","Operation","inverse","withoutSaving","err","deselect","pop","historyRedoOperationImplementation","transformedOperation","insertBlockIndex","items","adjustBlockPath","unsetBlockIndex","operationTargetBlock","findOperationTargetBlock","parsePatch","diffPatch","adjustOffsetBy","changedOffset","utf8Start1","diffs","diff","index","diffType","DIFF_INSERT","DIFF_DELETE","DIFF_EQUAL","dType","currentFocus","currentAnchor","addAnnotationOperationImplementation","parsedAnnotation","parseAnnotation","paths","markDefPath","markDefPaths","annotationKey","unshift","existingSameTypeAnnotations","removeAnnotationOperationImplementation","potentialAnnotations","selectedChild","selectedChildPath","annotationToRemove","previousSpansWithSameAnnotation","nextSpansWithSameAnnotation","marksWithoutAnnotation","blockSetOperationImplementation","location","filteredProps","updatedBlock","slateBlock","blockUnsetOperationImplementation","propsToRemove","prop","updatedTextBlock","omit","propsToSet","updatedBlockObject","decoratorAddOperationImplementation","manualAnchor","blockOffset","direction","manualFocus","manualSelection","editorSelection","anchorOffset","selectionPoint","focusOffset","newValue","newSelection","offsets","trimmedSelection","newRange","splitTextNodes","isRange","existingMarks","deleteOperationImplementation","anchorBlockKey","focusBlockKey","anchorBlockPath","removeNodes","delete","unit","insertInlineObjectOperationImplementation","parsedInlineObject","parseInlineObject","focusTextBlock","insertSpanOperationImplementation","insertBlockOperationImplementation","fragment","placement","select","insertBlock","startBlock","startBlockPath","endBlock","endBlockPath","nextPath","selectionBefore","insertFragment","currentSelection","endBlockEndPoint","adjustedSelection","next","endBlockStartPoint","splitNodes","moveBackwardOperationImplementation","move","distance","moveBlockOperationImplementation","to","moveNodes","moveForwardOperationImplementation","selectOperationImplementation","behaviorOperationImplementations","performOperation","message","CURRENT_OPERATION_ID","withApplyingBehaviorOperations","getCurrentOperationId","isApplyingBehaviorOperations","createWithEventListeners","maxBlocks","editorDelete","behaviorEvent","deleteBackward","deleteForward","insertBreak","insertData","dataTransfer","insertSoftBreak","redo","setFragmentData","undo","createWithMaxBlocks","rows","createWithObjectKeys","existingKeys","descendants","entry","createApplyPatch","changed","insertPatch","unsetPatch","setPatch","diffMatchPatch","findBlock","findBlockChild","diffMatchPatchApplyPatches","allowExceedingIndices","cleanupEfficiency","makeDiff","blocksToInsert","targetBlockIndex","normalizedIdx","editorWasEmptyBefore","targetChild","childrenToInsert","childInsertPath","oldText","newText","propPath","propEntry","newNode","applyAll","reservedProps","nextRest","prevChildren","prevRest","blockNode","newVal","previousSelection","_","pteCreateTextBlock","newKeys","keys","removedProperties","property","unsetNodes","isMatch","isKeyedSegment","insertTextPatch","beforeValue","textChild","isSpan","prevBlock","prevChild","prevText","removeTextPatch","beforeBlock","prevTextChild","setNodePatch","setNode","omitBy","isUndefined","keyName","val","indexOf","insertNodePatch","targetKey","insert","setIfMissing","splitNodePatch","splitBlock","oldBlock","targetValue","unset","splitSpan","targetSpans","removeNodePatch","spanToRemove","mergeNodePatch","newBlock","updatedSpan","removedSpan","moveNodePatch","childToInsert","PATCHING","withoutPatching","isPatching","createWithPatches","relayActor","previousChildren","applyPatch","bufferedPatches","handleBufferedRemotePatches","normalize","handlePatches","p","editorWasEmpty","editorIsEmpty","debugVerbose","previousValue","operationId","createWithPlaceholderBlock","insertNode","createWithPortableTextBlockStyle","defaultStyle","SlateText","createWithPortableTextSelections","prevSelection","emitPortableTextSelection","ptRange","existing","createWithSchemaTypes","obj","createWithUtils","getMarkState","selectedSpans","marksWithoutAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","pluginUpdateMarkState","isEditorNode","isTextBlockNode","isTypedObject","isSpanNode","isPartialSpanNode","isObjectNode","getBlock","root","getNode","getSpan","getParent","parentPath","applyOperationToPortableText","draft","createDraft","e","finishDraft","applyOperationToPortableTextDraft","insertedNode","before","after","prevPath","previous","isAncestor","truePath","newParent","newIndex","valueBefore","valueAfter","hasOwnProperty","newTextBlockNode","newSpanNode","pluginUpdateValue","withPlugins","withObjectKeys","withSchemaTypes","withPatches","withMaxBlocks","withUndoRedo","withPortableTextMarkModel","withPortableTextBlockStyle","withPlaceholderBlock","withUtils","withPortableTextSelections","createSlateEditor","withReact","createEditor","initialValue","addAnnotationOnCollapsedSelection","caretWordSelection","raise","coreAnnotationBehaviors","IS_MAC","test","navigator","userAgent","modifiers","alt","control","meta","aliases","break","cmd","command","ctl","ctrl","del","down","esc","ins","left","mod","opt","option","return","right","space","spacebar","up","win","windows","keyCodes","isHotkey","hotkey","compareHotkey","parseHotkey","parsedHotkey","altKey","ctrlKey","metaKey","shiftKey","hotkeySegments","rawHotkeySegment","optional","endsWith","hotkeySegment","toKeyName","modifier","alias","code","TypeError","keyCode","toKeyCode","toLowerCase","toUpperCase","charCodeAt","arrowDownOnLonelyBlockObject","focusBlockObject","nextBlock","arrowUpOnLonelyBlockObject","previousBlock","breakingBlockObject","clickingAboveLonelyBlockObject","clickingBelowLonelyBlockObject","deletingEmptyTextBlockAfterBlockObject","selectionCollapsed","isEmptyTextBlock","deletingEmptyTextBlockBeforeBlockObject","coreBlockObjectBehaviors","coreDecoratorBehaviors","strongShortcut","emShortcut","underlineShortcut","codeShortcut","getCompoundClientRect","DOMRect","elements","firstRect","rect","min","max","coreDndBehaviors","dom","selectingEntireBlocks","draggedDomNodes","blockNodes","getBlockNodes","childNodes","getChildNodes","dragGhost","createElement","clonedBlockNodes","cloneNode","HTMLElement","appendChild","customGhost","querySelector","replaceChildren","setAttribute","boxSizing","body","customGhostRect","x","y","setDragGhost","ghost","blocksDomRect","clonedChildNodes","childrenDomRect","dropPosition","droppingOnDragOrigin","draggingEntireBlocks","draggedBlocks","breakingAtTheEndOfTextBlock","atTheEndOfBlock","focusListItem","focusLevel","breakingAtTheStartOfTextBlock","focusDecorators","focusAnnotations","breakingEntireDocument","firstBlockStartPoint","lastBlockEndPoint","breakingEntireBlocks","startBlockStartPoint","coreInsertBreakBehaviors","MAX_LIST_LEVEL","clearListOnBackspace","unindentListOnBackspace","clearListOnEnter","focusListBlock","indentListOnTab","selectedListBlocks","selectedListBlock","unindentListOnShiftTab","coreListBehaviors","coreBehaviorsConfig","createEditorDom","sendBack","childNode","setDragImage","abstractAnnotationBehaviors","isActiveAnnotation","abstractDecoratorBehaviors","isActiveDecorator","blockOffsetsToSelection","abstractDeleteBehaviors","abstractInsertBehaviors","getFocusTextBlock","keyIs","lineBreak","abstractKeyboardBehaviors","abstractListItemBehaviors","selectedTextBlocks","getSelectedTextBlocks","isActiveListItem","abstractMoveBehaviors","getPreviousBlock","getNextBlock","abstractSelectBehaviors","getBlockEndPoint","getBlockStartPoint","abstractSplitBehaviors","getSelectionStartPoint","getSelectionEndPoint","blockEndPoint","newTextBlockSelection","newTextBlock","isSelectionCollapsed","abstractStyleBehaviors","isActiveStyle","raiseDeserializationSuccessOrFailure","success","failures","getData","deserializeEvent","failure","raiseSerializationSuccessOrFailure","serializeEvents","serializeEvent","abstractBehaviors","setData","textRuns","getTextBlockText","textRun","isSyntheticBehaviorEvent","isCustomBehaviorEvent","isNativeBehaviorEvent","isAbstractBehaviorEvent","abstractBehaviorEventTypes","nativeBehaviorEventTypes","startsWith","eventCategory","performEvent","behaviors","remainingEventBehaviors","nativeEvent","eventBehaviors","listenedNamespace","eventNamespace","preventDefault","guardSnapshot","nativeEventPrevented","defaultBehaviorOverwritten","eventBehaviorIndex","eventBehavior","shouldRun","actionSet","actionsSnapshot","action","sortByPriority","itemsWithPriority","itemsWithoutPriority","itemsByPriorityId","Map","graph","inDegree","ensureNode","addEdge","fromId","toId","visited","refId","queue","degree","result","currentId","currentItem","neighborId","newDegree","createEditorSnapshot","editorMachine","events","emitted","input","tags","assign","assertEvent","enqueueActions","enqueue","emit","pendingEvents","pendingIncomingPatchesEvents","handle blur","blur","handle focus","handle behavior event","self","guards","slate is busy","createMachine","initialReadOnly","states","initial","exit","dragstart","internalDrag","always","parentNode","removeChild","dragend","drop","pristine","idle","normalizing","dirty","createLegacySchema","portableTextType","blockType","of","findBlockType","childrenField","fields","field","ofType","spanType","memberType","inlineObjectTypes","blockObjectTypes","resolveEnabledStyles","resolveEnabledDecorators","resolveEnabledListItems","styleField","btField","textStyles","listField","listItems","defineSchema","definition","temporaryImageName","temporaryUrlName","temporaryObjectNames","image","url","objectNames","defaultObjectTitles","legacySchemaToEditorSchema","jsonType","compileSchemaDefinitionToLegacySchema","defineType","portableTextSchema","defineField","startCase","SanitySchema","pteSchema","mutationMachine","bulk","pendingMutations","lastBulk","pendingPatchEvents","actors","fromCallback","originalApply","interval","setInterval","process","env","NODE_ENV","clearInterval","is read-only","stateIn","typing","slate is normalizing","isNormalizing","delays","invoke","src","reenter","mutations","and","not","createEditableAPI","toggleMark","toggleList","toggleBlockStyle","isMarkActive","slateSelection","descendant","insertChild","focusChildPath","focusNode","hasBlockStyle","hasListStyle","findByPath","slatePath","ptBlock","ptChild","findDOMNode","ReactEditor","spans","isAnnotationActive","annotationType","addAnnotation","SlateElement","removeAnnotation","getSelection","getValue","isCollapsedSelection","isExpandedSelection","getFragment","isSelectionsOverlapping","selectionA","selectionB","rangeA","rangeB","selectionMarkDefs","accMarkDefs","markKey","relayMachine","validateValue","resolution","valid","validChildTypes","validBlockTypes","description","i18n","isPlainObject","currentBlockTypeName","expectedTypeName","typeName","newSpan","autoResolve","allUsedMarks","unusedMarkDefs","markDefKey","m","orphanedMarks","dec","spanChildren","orphaned","cMrk","cIndex","newChild","childType","syncValueCallback","streamBlocks","syncValueLogic","syncMachine","initialValueSynced","pendingValue","initial value synced","is busy","editable","isProcessingLocalChanges","isChanging","isBusy","is empty value","is empty array","is new value","value changed while syncing","pending value equals previous value","busy","syncing","updateValue","doneSyncing","isChanged","isValid","hadSelection","childrenLength","slateValueFromProps","Promise","resolve","removeExtraBlocks","currentBlock","currentBlockIndex","getStreamedBlocks","slateValue","blockChanged","blockValid","syncBlock","setTimeout","hasChanges","validationValue","validation","_updateBlock","_replaceBlock","selectionFocusOnBlock","oldBlockChildrenLength","currentBlockChild","currentBlockChildIndex","oldBlockChild","isChildChanged","isTextChanged","createInternalEditor","createActor","editorConfigToMachineInput","mutationActor","syncActor","createActors","registerBehavior","behaviorConfigWithPriority","listener","compileSchemasFromEditorConfig","schemaDefinition","subscribe","PortableTextEditorSelectionContext","usePortableTextEditorSelection","PortableTextEditorSelectionProvider","setSelection","startTransition","RelayActorContext","RouteEventsToChanges","change","handleChange","change_0","eventToChange","isLoading","PortableTextEditor","Component","displayName","change$","Subject","unsubscribers","constructor","Number","parseInt","componentDidMount","relayActorSubscription","componentDidUpdate","prevProps","editorRef","componentWillUnmount","setEditable","render","legacyPatches","incomingPatches$","patches$","blockStyle","listStyle","isObjectPath","_editor","isChildObjectEditPath","RoutePatchesObservableToEditorActor","payload","RenderSpan","spanRef","portableTextEditor","blockSelected","setFocused","setSelected","useMemo","leaf","decoratorSchemaTypes","annotationMarkDefs","shouldTrackSelectionAndFocus","sel","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","intersectsNode","onBlur","onFocus","onSelection","legacyDecoratorSchemaType","renderDecorator","annotationMarkDef","legacyAnnotationSchemaType","renderAnnotation","_child","PLACEHOLDER_STYLE","pointerEvents","RenderLeaf","renderedSpan","renderPlaceholder","placeholder","rangeDecoration","component","RenderText","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","cat","possibleMark","possibleCommand","slateOperationCallback","rangeDecorationsMachine","pendingRangeDecorations","rangeDecorations","decoratedRanges","rangeDecorationState","slateRange","onMoved","decoratedRange","newRangeSelection","updateCount","has pending range decorations","has range decorations","has different decorations","existingRangeDecorations","newRangeDecorations","not read only","should skip setup","skipSetup","createDecorate","rangeDecorationActor","intersection","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDragStart","onDrag","onDragEnd","onDragEnter","onDragOver","onDrop","onDragLeave","propsSelection","scrollSelectionIntoView","restProps","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","useSlate","rangeDecorationsActor","useActorRef","decorate","renderElement","eProps","renderLeaf","leafProps","renderText","restoreSelectionFromProps","normalizedSelection","o","onReady","onInvalidValue","onValueChanged","handleCopy","clipboardData","stopPropagation","handleCut","handlePaste","onPasteResult","then","parseBlocks","catch","finally","handleOnFocus","isDefaultPrevented","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","addEventListener","removeEventListener","handleDragStart","handleDrag","handleDragEnd","handleDragEnter","handleDragOver","handleDrop","handleDragLeave","SlateEditable","className","useConstant","factory","React","constant","EditorProvider","initialConfig","internalEditor","internalEditor_0","portableTextEditor_0","t4","t5","t6","t7","t8","t9","t10"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcO,SAAAA,oBAAAC,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA,GAGLC,SAAeC,UACfC,GAAAA,KAAWC,eAAeN,MAAKK,EAAG;AAACE,MAAAA;AAAAN,IAAAE,CAAAA,MAAAA,UAAAF,SAAAI,MAEzBE,KAAAA,MAAA;AACR,UAAAC,eAAqBL,OAAME,GAAI,KAAKA,EAAE;AAAC,WAAA,MAAA;AAGrCG,mBAAYC,YAAa;AAAA,IAAC;AAAA,EAE7BR,GAAAA,OAAAE,QAAAF,OAAAI,IAAAJ,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AAAAS,MAAAA;AAAAT,SAAAA,SAAAE,UAAEO,MAACP,MAAM,GAACF,OAAAE,QAAAF,OAAAS,MAAAA,KAAAT,EAAA,CAAA,GANXU,UAAUJ,IAMPG,EAAQ,GAAC;AAAA;ACxBd,MAAME,WAAW;AAEFC,QAAMD,QAAQ;AACtB,SAASE,cAAcC,MAA8B;AAC1D,QAAMC,YAAY,GAAGJ,QAAQ,GAAGG,IAAI;AAChCF,SAAAA,WAASA,QAAMI,QAAQD,SAAS,IAC3BH,QAAMG,SAAS,IAEjBH,QAAMD,QAAQ;AACvB;ACAaM,MAEAC,iBAAiB;AAM9B,SAASC,mBACPC,QACAC,QACA;AACMC,QAAAA,QAAQD,OAAOD,OAAOG,IAAI;AAC5BD,SAAAA,SAASE,QAAQJ,QAAQE,KAAK,IACzBA,SAETD,OAAOD,OAAOG,IAAI,IAAIH,QACfA;AACT;AAEO,SAASK,aACdH,OACA;AAAA,EAACI;AAAwC,GACzCL,SAA8B,CAAA,GAChB;AACd,SAAIC,SAASK,MAAMC,QAAQN,KAAK,IACvBA,MAAMO,IAAKC,CAAU,UAAA;AACpB,UAAA;AAAA,MAACC;AAAAA,MAAOR;AAAAA,MAAM,GAAGS;AAAAA,IAAAA,IAAQF;AAE/B,QADuBA,SAASA,MAAMC,UAAUL,YAAYI,MAAMhB,MAC9C;AAClB,YAAMmB,YAAYH;AAClB,UAAII,aAAa;AACXC,YAAAA,kBAAkB,OAAOF,UAAUG,QAAU,KAC7CC,qBAAqB,OAAOJ,UAAUK,WAAa,KACnDC,qBAAqB,OAAON,UAAUO,WAAa,KAEnDA,YAAYP,UAAUO,YAAY,CAAIX,GAAAA,IAAKY,CAAU,UAAA;AACnD,cAAA;AAAA,UAACV,OAAOW;AAAAA,UAAOnB,MAAMoB;AAAAA,UAAM,GAAGC;AAAAA,QAAAA,IAASH;AAM7C,eAAIC,UAAU,UACZR,aAAa,IACNf,mBACL;AAAA,UACEY,OAAOW;AAAAA,UACPnB,MAAMoB;AAAAA,UACNH,UAAU,CACR;AAAA,YACEjB,MAAML;AAAAA,YACNa,OAAO;AAAA,YACPc,MAAM;AAAA,YACNC,OAAO,CAAA;AAAA,UAAA,CACR;AAAA,UAEHxB,OAAOsB;AAAAA,UACPG,UAAU;AAAA,QAAA,GAEZ1B,MACF,KAGKoB;AAAAA,MAAAA,CACR;AAGC,aAAA,CAACN,mBACD,CAACE,sBACD,CAACE,sBACD,CAACL,cACDc,UAAQC,UAAUnB,KAAK,IAGhBA,SAGLK,oBACFH,KAAKI,QAAQV,YAAYwB,OAAO,CAAC,EAAEpC,OAE9BK,mBAAmB;AAAA,QAACY;AAAAA,QAAOR;AAAAA,QAAM,GAAGS;AAAAA,QAAMQ;AAAAA,SAAWnB,MAAM;AAAA,IAAA;AAEpE,WAAOF,mBACL;AAAA,MACEY;AAAAA,MACAR;AAAAA,MACAiB,UAAU,CACR;AAAA,QACEjB,MAAML;AAAAA,QACNa,OAAO;AAAA,QACPc,MAAM;AAAA,QACNC,OAAO,CAAA;AAAA,MAAA,CACR;AAAA,MAEHxB,OAAOU;AAAAA,OAETX,MACF;AAAA,EACD,CAAA,IAEI,CAAE;AACX;AAEO,SAAS8B,eACd7B,OACA8B,eACA/B,SAAgE,CAAA,GAC3C;AACdC,SAAAA,MAAMO,IAAKC,CAAU,UAAA;AACpB,UAAA;AAAA,MAACP;AAAAA,MAAMQ;AAAAA,IAAAA,IAASD;AAClB,QAAA,CAACP,QAAQ,CAACQ;AACN,YAAA,IAAIsB,MAAM,mBAAmB;AAGnCtB,QAAAA,UAAUqB,iBACV,cAActB,SACdH,MAAMC,QAAQE,MAAMU,QAAQ,KAC5BjB,MACA;AACA,UAAIW,aAAa;AACjB,YAAMM,WAAWV,MAAMU,SAASX,IAAKY,CAAU,UAAA;AACvC,cAAA;AAAA,UAACV,OAAOuB;AAAAA,QAAAA,IAAUb;AACpB,YAAA,WAAWA,SAASa,WAAW,QAAQ;AAC5B,uBAAA;AACP,gBAAA;AAAA,YACJhC,OAAOiC;AAAAA,YACPhC,MAAMiC;AAAAA,YACNzB,OAAO0B;AAAAA,YACPV,UAAUW;AAAAA,YACVlB,UAAUvC;AAAAA,YACV,GAAG+B;AAAAA,UAAAA,IACDS;AACJ,iBAAOtB,mBACL;AAAA,YAAC,GAAGa;AAAAA,YAAM,GAAGuB;AAAAA,YAAGhC,MAAMiC;AAAAA,YAAazB,OAAO0B;AAAAA,aAC1CpC,MACF;AAAA,QAAA;AAEKoB,eAAAA;AAAAA,MAAAA,CACR;AACD,aAAKP,aAGEf,mBACL;AAAA,QAAC,GAAGW;AAAAA,QAAOU;AAAAA,QAAUjB;AAAAA,QAAMQ;AAAAA,MAAAA,GAC3BV,MACF,IALSS;AAAAA,IAAAA;AAOL6B,UAAAA,aAAa,WAAW7B,SAASA,MAAMR;AAC7C,WAAOH,mBACL;AAAA,MAACI;AAAAA,MAAMQ;AAAAA,MAAO,GAAI,OAAO4B,cAAe,WAAWA,aAAa,CAAA;AAAA,OAChEtC,MACF;AAAA,EAAA,CACD;AACH;AAEgBuC,SAAAA,qBACdpB,UACAd,aACS;AAEPc,SAAAA,aAAaqB,UACZrB,YAAYb,MAAMC,QAAQY,QAAQ,KAAKA,SAASsB,WAAW,KAC3DtB,YACCb,MAAMC,QAAQY,QAAQ,KACtBA,SAASsB,WAAW,KACpBd,UAAQC,UAAUT,SAAS,CAAC,CAAC,KAC7BA,SAAS,CAAC,EAAET,UAAUL,YAAYI,MAAMhB,QACxC,WAAW0B,SAAS,CAAC,KACrBA,SAAS,CAAC,EAAEJ,UAAUV,YAAYwB,OAAO,CAAC,EAAEpC,QAC5C,EAAE,cAAc0B,SAAS,CAAC,MAC1Bb,MAAMC,QAAQY,SAAS,CAAC,EAAEA,QAAQ,KAClCA,SAAS,CAAC,EAAEA,SAASsB,WAAW,KAChCC,KAAKC,OAAOxB,SAAS,CAAC,EAAEA,SAAS,CAAC,CAAC,KACnCA,SAAS,CAAC,EAAEA,SAAS,CAAC,EAAET,UAAU,UAClC,CAACS,SAAS,CAAC,EAAEA,SAAS,CAAC,EAAEM,OAAOmB,KAAK,EAAE,KACvCzB,SAAS,CAAC,EAAEA,SAAS,CAAC,EAAEK,SAAS;AAEvC;ACvLO,SAASqB,aAAa;AAAA,EAC3BhE;AAAAA,EACAqB;AAIF,GAAyB;AACjB,QAAA,CAAA,EAAG4C,SAAS,IAAIxC,MAAMyC,KAC1BC,OAAOC,MAAMpE,QAAQ;AAAA,IACnBqE,IAAI,CAAE;AAAA,IACNC,OAAQC,CAAMA,MAAAA,EAAElD,SAASA;AAAAA,EAC1B,CAAA,CACH,EAAEgD,GAAG,CAAC,KAAK,CAACV,QAAWA,MAAS,GAE1Ba,aAAaP,WAAWI,GAAG,CAAC;AAElC,MAAIG,eAAeb;AAInB,WAAO,CAACa,UAAU;AACpB;AAuBO,SAASC,cAAc;AAAA,EAC5BzE;AAGF,GAAsD;AACpD,MAAI,CAACA,OAAO0E;AACH,WAAA,CAACf,QAAWA,MAAS;AAG1B,MAAA;AACF,WACEQ,OAAOQ,KAAK3E,QAAQA,OAAO0E,UAAUE,MAAMC,KAAKC,MAAM,GAAG,CAAC,CAAC,KAAK,CAC9DnB,QACAA,MAAS;AAAA,EAAA,QAGP;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEO,SAASoB,aAAa;AAAA,EAC3B/E;AAGF,GAAkE;AAChE,MAAI,CAACA,OAAO0E;AACH,WAAA,CAACf,QAAWA,MAAS;AAG1B,MAAA;AACI,UAAA,CAACgB,MAAME,IAAI,IAAIV,OAAOQ,KAAK3E,QAAQA,OAAO0E,UAAUE,MAAMC,IAAI;AAEhE7E,QAAAA,OAAOgF,WAAWL,IAAI;AACjB,aAAA,CAACA,MAAME,IAAI;AAAA,EAAA,QAEd;AACC,WAAA,CAAClB,QAAWA,MAAS;AAAA,EAAA;AAGvB,SAAA,CAACA,QAAWA,MAAS;AAC9B;AAEO,SAASsB,iBAAiB;AAAA,EAC/BjF;AAGF,GAAgD;AAC9C,MAAI,CAACA,OAAO0E;AACV,WAAO,CAAE;AAGP,MAAA;AACF,WAAOjD,MAAMyC,KACXC,OAAOC,MAAMpE,QAAQ;AAAA,MACnBqE,IAAIrE,OAAO0E;AAAAA,MACXJ,OAAQK,CAAAA,SAAS3E,OAAOgF,WAAWL,IAAI;AAAA,IAAA,CACxC,CACH;AAAA,EAAA,QACM;AACN,WAAO,CAAE;AAAA,EAAA;AAEb;AAEO,SAASO,uBAAuB;AAAA,EACrClF;AAGF,GAAsD;AACpD,MAAI,CAACA,OAAO0E;AACH,WAAA,CAACf,QAAWA,MAAS;AAG9B,QAAMwB,sBAAsBC,MAAMC,MAAMrF,OAAO0E,SAAS;AAExD,SAAOY,cAAc;AAAA,IAACtF;AAAAA,IAAQuF,OAAOJ;AAAAA,EAAAA,CAAoB;AAC3D;AAEO,SAASK,qBAAqB;AAAA,EACnCxF;AAGF,GAAsD;AACpD,MAAI,CAACA,OAAO0E;AACH,WAAA,CAACf,QAAWA,MAAS;AAG9B,QAAM8B,oBAAoBL,MAAMM,IAAI1F,OAAO0E,SAAS;AAEpD,SAAOY,cAAc;AAAA,IAACtF;AAAAA,IAAQuF,OAAOE;AAAAA,EAAAA,CAAkB;AACzD;AAEO,SAASH,cAAc;AAAA,EAC5BtF;AAAAA,EACAuF;AAIF,GAAsD;AAChD,MAAA;AACF,UAAM,CAAC3D,KAAK,IAAIuC,OAAOQ,KAAK3E,QAAQuF,MAAMV,KAAKC,MAAM,GAAG,CAAC,CAAC,KAAK,CAC7DnB,QACAA,MAAS;AAEX,WAAO/B,QAAQ,CAACA,OAAO2D,MAAMV,KAAKC,MAAM,GAAG,CAAC,CAAC,IAAI,CAACnB,QAAWA,MAAS;AAAA,EAAA,QAChE;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEO,SAASgC,cAAc;AAAA,EAC5B3F;AAGF,GAAsD;AACpD,QAAM,CAAC4F,YAAYC,cAAc,IAAIpB,cAAc;AAAA,IAACzE;AAAAA,EAAAA,CAAO,GACrD8F,aAAa9F,OAAO0E,WAAWE,MAAMC,KAAKR,GAAG,CAAC;AAEpD,MAAI,CAACuB,cAAc,CAACC,kBAAkBC,eAAenC;AAC5C,WAAA,CAACA,QAAWA,MAAS;AAG1B,MAAA;AACF,UAAMoC,aAAaC,KAAKzD,MAAMqD,YAAYE,UAAU;AAE7CC,WAAAA,aACH,CAACA,YAAY,CAAC,GAAGF,gBAAgBC,UAAU,CAAC,IAC5C,CAACnC,QAAWA,MAAS;AAAA,EAAA,QACnB;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEA,SAASsC,cAAc;AAAA,EACrBjG;AAAAA,EACAuF;AAIF,GAAsD;AACpD,QAAM,CAAC3D,OAAOqC,SAAS,IAAIqB,cAAc;AAAA,IAACtF;AAAAA,IAAQuF;AAAAA,EAAM,CAAA,GAClDO,aAAaP,MAAMV,KAAKR,GAAG,CAAC;AAElC,MAAI,CAACzC,SAAS,CAACqC,aAAa6B,eAAenC;AAClC,WAAA,CAACA,QAAWA,MAAS;AAG1B,MAAA;AACF,UAAMuC,aAAaF,KAAKzD,MAAMX,OAAOkE,UAAU;AAExCI,WAAAA,aACH,CAACA,YAAY,CAAC,GAAGjC,WAAW6B,UAAU,CAAC,IACvC,CAACnC,QAAWA,MAAS;AAAA,EAAA,QACnB;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEO,SAASwC,cAAc;AAAA,EAC5BnG;AAGF,GAAsD;AAChDA,MAAAA,OAAOsC,SAASsB,WAAW;AACtB,WAAA,CAACD,QAAWA,MAAS;AAIxByC,QAAAA,iBADajC,OAAOkB,MAAMrF,QAAQ,CAAA,CAAE,EACR6E,KAAKR,GAAG,CAAC;AAEvC,MAAA;AACF,WAAO+B,mBAAmBzC,SACrBQ,OAAOQ,KAAK3E,QAAQ,CAACoG,cAAc,CAAC,KAAK,CAACzC,QAAWA,MAAS,IAC/D,CAACA,QAAWA,MAAS;AAAA,EAAA,QACnB;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEO,SAAS0C,aAAa;AAAA,EAC3BrG;AAGF,GAAsD;AAChDA,MAAAA,OAAOsC,SAASsB,WAAW;AACtB,WAAA,CAACD,QAAWA,MAAS;AAIxB2C,QAAAA,gBADYnC,OAAOuB,IAAI1F,QAAQ,CAAA,CAAE,EACP6E,KAAKR,GAAG,CAAC;AAErC,MAAA;AACF,WAAOiC,kBAAkB3C,SACpBQ,OAAOQ,KAAK3E,QAAQ,CAACsG,aAAa,CAAC,KAAK,CAAC3C,QAAWA,MAAS,IAC9D,CAACA,QAAWA,MAAS;AAAA,EAAA,QACnB;AACC,WAAA,CAACA,QAAWA,MAAS;AAAA,EAAA;AAEhC;AAEO,SAAS4C,aAAa;AAAA,EAC3BvG;AAAAA,EACAwG;AAAAA,EACA7B;AAKF,GAAG;AACGR,MAAAA,OAAOsC,SAAS9B,IAAI;AACtB;AAGF,MAAI+B,eAAe;AAAA,IAAC1G;AAAAA,IAAQwG;AAAAA,KAAS7B,IAAI;AACvC,WAAOgC,eAAe;AAAA,MAACH;AAAAA,MAAQI,SAASjC;AAAAA,IAAAA,CAAK;AAG/C,QAAMkC,SAASpF,MAAMyC,KACnBC,OAAOC,MAAMpE,QAAQ;AAAA,IACnB8G,MAAM;AAAA,IACNzC,IAAI,CAAE;AAAA,IACNC,OAAQC,OACNmC,eAAe;AAAA,MAAC1G;AAAAA,MAAQwG;AAAAA,IAAAA,GAASjC,CAAC,KAClCA,EAAEjC,SAASyE,KAAMxE,CAAUA,UAAAA,MAAMlB,SAASsD,KAAKtD,IAAI;AAAA,EACtD,CAAA,CACH,EACGgD,GAAG,CAAC,GACHA,GAAG,CAAC;AAER,SAAOvB,UAAQC,UAAU8D,MAAM,IAC3BF,eAAe;AAAA,IACbH;AAAAA,IACAI,SAASC;AAAAA,EACV,CAAA,IACDlD;AACN;AAEA,SAASgD,eAAe;AAAA,EACtBH;AAAAA,EACAI;AAIF,GAAG;AACM3D,SAAAA,eAAe,CAAC2D,OAAO,GAAGJ,OAAO5E,MAAMhB,IAAI,GAAGyD,GAAG,CAAC;AAC3D;AAEA,SAASqC,eACP;AAAA,EAAC1G;AAAAA,EAAQwG;AAA+D,GACxE7B,MACiB;AAEf7B,SAAAA,UAAQC,UAAU4B,IAAI,KACtB,CAAC3E,OAAOgH,SAASrC,IAAI,MACpB6B,OAAO5E,MAAMhB,SAAS+D,KAAK9C,SAC1B2E,OAAOS,aAAaF,KACjBG,CAAgBA,gBAAAA,YAAYtG,SAAS+D,KAAK9C,KAC7C;AAEN;AAEO,SAASsF,iBAAiB;AAAA,EAC/BnH;AAAAA,EACAoH;AAIF,GAAY;AACV,MAAI,CAACpH,OAAO0E;AACH,WAAA;AAGT,QAAM2C,iBAAiB,CACrB,GAAGlD,OAAOC,MAAMpE,QAAQ;AAAA,IACtBqE,IAAIrE,OAAO0E;AAAAA,IACXJ,OAAQK,CAAAA,SAAS3E,OAAOsH,YAAY3C,IAAI;AAAA,EAAA,CACzC,CAAC;AAGJ,SAAI0C,eAAezD,SAAS,IACnByD,eAAeE,MACpB,CAAC,CAAC5C,IAAI,MAAM3E,OAAOwH,YAAY7C,IAAI,KAAKA,KAAKyC,aAAaA,QAC5D,IAGK;AACT;AAEO,SAASK,cAAc;AAAA,EAC5BzH;AAAAA,EACAkC;AAIF,GAAY;AACV,MAAI,CAAClC,OAAO0E;AACH,WAAA;AAGT,QAAM2C,iBAAiB,CACrB,GAAGlD,OAAOC,MAAMpE,QAAQ;AAAA,IACtBqE,IAAIrE,OAAO0E;AAAAA,IACXJ,OAAQK,CAAAA,SAAS3E,OAAOsH,YAAY3C,IAAI;AAAA,EAAA,CACzC,CAAC;AAGJ,SAAI0C,eAAezD,SAAS,IACnByD,eAAeE,MAAM,CAAC,CAAC5C,IAAI,MAAMA,KAAKzC,UAAUA,KAAK,IAGvD;AACT;AAEO,SAASwF,sBAAsB;AAAA,EACpClB;AAAAA,EACAxG;AAAAA,EACA2H;AAKF,GAAoB;AACZ,QAAA,CAACC,WAAW,IAAItC,cAAc;AAAA,IAClCtF;AAAAA,IACAuF,OAAOoC,MAAME;AAAAA,EAAAA,CACd,GACK,CAACjC,UAAU,IAAIN,cAAc;AAAA,IACjCtF;AAAAA,IACAuF,OAAOoC,MAAM/C;AAAAA,EAAAA,CACd;AAEG,MAAA,CAACgD,eAAe,CAAChC;AACZ,WAAA;AAGH,QAAA,CAACkC,WAAW,IAChBF,YAAY/F,UAAU2E,OAAO5E,MAAMhB,OAC/BqF,cAAc;AAAA,IACZjG;AAAAA,IACAuF,OAAOoC,MAAME;AAAAA,EACd,CAAA,IACD,CAAClE,QAAWA,MAAS,GACrB,CAACoC,UAAU,IACfH,WAAW/D,UAAU2E,OAAO5E,MAAMhB,OAC9BqF,cAAc;AAAA,IACZjG;AAAAA,IACAuF,OAAOoC,MAAM/C;AAAAA,EACd,CAAA,IACD,CAACjB,QAAWA,MAAS,GAErBe,YAA6B;AAAA,IACjCmD,QAAQ;AAAA,MACNhD,MAAM,CAAC;AAAA,QAACxD,MAAMuG,YAAYvG;AAAAA,MAAAA,CAAK;AAAA,MAC/B0G,QAAQJ,MAAME,OAAOE;AAAAA,IACvB;AAAA,IACAnD,OAAO;AAAA,MACLC,MAAM,CAAC;AAAA,QAACxD,MAAMuE,WAAWvE;AAAAA,MAAAA,CAAK;AAAA,MAC9B0G,QAAQJ,MAAM/C,MAAMmD;AAAAA,IACtB;AAAA,IACAC,UAAU5C,MAAM6C,WAAWN,KAAK;AAAA,EAClC;AAEIG,SAAAA,gBACFpD,UAAUmD,OAAOhD,KAAKqD,KAAK,UAAU,GACrCxD,UAAUmD,OAAOhD,KAAKqD,KAAK;AAAA,IAAC7G,MAAMyG,YAAYzG;AAAAA,EAAK,CAAA,IAGjD0E,eACFrB,UAAUE,MAAMC,KAAKqD,KAAK,UAAU,GACpCxD,UAAUE,MAAMC,KAAKqD,KAAK;AAAA,IAAC7G,MAAM0E,WAAW1E;AAAAA,EAAK,CAAA,IAG5CqD;AACT;AC/YO,SAASyD,iBAAiB;AAAA,EAC/BC;AAAAA,EACAC;AAAAA,EACAC;AAKF,GAA8B;AACxBF,MAAAA,YAAYG,YAAY,EAAEC,QAAQ;AAAA,IAACC,OAAO;AAAA,EAAA,CAAa;AACzD;AAGF,QAAMC,YAAYC,aAAa;AAAA,IAACN;AAAAA,IAAaC;AAAAA,EAAAA,CAAM;AAEnD,MAAI,CAACI;AACH;AAGF,QAAME,aAAarC,aAAa;AAAA,IAC9BvG,QAAQqI;AAAAA,IACR7B,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,IAC1C7B,MAAM+D;AAAAA,EAAAA,CACP,GACKI,qBAAqBC,sBAAsB;AAAA,IAC/CpE,MAAM+D;AAAAA,IACNL;AAAAA,IACAC;AAAAA,EAAAA,CACD,GACKU,iBAAiBC,kBAAkB;AAAA,IACvCzC,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,IAC1C6B;AAAAA,IACAC;AAAAA,EAAAA,CACD;AAED,MACEM,cACAE,sBACA,CAACE,kBACD,CAAC7E,OAAOsC,SAASiC,SAAS;AAInB,WAAA;AAAA,MACL9G,OAAOkH;AAAAA,MACPrC,UAAU;AAAA,MACV/B,WAAW;AAAA,QACTmD,QAAQqB,mBAAyB;AAAA,UAC/BL,SAAST,YAAYG,YAAAA,EAAcM;AAAAA,UACnCjH,OAAO;AAAA,YACL+C,MAAMiE;AAAAA,YACN/D,MAAM,CAAC;AAAA,cAACxD,MAAMuH,WAAWvH;AAAAA,YAAK,CAAA;AAAA,UAAA;AAAA,QAChC,CACD;AAAA,QACDuD,OAAOsE,iBAAuB;AAAA,UAC5BL,SAAST,YAAYG,YAAAA,EAAcM;AAAAA,UACnCjH,OAAO;AAAA,YACL+C,MAAMiE;AAAAA,YACN/D,MAAM,CAAC;AAAA,cAACxD,MAAMuH,WAAWvH;AAAAA,YAAK,CAAA;AAAA,UAAA;AAAA,QAEjC,CAAA;AAAA,MAAA;AAAA,IAEL;AAGE,MAAA,CAACyH,sBAAsB,CAACE;AAC1B;AAGIG,QAAAA,8BAA8BC,8BAClCJ,eAAepE,KACjB;AAEA,MAAIuE,gCAAgCxF;AAIpC,WACEuF,qBAA2BF,cAAc,KACzCJ,cACAO,gCAAgCP,WAAWvH,OAIpC;AAAA,MACLO,OAAOkH;AAAAA,MACPrC,UAAU;AAAA,MACV/B,WAAW;AAAA,QACTmD,QAAQqB,mBAAyB;AAAA,UAC/BL,SAAST,YAAYG,YAAAA,EAAcM;AAAAA,UACnCjH,OAAO;AAAA,YACL+C,MAAMiE;AAAAA,YACN/D,MAAM,CAAC;AAAA,cAACxD,MAAMuH,WAAWvH;AAAAA,YAAK,CAAA;AAAA,UAAA;AAAA,QAChC,CACD;AAAA,QACDuD,OAAOsE,iBAAuB;AAAA,UAC5BL,SAAST,YAAYG,YAAAA,EAAcM;AAAAA,UACnCjH,OAAO;AAAA,YACL+C,MAAMiE;AAAAA,YACN/D,MAAM,CAAC;AAAA,cAACxD,MAAMuH,WAAWvH;AAAAA,YAAK,CAAA;AAAA,UAAA;AAAA,QAEjC,CAAA;AAAA,MAAA;AAAA,IACH,IAIG;AAAA,MACLO,OAAOkH;AAAAA,MACPrC,UAAUtC,OAAOsC,SAASiC,SAAS;AAAA,MACnChE,WAAWsE;AAAAA,IACb;AACF;AAEO,SAASL,aAAa;AAAA,EAC3BN;AAAAA,EACAC;AAIF,GAAG;AACIe,SAAAA,UAAUC,UAAUjB,aAAaC,MAAMiB,MAAM,IAIrCF,UAAUG,YAAYnB,aAAaC,MAAMiB,MAAM,IAH1D;AAMJ;AAEA,SAASR,sBAAsB;AAAA,EAC7BpE;AAAAA,EACA0D;AAAAA,EACAC;AAKF,GAAmC;AAC3B,QAAA,CAACmB,UAAU,IAAItD,cAAc;AAAA,IAACnG,QAAQqI;AAAAA,EAAAA,CAAY;AAExD,MAAI,CAACoB;AACH;AAIF,QAAMC,iBADoBL,UAAUM,UAAUtB,aAAaoB,UAAU,EAC5BG,sBAAsB;AAE3DtB,MAAAA,MAAMuB,QAAQH,eAAeI;AACxB,WAAA;AAGH,QAAA,CAACC,SAAS,IAAI1D,aAAa;AAAA,IAACrG,QAAQqI;AAAAA,EAAAA,CAAY;AAEtD,MAAI,CAAC0B;AACH;AAIF,QAAMC,eADmBX,UAAUM,UAAUtB,aAAa0B,SAAS,EAC7BH,sBAAsB;AAExDtB,MAAAA,MAAMuB,QAAQG,aAAaC;AACtB,WAAA;AAIT,QAAMC,cADUb,UAAUM,UAAUtB,aAAa1D,IAAI,EACzBiF,sBAAsB,GAC5CE,MAAMI,YAAYJ,KAClBK,SAASD,YAAYC;AACVC,SAAAA,KAAKC,IAAIP,MAAMxB,MAAMuB,KAAK,IAEzBM,SAAS,IAAI,UAAU;AAC3C;AAEO,SAASlB,kBAAkB;AAAA,EAChCzC;AAAAA,EACA6B;AAAAA,EACAC;AAKF,GAAoB;AACZX,QAAAA,QAAQ2C,uBAAuBjC,aAAaC,KAAK;AAUvD,SARkBX,QACdD,sBAAsB;AAAA,IACpBlB;AAAAA,IACAxG,QAAQqI;AAAAA,IACRV;AAAAA,EACD,CAAA,IACD;AAGN;AAEA,SAAS2C,uBACPtK,QACAsI,OACA;AAKA,MAJI,CAACA,MAAMiB,UAIP,CAACgB,UAAUjC,MAAMiB,MAAM;AACzB;AAGIiB,QAAAA,UAASnB,UAAUoB,UAAUzK,MAAM;AAErC0K,MAAAA;AAEAF,MAAAA,QAAOG,SAASC,2BAA2BjH,QAAW;AACxD,UAAMkH,WAAWL,QAAOG,SAASC,uBAC/BtC,MAAMwC,SACNxC,MAAMyC,OACR;AAEIF,QAAAA;AACE,UAAA;AACFH,mBAAWF,QAAOG,SAASK,YAC3BN,GAAAA,SAASO,SAASJ,SAASK,YAAYL,SAAS9C,MAAM,GACtD2C,SAASS,OAAON,SAASK,YAAYL,SAAS9C,MAAM;AAAA,MAAA,QAC9C;AAAA,MAAA;AAAA,EAEZ,WAAWyC,QAAOG,SAASS,wBAAwBzH;AAEjD+G,eACEF,QAAOG,SAASS,oBAAoB9C,MAAMwC,SAASxC,MAAMyC,OAAO,KAChEpH;AAAAA,OACG;AACL0H,YAAQC,KACN,qEACF;AACA;AAAA,EAAA;AAGF,MAAI,CAACZ;AACH;AAGE/C,MAAAA;AAEA,MAAA;AACM0B,YAAAA,UAAUkC,aAAavL,QAAQ0K,UAAU;AAAA,MAC/Cc,YAAY;AAAA;AAAA,MAEZC,eAAe;AAAA,IAAA,CAChB;AAAA,EAAA,QACK;AAAA,EAAA;AAED9D,SAAAA;AACT;AC/QgB+D,SAAAA,YAAY7G,MAAY7E,QAA2B;AACjE,MAAI,CAACA;AACH,WAAO,CAAE;AAEL,QAAA,CAAC4B,OAAOqC,SAAS,IAAIxC,MAAMyC,KAC/BC,OAAOC,MAAMpE,QAAQ;AAAA,IACnBqE,IAAI,CAAE;AAAA,IACNC,OAAQC,CACNoH,MAAAA,aAAa9G,KAAK,CAAC,CAAC,KAAMN,EAAiBlD,SAASwD,KAAK,CAAC,EAAExD;AAAAA,EAC/D,CAAA,CACH,EAAE,CAAC,KAAK,CAACsC,QAAWA,MAAS;AAE7B,MAAI,CAAC/B,SAAS,CAACkB,UAAQC,UAAUnB,KAAK;AACpC,WAAO,CAAE;AAGP5B,MAAAA,OAAO4L,OAAOhK,KAAK;AACrB,WAAO,CAACqC,UAAU,CAAC,GAAG,CAAC;AAGzB,QAAM4H,YAAY,CAAChH,KAAK,CAAC,CAAC,GACpBiB,aAAalE,MAAMU,SAASwJ,UAAWvJ,CAC3CjB,UAAAA,QAAQ,CAAC;AAAA,IAACD,MAAMkB,MAAMlB;AAAAA,EAAAA,CAAK,GAAGwK,SAAS,CACzC;AAEA,MAAI/F,cAAc,KAAKlE,MAAMU,SAASwD,UAAU,GAAG;AAC3CvD,UAAAA,QAAQX,MAAMU,SAASwD,UAAU;AACvC,WAAIhD,UAAQC,UAAUR,KAAK,KAAKvC,OAAO4L,OAAOrJ,KAAK,IAC1C0B,UAAU8H,OAAOjG,UAAU,EAAEiG,OAAO,CAAC,IAEvC9H,UAAU8H,OAAOjG,UAAU;AAAA,EAAA;AAGpC,SAAO,CAAC7B,UAAU,CAAC,GAAG,CAAC;AACzB;AC5BgBsH,SAAAA,aACd7G,WACA1E,QACc;AACV,MAAA,CAAC0E,aAAa,CAAC1E;AACV,WAAA;AAET,QAAM6H,SAAS;AAAA,IACbhD,MAAM6G,YAAYhH,UAAUmD,OAAOhD,MAAM7E,MAAM;AAAA,IAC/C+H,QAAQrD,UAAUmD,OAAOE;AAAAA,KAErBnD,QAAQ;AAAA,IACZC,MAAM6G,YAAYhH,UAAUE,MAAMC,MAAM7E,MAAM;AAAA,IAC9C+H,QAAQrD,UAAUE,MAAMmD;AAAAA,EAC1B;AACInD,SAAAA,MAAMC,KAAKjB,WAAW,KAAKiE,OAAOhD,KAAKjB,WAAW,IAC7C,OAEKiE,UAAUjD,QAAQ;AAAA,IAACiD;AAAAA,IAAQjD;AAAAA,EAAAA,IAAS;AAEpD;AAEgBoH,SAAAA,qBACdrE,OACAsE,WACc;AACd,QAAMpE,SAASqE,MAAMC,UAAUxE,MAAME,QAAQoE,SAAS,GAChDrH,QAAQsH,MAAMC,UAAUxE,MAAM/C,OAAOqH,SAAS;AAEpD,SAAIpE,WAAW,QAAQjD,UAAU,OACxB,OAGLsH,MAAME,OAAOvE,QAAQF,MAAME,MAAM,KAAKqE,MAAME,OAAOxH,OAAO+C,MAAM/C,KAAK,IAChE+C,QAGF;AAAA,IAACE;AAAAA,IAAQjD;AAAAA,EAAK;AACvB;AC5CgByH,SAAAA,eACd9G,OACAnE,OAC6B;AACzB,MAAA,CAACmE,SAAS,CAACnE;AACN,WAAA;AAET,QAAMkL,UAAgB,CAAE;AACpBC,MAAAA,YAAoBhH,MAAMwC,UAAU;AACxC,QAAMyE,WACJ,OAAOjH,MAAMV,KAAK,CAAC,KAAM,YACzB,UAAUU,MAAMV,KAAK,CAAC,KACtBU,MAAMV,KAAK,CAAC,EAAExD,MACVoL,WACJ,OAAOlH,MAAMV,KAAK,CAAC,KAAM,YACzB,UAAUU,MAAMV,KAAK,CAAC,KACtBU,MAAMV,KAAK,CAAC,EAAExD,MACVO,QAAuCR,MAAMsL,KAChDC,CAAQA,QAAAA,IAAItL,SAASmL,QACxB;AACI5K,MAAAA;AACF0K,YAAQpE,KAAK;AAAA,MAAC7G,MAAMO,MAAMP;AAAAA,IAAAA,CAAK;AAAA;AAExB,WAAA;AAET,MAAIO,SAAS2D,MAAMV,KAAK,CAAC,MAAM,YAAY;AAEvC,QAAA,CAACjD,MAAMU,YACNb,MAAMC,QAAQE,MAAMU,QAAQ,KAAKV,MAAMU,SAASsB,WAAW;AAErD,aAAA;AAET,UAAMrB,QACJd,MAAMC,QAAQE,MAAMU,QAAQ,KAC5BV,MAAMU,SAASoK,KAAME,CAAAA,QAAQA,IAAIvL,SAASoL,QAAQ;AAChDlK,QAAAA;AACF+J,cAAQpE,KAAK,UAAU,GACvBoE,QAAQpE,KAAK;AAAA,QAAC7G,MAAMkB,MAAMlB;AAAAA,MAAAA,CAAK,GAC/BkL,YACEhK,MAAMI,QAAQJ,MAAMI,KAAKiB,UAAU2B,MAAMwC,SACrCxC,MAAMwC,SACLxF,MAAMI,QAAQJ,MAAMI,KAAKiB,UAAW;AAAA;AAEpC,aAAA;AAAA,EAAA;AAGJ,SAAA;AAAA,IAACiB,MAAMyH;AAAAA,IAASvE,QAAQwE;AAAAA,EAAS;AAC1C;AAEgBM,SAAAA,mBACdnI,WACAtD,OACwB;AACxB,MAAI,CAACsD,aAAa,CAACtD,SAASA,MAAMwC,WAAW;AACpC,WAAA;AAELkJ,MAAAA,YAAyC,MACzCC,WAAwC;AACtC,QAAA;AAAA,IAAClF;AAAAA,IAAQjD;AAAAA,EAAAA,IAASF;AAUxB,SAREmD,UACAzG,MAAMsL,KAAMC,CAAAA,QAAQrL,QAAQ;AAAA,IAACD,MAAMsL,IAAItL;AAAAA,EAAAA,GAAOwG,OAAOhD,KAAK,CAAC,CAAC,CAAC,MAE7DiI,YAAYT,eAAexE,QAAQzG,KAAK,IAEtCwD,SAASxD,MAAMsL,KAAMC,SAAQrL,QAAQ;AAAA,IAACD,MAAMsL,IAAItL;AAAAA,EAAOuD,GAAAA,MAAMC,KAAK,CAAC,CAAC,CAAC,MACvEkI,WAAWV,eAAezH,OAAOxD,KAAK,IAEpC0L,aAAaC,WACR;AAAA,IAAClF,QAAQiF;AAAAA,IAAWlI,OAAOmI;AAAAA,IAAU/E,UAAUtD,UAAUsD;AAAAA,EAAAA,IAE3D;AACT;ACxEO,MAAMgF,+BACX,oBAAIC,WAEOC,uBACPD,oBAAAA,QAAAA,GACOE,uBACPF,oBAAAA,QAAAA,GAGOG,mDAAmCH,QAG9C,GCbWI,qBAAqBC,cAA2B,EAAiB;ACHvE,SAAAC,gBAAA;AAAAzN,QAAAA,IAAAC,EAAA,CAAA;AAAAK,MAAAA;AAAA,SAAAN,EAAA,CAAA,MAAA0N,OAAAC,IAAA,2BAAA,KAEHrN,KAYM,oBAAA,OAXa,EAAA,iBAAI,IACX,WAAA,qBACH,OAAA;AAAA,IAAAyK,UACK;AAAA,IAAU6C,OACb;AAAA,IAAMvD,QAAA;AAAA,IAAAwD,cAEC;AAAA,IAAwBC,QAAA;AAAA,EAIxC,GAAA,UAAA,oBAAQ,QAAA,CAAA,CAAA,EACV,CAAA,GAAM9N,OAAAM,MAAAA,KAAAN,EAAA,CAAA,GAZNM;AAYM;ACZH,SAAAyN,yBAAAhO,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA;AAAAK,MAAAA;AAAAN,IAAA,CAAA,MAAA0N,OAAAC,IAAA,2BAAA,KAISrN,KAAA;AAAA,IAAA0N,YAAa;AAAA,EAAA,GAAOhO,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AAAAS,MAAAA;AAAA,SAAAT,EAAA,CAAA,MAAAD,MAAAqH,YAAA7F,QAAAvB,EAAAD,CAAAA,MAAAA,MAAAqH,YAAArF,SAAhCtB,KAAA,qBAAA,OAAA,EAAY,OAAAH,IAAsB,UAAA;AAAA,IAAA;AAAA,IAC9BP,MAAKqH,YAAArF;AAAAA,IAAmB;AAAA,IAAGhC,MAAKqH,YAAA7F;AAAAA,IAAkB;AAAA,EAAA,GACtD,GAAMvB,EAAAD,CAAAA,IAAAA,MAAAqH,YAAA7F,MAAAvB,EAAAD,CAAAA,IAAAA,MAAAqH,YAAArF,OAAA/B,OAAAS,MAAAA,KAAAT,EAAA,CAAA,GAFNS;AAEM;AAIH,SAAAwN,0BAAAlO,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA;AAAAK,MAAAA;AAAAN,IAAA,CAAA,MAAA0N,OAAAC,IAAA,2BAAA,KAIUrN,KAAA;AAAA,IAAA0N,YAAa;AAAA,EAAA,GAAOhO,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AAAAS,MAAAA;AAAA,SAAAT,EAAA,CAAA,MAAAD,MAAAmO,aAAA3M,QAAAvB,EAAAD,CAAAA,MAAAA,MAAAmO,aAAAnM,SAAjCtB,KAAA,qBAAA,QAAA,EAAa,OAAAH,IAAsB,UAAA;AAAA,IAAA;AAAA,IAC/BP,MAAKmO,aAAAnM;AAAAA,IAAoB;AAAA,IAAGhC,MAAKmO,aAAA3M;AAAAA,IAAmB;AAAA,EAAA,GACxD,GAAOvB,EAAAD,CAAAA,IAAAA,MAAAmO,aAAA3M,MAAAvB,EAAAD,CAAAA,IAAAA,MAAAmO,aAAAnM,OAAA/B,OAAAS,MAAAA,KAAAT,EAAA,CAAA,GAFPS;AAEO;ACRJ,SAAS0N,iBAAiB;AAAA,EAC/BjF;AAAAA,EACAkF;AAIF,GAAG;AACD,MAAIC,gBAAgBnF;AAUpB,MAR4BoF,qBAA+B;AAAA,IAEzDvF,SAAS;AAAA,MACP,GAAGqF,SAASrF;AAAAA,MACZnE,WAAWsE;AAAAA,IAAAA;AAAAA,EACb,CACD;AAGQmF,WAAAA;AAGHE,QAAAA,6BAA6BD,uBAA+B;AAAA,IAEhEvF,SAAS;AAAA,MACP,GAAGqF,SAASrF;AAAAA,MACZnE,WAAWsE;AAAAA,IAAAA;AAAAA,EACb,CACD,GACKsF,mBAAmBF,kBAA4B;AAAA,IAEnDvF,SAAS;AAAA,MACP,GAAGqF,SAASrF;AAAAA,MACZnE,WAAWsE;AAAAA,IAAAA;AAAAA,EACb,CACD,GACKuF,cAAcH,eAAuB;AAAA,IAEzCvF,SAAS;AAAA,MACP,GAAGqF,SAASrF;AAAAA,MACZnE,WAAWsE;AAAAA,IAAAA;AAAAA,EACb,CACD;AAEGqF,gCAA8BC,oBAAoBC,gBAGpDJ,gBAAgB;AAAA,IACdtG,QAAQqB,mBAAyB;AAAA,MAC/BL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO0M;AAAAA,IAAAA,CACR;AAAA,IACD1J,OAAOsE,iBAAuB;AAAA,MAC5BL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO0M;AAAAA,IACR,CAAA;AAAA,EAAA;AAICjH,QAAAA,iBAAiB+G,kBAA4BF,QAAQ;AAGzDA,MAAAA,SAASrF,QAAQnE,aACjB0J,oBAA8BF,QAAQ,KACtC7G,eAAezD,SAAS,GACxB;AACM4K,UAAAA,sBAAsBJ,yBAAiCF,QAAQ,GAC/DO,oBAAoBL,uBAA+BF,QAAQ;AAE7D,QAAA,CAACM,uBAAuB,CAACC;AACpBN,aAAAA;AAGHhJ,UAAAA,sBAAsB+D,mBAAyB;AAAA,MACnDL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO4M;AAAAA,IAAAA,CACR,GACK/I,oBAAoByD,iBAAuB;AAAA,MAC/CL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO6M;AAAAA,IAAAA,CACR;AAEkCL,2BACjCpF,cACF,EAAE;AAAA,MACA,GAAGkF;AAAAA,MACHrF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW;AAAA,UAACmD,QAAQ1C;AAAAA,UAAqBP,OAAOa;AAAAA,QAAAA;AAAAA,MAAiB;AAAA,IAEpE,CAAA,MAGC0I,gBAAgB;AAAA,MACdtG,QAAQ1C;AAAAA,MACRP,OAAOa;AAAAA,IAAAA;AAAAA,EACT;AAIG0I,SAAAA;AACT;ACzGaO,MAAAA,sBAAsBA,MAAcC,UAAU,EAAE,GAEvDC,kBAAyB,uBAAA;AACzBC,MAAAA;AACJ,SAAO,MAAM;AACPA,QAAAA;AACKA,aAAAA;AAGTA,YAAQ,CAAE;AACV,aAASC,IAAI,GAAGA,IAAI,KAAK,EAAEA;AACnBA,YAAAA,CAAC,KAAKA,IAAI,KAAOC,SAAS,EAAE,EAAEjK,MAAM,CAAC;AAEtC+J,WAAAA;AAAAA,EACT;AACF,GAAG;AAGH,SAASG,UAAUpL,SAAS,IAAI;AACxBqL,QAAAA,QAAQ,IAAIC,WAAWtL,MAAM;AACnCuL,SAAAA,gBAAgBF,KAAK,GACdA;AACT;AAEA,SAASN,UAAU/K,QAAyB;AAC1C,QAAMiL,QAAQD,gBAAgB;AAC9B,SAAOI,UAAUpL,MAAM,EACpBwL,OAAO,CAACC,KAAK9K,MAAM8K,MAAMR,MAAMtK,CAAC,GAAG,EAAE,EACrCO,MAAM,GAAGlB,MAAM;AACpB;ACvBO,SAAS0L,qBAAqBC,QAMlB;AACV,SAAA;AAAA,IACLC,IAAId,oBAAoB;AAAA,IACxB9N,MAAM2O,QAAQ3O;AAAAA,IACd6O,WAAWF,QAAQE;AAAAA,EACrB;AACF;ACrBO,MAAMC,eAAeJ,qBAAqB;AAAA,EAAC1O,MAAM;AAAM,CAAC;ACMxD,SAAS+O,sCAAsC;AAAA,EACpDC;AAAAA,EACAC;AAMF,GAAG;AACD,SAAO,CACL;AAAA,IACEC,UAAUC,eAAe;AAAA,MACvB7P,IAAI;AAAA,MACJ8P,OAAOA,CAAC;AAAA,QAAC9B;AAAAA,QAAU5F;AAAAA,MAAAA,MAAW;AACtB2H,cAAAA,iBAAiB7B,gBAAwB;AAAA,UAE7CvF,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAW4D,MAAMuC,SAASnG;AAAAA,UAAAA;AAAAA,QAC5B,CACD;AAED,YAAI,CAACuL,kBAAkBA,eAAetL,KAAKtD,SAASuO;AAC3C,iBAAA;AAGT,cAAMM,aAAa5H,MAAM4H;AAEzB,YAAI,CAACA;AACI,iBAAA;AAGT,cAAM/B,gBAAgBF,iBAAiB;AAAA,UACrCjF,gBAAgBkH,WAAWxL;AAAAA,UAC3BwJ;AAAAA,QAAAA,CACD;AAUD,eARsBE,kBAA4B;AAAA,UAEhDvF,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAWyJ;AAAAA,UAAAA;AAAAA,QACb,CACD,EAGepH,KAAMoJ,CAAiBA,iBAAAA,aAAaxL,KAAKtD,SAASuO,GAAG,IAE5D,KAGoBxB,wBAAkC;AAAA,UAE7DvF,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAWyJ;AAAAA,UAAAA;AAAAA,QACb,CACD;AAAA,MAGH;AAAA,MACAiC,SAAS,CACP,CAAC;AAAA,QAAC9H;AAAAA,MAAAA,MAAW,CACX;AAAA,QACE+H,MAAM;AAAA,QACNC,QAAQA,MAAM;AACWhI,iCAAAA,MAAMuC,SAASjJ,KAAK;AAAA,QAAA;AAAA,MAC7C,CACD,CACF;AAAA,IAAA,CAEJ;AAAA,IACD2O,UAAUjB,qBAAqB;AAAA,MAC7BG,WAAW;AAAA,QACTc,UAAUb;AAAAA,QACVc,YAAY;AAAA,MAAA;AAAA,IAEf,CAAA;AAAA,EAAA,GAEH;AAAA,IACEV,UAAUC,eAAe;AAAA,MACvB7P,IAAI;AAAA,MACJ8P,OAAOA,CAAC;AAAA,QAAC1H;AAAAA,MAAAA,MACAA,MAAM+H,SAAS;AAAA,MAExBD,SAAS,CACP,CAAC;AAAA,QAAC9H;AAAAA,MAAAA,MAAW,CACX;AAAA,QACE+H,MAAM;AAAA,QACNC,QAAQA,MAAM;AACZT,iCAAuBlM,MAAS;AAAA,QAAA;AAAA,MAClC,GAEF8M,QAAQnI,KAAK,CAAC,CACf;AAAA,IAAA,CAEJ;AAAA,IACDiI,UAAUjB,qBAAqB;AAAA,MAC7BG,WAAW;AAAA,QACTc,UAAUb;AAAAA,QACVc,YAAY;AAAA,MAAA;AAAA,IAEf,CAAA;AAAA,EAAA,CACF;AAEL;AC5GO,SAAAE,6BAAAtQ,IAAA;AAAAN,QAAAA,IAAAC,EAAA,CAAA,GAAsC;AAAA,IAAA6P;AAAAA,IAAAC;AAAAA,EAAAzP,IAAAA,IAS3CgI,cAAoBuI,WAAAtD,kBAA6B;AAAC,MAAA9M,IAAAqQ;AAAA9Q,IAAAsI,CAAAA,MAAAA,eAAAtI,SAAA8P,OAAA9P,EAAA,CAAA,MAAA+P,0BAExCtP,KAAAA,MAAA;AACR,UAAAsQ,kBAAwBlB,sCAAA;AAAA,MAAAC;AAAAA,MAAAC;AAAAA,IAAAA,CAGvB;AAAC,eAEGiB,kBAAwBD;AAC3BzI,kBAAW2I,KAAA;AAAA,QAAAV,MACH;AAAA,QAAcS;AAAAA,MAAAA,CAErB;AAAC,WAAA,MAAA;AAAA,iBAIGE,oBAAwBH;AAC3BzI,oBAAW2I,KAAA;AAAA,UAAAV,MACH;AAAA,UAAiBS,gBACvBA;AAAAA,QAAAA,CACD;AAAA,IAAC;AAAA,EAAA,GAGLF,KAACxI,CAAAA,aAAawH,KAAKC,sBAAsB,GAAC/P,OAAAsI,aAAAtI,OAAA8P,KAAA9P,OAAA+P,wBAAA/P,OAAAS,IAAAT,OAAA8Q,OAAArQ,KAAAT,EAAA,CAAA,GAAA8Q,KAAA9Q,EAAA,CAAA,IArB7CU,UAAUD,IAqBPqQ,EAA0C;AAAC;ACzBzC,SAASK,kBAAkBpR,OAO/B;AACD,QAAM,CAACqR,mBAAmBC,oBAAoB,IAC5CC,SAA6B,GACzBC,iBAAiBC,OAAuB,IAAI,GAE5CjJ,cAAckJ,eACdC,GAAAA,WAAWC,YAEXrJ,GAAAA,cAAcuI,WAAWtD,kBAAkB;AAEpB,+BAAA;AAAA,IAC3BuC,KAAK/P,MAAM+G,QAAQvF;AAAAA,IACnBwO,wBAAwBsB;AAAAA,EAAAA,CACzB;AAED,QAAMO,mBAAmBC,YAAYvJ,aAAcwJ,CACjDA,MAAAA,EAAE/I,QACCgJ,gBAAgB,EAChB5K,aAAayF,KACXxF,iBAAgBA,YAAYtG,SAASf,MAAM+G,QAAQ/E,KACtD,CACJ;AAEK6P,sBACHrG,QAAQyG,MACN,qBAAqBjS,MAAM+G,QAAQ/E,KAAK,sBAC1C;AAGIkQ,QAAAA,UACJP,YACAnJ,YAAY3D,cAAc,QAC1BU,MAAM4M,YAAY3J,YAAY3D,SAAS;AAEzC,8BACG,OACC,EAAA,GAAI7E,MAAMoS,YACV,WAAU,4BACV,kBAAgBpS,MAAM+G,QAAQvF,MAC9B,mBAAiBxB,MAAM+G,QAAQ/E,OAC/B,mBAAgB,UAEfqP,UAAAA;AAAAA,IAAsB,sBAAA,UAAW,oBAAA,eAAA,CAAA,CAAgB,IAAG;AAAA,IACpDrR,MAAMyC;AAAAA,IACN,oBAAA,OAAA,EACC,KAAK+O,gBACL,iBAAiB,IACjB,WAAW,CAACxR,MAAMqS,UAEjBrS,UAAAA,MAAMsS,eAAeT,mBACpB7R,MAAMsS,YAAY;AAAA,MAChB7P,UACE,oBAAC,0BAAyB,EAAA,aAAazC,MAAMqH,aAC9C;AAAA,MACDkL,kBAAkBf;AAAAA,MAClBU;AAAAA,MACAlN,MAAM,CAAC;AAAA,QAACxD,MAAMxB,MAAM+G,QAAQvF;AAAAA,MAAAA,CAAK;AAAA,MACjCgR,YAAYX;AAAAA,MACZF;AAAAA,MACAnB,MAAMqB;AAAAA,MACNtQ,OAAOvB,MAAMqH;AAAAA,IAAAA,CACd,IAED,oBAAC,4BAAyB,aAAarH,MAAMqH,YAC9C,CAAA,GACH;AAAA,IACCgK,sBAAsB,QAAS,oBAAA,eAAA,CAAgB,CAAA,IAAG;AAAA,EAAA,GACrD;AAEJ;AC7EO,SAASoB,mBAAmBzS,OAOhC;AACD,QAAM0S,kBAAkBjB,OAAoB,IAAI,GAE1CjJ,cAAckJ,eACdC,GAAAA,WAAWC,YAAY,GAEvBrJ,cAAcuI,WAAWtD,kBAAkB,GAC3CqE,mBAAmBC,YAAYvJ,aAAcwJ,CACjDA,MAAAA,EAAE/I,QACCgJ,gBAAAA,EACAW,cAAc9F,KACZsB,CAAAA,iBAAiBA,aAAapN,SAASf,MAAM+G,QAAQ/E,KACxD,CACJ;AAEK6P,sBACHrG,QAAQyG,MACN,sBAAsBjS,MAAM+G,QAAQ/E,KAAK,sBAC3C;AAGIkQ,QAAAA,UACJP,YACAnJ,YAAY3D,cAAc,QAC1BU,MAAM4M,YAAY3J,YAAY3D,SAAS,GACnCG,OAAOwE,UAAUoJ,SAASpK,aAAaxI,MAAM+G,OAAO,GACpD,CAAChF,KAAK,IAAI0D,cAAc;AAAA,IAC5BtF,QAAQqI;AAAAA,IACR9C,OAAO;AAAA,MACLV;AAAAA,MACAkD,QAAQ;AAAA,IAAA;AAAA,EACV,CACD;AAED,SAAKnG,SACHyJ,QAAQyG,MACN,gDAAgDjS,MAAM+G,QAAQvF,IAAI,EACpE,GAIA,qBAAC,QACC,EAAA,GAAIxB,MAAMoS,YACV,WAAW,CAACpS,MAAMqS,UAClB,WAAU,oBACV,kBAAgBrS,MAAMmO,aAAa3M,MACnC,mBAAiBxB,MAAMmO,aAAanM,OACpC,mBAAgB,UAEfhC,UAAAA;AAAAA,IAAMyC,MAAAA;AAAAA,IACN,oBAAA,QAAA,EAAK,KAAKiQ,iBAAiB,OAAO;AAAA,MAACG,SAAS;AAAA,IAAA,GAC1C7S,UAAM8S,MAAAA,eAAe/Q,SAAS8P,mBAC7B7R,MAAM8S,YAAY;AAAA,MAChBC,aAAa,CAAE;AAAA,MACftQ,UACE,oBAAC,2BAA0B,EAAA,cAAczC,MAAMmO,cAChD;AAAA,MACDoE,kBAAkBG;AAAAA,MAClBf;AAAAA,MACAO;AAAAA,MACAlN,MAAM,CAAC;AAAA,QAACxD,MAAMO,MAAMP;AAAAA,SAAO,YAAY;AAAA,QAACA,MAAMxB,MAAM+G,QAAQvF;AAAAA,MAAAA,CAAK;AAAA,MACjEgR,YAAYX;AAAAA,MACZtQ,OAAOvB,MAAMmO;AAAAA,MACbqC,MAAMqB;AAAAA,IAAAA,CACP,IAED,oBAAC,6BAA0B,cAAc7R,MAAMmO,cAChD,EACH,CAAA;AAAA,EAAA,GACF;AAEJ;AC1EO,SAAS6E,gBAAgBhT,OAU7B;AACD,QAAM,CAACqR,mBAAmBC,oBAAoB,IAC5CC,SAA6B,GACzB0B,WAAWxB,OAAuB,IAAI,GAEtCjJ,cAAckJ,eACdC,GAAAA,WAAWC,YAEXrJ,GAAAA,cAAcuI,WAAWtD,kBAAkB;AAEpB,+BAAA;AAAA,IAC3BuC,KAAK/P,MAAM+G,QAAQvF;AAAAA,IACnBwO,wBAAwBsB;AAAAA,EAAAA,CACzB;AAED,QAAM4B,eAAepB,YAAYvJ,aAAcwJ,CAC7CA,MAAAA,EAAE/I,QAAQgJ,gBACZ,CAAA,GAEME,UACJP,YACAnJ,YAAY3D,cAAc,QAC1BU,MAAM4M,YAAY3J,YAAY3D,SAAS;AAEzC,MAAIpC,WAAWzC,MAAMyC;AAErB,QAAM0Q,wBAAwBD,aAAanR;AAE3C,MAAI/B,MAAMoT,eAAepT,MAAMkC,UAAUG,OAAO;AAC9C,UAAMgR,wBACJrT,MAAMkC,UAAUG,UAAUyB,SACtBoP,aAAa/P,OAAO0J,KACjBxK,CAAAA,UAAUA,MAAMd,UAAUvB,MAAMkC,UAAUG,KAC7C,IACAyB;AAEFuP,4BACF5Q,WAAWzC,MAAMoT,YAAY;AAAA,MAC3BrR,OAAO/B,MAAMkC;AAAAA,MACbO;AAAAA,MACA8P,kBAAkBU;AAAAA,MAClBf;AAAAA,MACAlN,MAAM,CAAC;AAAA,QAACxD,MAAMxB,MAAMkC,UAAUV;AAAAA,MAAAA,CAAK;AAAA,MACnCgR,YAAYa;AAAAA,MACZ1B;AAAAA,MACApQ,OAAOvB,MAAMkC,UAAUG;AAAAA,IAAAA,CACxB,IAEDmJ,QAAQyG,MACN,mDAAmDjS,MAAMkC,UAAUG,KAAK,EAC1E;AAAA,EAAA;AAIJ,MAAIrC,MAAMsT,kBAAkBtT,MAAMkC,UAAUqF,UAAU;AAC9CgM,UAAAA,2BAA2BL,aAAaM,MAAM3G,KACjD4G,UAASA,KAAKlS,UAAUvB,MAAMkC,UAAUqF,QAC3C;AAEIgM,+BACF9Q,WAAWzC,MAAMsT,eAAe;AAAA,MAC9BvR,OAAO/B,MAAMkC;AAAAA,MACbO;AAAAA,MACA8P,kBAAkBU;AAAAA,MAClBf;AAAAA,MACAwB,OAAO1T,MAAMkC,UAAUwR,SAAS;AAAA,MAChC1O,MAAM,CAAC;AAAA,QAACxD,MAAMxB,MAAMkC,UAAUV;AAAAA,MAAAA,CAAK;AAAA,MACnCmQ;AAAAA,MACApQ,OAAOvB,MAAMkC,UAAUqF;AAAAA,MACvBiL,YAAYe;AAAAA,IAAAA,CACb,IAED/H,QAAQyG,MACN,uDAAuDjS,MAAMkC,UAAUqF,QAAQ,EACjF;AAAA,EAAA;AAIJ,SACG,qBAAA,OAAA,EACKvH,GAAAA,MAAMoS,YACV,WAAW,CACT,YACA,iBACA,GAAIpS,MAAMkC,UAAUG,QAChB,CAAC,uBAAuBrC,MAAMkC,UAAUG,KAAK,EAAE,IAC/C,CAAA,GACJ,GAAIrC,MAAMkC,UAAUqF,WAChB,CACE,gBACA,gBAAgBvH,MAAMkC,UAAUqF,QAAQ,IACxC,sBAAsBvH,MAAMkC,UAAUwR,SAAS,CAAC,EAAE,IAEpD,CAAA,CAAG,EACPxP,KAAK,GAAG,GACV,YAAYlE,MAAM2T,YAClB,kBAAgB3T,MAAMkC,UAAUV,MAChC,mBAAiBxB,MAAMkC,UAAUF,OACjC,mBAAgB,QACXhC,GAAAA,MAAMkC,UAAUqF,aAAazD,SAC9B;AAAA,IACE,kBAAkB9D,MAAMkC,UAAUqF;AAAAA,MAEpC,CAAC,GACL,GAAKvH,MAAMkC,UAAUwR,UAAU5P,SAC3B;AAAA,IACE,cAAc9D,MAAMkC,UAAUwR;AAAAA,MAEhC,CAAC,GACL,GAAK1T,MAAMkC,UAAUG,UAAUyB,SAC3B;AAAA,IACE,cAAc9D,MAAMkC,UAAUG;AAAAA,EAAAA,IAEhC,CAAA,GAEHgP,UAAAA;AAAAA,IAAsB,sBAAA,UAAW,oBAAA,eAAA,CAAA,CAAgB,IAAG;AAAA,wBACpD,OAAI,EAAA,KAAK4B,UACPjT,UAAMsS,MAAAA,cACHtS,MAAMsS,YAAY;AAAA,MAChB7P;AAAAA,MACA8P,kBAAkBU;AAAAA,MAClBf;AAAAA,MACAwB,OAAO1T,MAAMkC,UAAUwR;AAAAA,MACvBnM,UAAUvH,MAAMkC,UAAUqF;AAAAA,MAC1BvC,MAAM,CAAC;AAAA,QAACxD,MAAMxB,MAAMkC,UAAUV;AAAAA,MAAAA,CAAK;AAAA,MACnCmQ;AAAAA,MACAa,YAAYW;AAAAA,MACZ9Q,OAAOrC,MAAMkC,UAAUG;AAAAA,MACvBmO,MAAM2C;AAAAA,MACN5R,OAAOvB,MAAMkC;AAAAA,IAAAA,CACd,IACDlC,MAAMyC,UACZ;AAAA,IACC4O,sBAAsB,QAAS,oBAAA,eAAA,CAAgB,CAAA,IAAG;AAAA,EAAA,GACrD;AAEJ;ACjJO,SAAAuC,cAAA5T,OAAA;AAAAC,QAAAA,IAAAC,EAAA,EAAA,GAWLqI,cAAoBuI,WAAAtD,kBAA6B,GACjD7G,SAAemL,YAAYvJ,aAAWsL,OAAyB;AAEC,MAA9D,cAAc7T,MAAK+G,WAAY/G,MAAK+G,QAAA/D,aAA0B,IAEpD;AAAAzC,QAAAA;AAAAN,MAAA,CAAA,MAAAD,MAAA+G,WAIJxG,MAAA,WAAWP,MAAK+G,WAAY,OAAO/G,MAAK+G,QAAAxF,SAAmB,WAC3DvB,MAAK+G,QAAAxF,QACH,CAAA,GAAAtB,EAAA,CAAA,IAAAD,MAAA+G,SAAA9G,OAAAM,OAAAA,MAAAN,EAAA,CAAA;AAAAS,QAAAA;AAAAT,MAAAD,CAAAA,MAAAA,MAAA+G,QAAAvF,QAAAvB,EAAAD,CAAAA,MAAAA,MAAA+G,QAAA/E,SAAA/B,SAAAM,OALaG,MAAA;AAAA,MAAAc,MACbxB,MAAK+G,QAAAvF;AAAAA,MAAAQ,OACJhC,MAAK+G,QAAA/E;AAAAA,MAAA,GACRzB;AAAAA,IAAAA,GAGLN,EAAAD,CAAAA,IAAAA,MAAA+G,QAAAvF,MAAAvB,EAAAD,CAAAA,IAAAA,MAAA+G,QAAA/E,OAAA/B,OAAAM,KAAAN,OAAAS,OAAAA,MAAAT,EAAA,CAAA;AAND,UAAAkO,eAAqBzN;AASlBiG,WAAMgM,cAAA9F,KAAAiH,CACa3F,mBAAAA,eAAYpN,SAAUf,MAAK+G,QAAA/E,KAC/C,KAEAwJ,QAAAyG,MACE,iCAAiCjS,MAAK+G,QAAA/E,KAAA,aACxC;AAAC+O,QAAAA;AAAA9Q,MAAAkO,CAAAA,MAAAA,gBAAAlO,EAAA,CAAA,MAAAD,MAAA+G,QAAAvF,QAAAvB,EAAA,CAAA,MAAAD,MAAA+G,QAAA/E,SAQG+O,MAAA5C,gBAAY;AAAA,MAAA3M,MACJxB,MAAK+G,QAAAvF;AAAAA,MAAAQ,OACJhC,MAAK+G,QAAA/E;AAAAA,IAAAA,GACb/B,OAAAkO,cAAAlO,EAAAD,CAAAA,IAAAA,MAAA+G,QAAAvF,MAAAvB,EAAAD,CAAAA,IAAAA,MAAA+G,QAAA/E,OAAA/B,OAAA8Q,OAAAA,MAAA9Q,EAAA,CAAA;AAAA8T,QAAAA;AAAA,WAAA9T,EAAA,EAAA,MAAAD,MAAAoS,cAAAnS,EAAAD,EAAAA,MAAAA,MAAAyC,YAAAxC,UAAAD,MAAA+G,WAAA9G,EAAA,EAAA,MAAAD,MAAAqS,YAAApS,EAAAD,EAAAA,MAAAA,MAAA8S,eAAA7S,UAAA8Q,OAPLgD,MAAA,oBAAC,oBACa,EAAA,YAAA/T,MAAKoS,YACR,SAAApS,MAAK+G,SAEZ,cAAAgK,KAKQ,UAAA/Q,MAAKqS,UACF,aAAArS,MAAK8S,aAEjB9S,UAAAA,MAAKyC,UACR,GAAqBxC,EAAA,EAAA,IAAAD,MAAAoS,YAAAnS,EAAA,EAAA,IAAAD,MAAAyC,UAAAxC,EAAA,EAAA,IAAAD,MAAA+G,SAAA9G,EAAA,EAAA,IAAAD,MAAAqS,UAAApS,EAAA,EAAA,IAAAD,MAAA8S,aAAA7S,QAAA8Q,KAAA9Q,QAAA8T,OAAAA,MAAA9T,EAAA,EAAA,GAbrB8T;AAAAA,EAAAA;AAaqB,MAIrBtM,YAAA;AAAA,IAAAd;AAAAA,EAAAA,GAAsB3G,MAAK+G,OAAQ,GAAC;AAAAxG,QAAAA;AAAAN,WAAAA,UAAAD,MAAAoS,cAAAnS,UAAAD,MAAAyC,YAAAxC,UAAAD,MAAA+G,WAAA9G,EAAAD,EAAAA,MAAAA,MAAAqS,YAAApS,EAAA,EAAA,MAAAD,MAAAsS,eAAArS,EAAA,EAAA,MAAAD,MAAAsT,kBAAArT,EAAA,EAAA,MAAAD,MAAAoT,eAAAnT,EAAA,EAAA,MAAAD,MAAA2T,cAEpCpT,MAAC,oBAAA,iBAAA,EACa,YAAAP,MAAKoS,YACR,SAAApS,MAAK+G,SACJ,UAAA/G,MAAKqS,UACF,aAAArS,MAAKsS,aACF,gBAAAtS,MAAKsT,gBACR,aAAAtT,MAAKoT,aACN,YAAApT,MAAK2T,YACN,WAAA3T,MAAK+G,SAEf/G,UAAKyC,MAAAA,SACR,CAAA,GAAkBxC,EAAA,EAAA,IAAAD,MAAAoS,YAAAnS,EAAA,EAAA,IAAAD,MAAAyC,UAAAxC,EAAA,EAAA,IAAAD,MAAA+G,SAAA9G,EAAA,EAAA,IAAAD,MAAAqS,UAAApS,EAAA,EAAA,IAAAD,MAAAsS,aAAArS,EAAA,EAAA,IAAAD,MAAAsT,gBAAArT,EAAA,EAAA,IAAAD,MAAAoT,aAAAnT,EAAA,EAAA,IAAAD,MAAA2T,YAAA1T,QAAAM,OAAAA,MAAAN,EAAA,EAAA,GAXlBM;AAAAA,EAAAA;AAWkBA,MAAAA;AAAAN,IAAA,EAAA,MAAAD,MAAA+G,WAOhBxG,KAAA,WAAWP,MAAK+G,WAAY,OAAO/G,MAAK+G,QAAAxF,SAAmB,WAC3DvB,MAAK+G,QAAAxF,QACH,CAAA,GAAAtB,EAAA,EAAA,IAAAD,MAAA+G,SAAA9G,QAAAM,MAAAA,KAAAN,EAAA,EAAA;AAAAS,MAAAA;AAAAT,IAAAD,EAAAA,MAAAA,MAAA+G,QAAAvF,QAAAvB,EAAAD,EAAAA,MAAAA,MAAA+G,QAAA/E,SAAA/B,UAAAM,MALYG,KAAA;AAAA,IAAAc,MACZxB,MAAK+G,QAAAvF;AAAAA,IAAAQ,OACJhC,MAAK+G,QAAA/E;AAAAA,IAAA,GACRzB;AAAAA,EAAAA,GAGLN,EAAAD,EAAAA,IAAAA,MAAA+G,QAAAvF,MAAAvB,EAAAD,EAAAA,IAAAA,MAAA+G,QAAA/E,OAAA/B,QAAAM,IAAAN,QAAAS,MAAAA,KAAAT,EAAA,EAAA;AAND,QAAAoH,cAAoB3G;AASjBiG,SAAMS,aAAAyF,KAAAmH,CACY3M,kBAAAA,cAAWtG,SAAUf,MAAK+G,QAAA/E,KAC7C,KAEAwJ,QAAAyG,MACE,gCAAgCjS,MAAK+G,QAAA/E,KAAA,aACvC;AAAC+O,MAAAA;AAAA9Q,IAAAoH,EAAAA,MAAAA,eAAApH,EAAA,EAAA,MAAAD,MAAA+G,QAAAvF,QAAAvB,EAAA,EAAA,MAAAD,MAAA+G,QAAA/E,SAOG+O,KAAA1J,eAAW;AAAA,IAAA7F,MACHxB,MAAK+G,QAAAvF;AAAAA,IAAAQ,OACJhC,MAAK+G,QAAA/E;AAAAA,EAAAA,GACb/B,QAAAoH,aAAApH,EAAAD,EAAAA,IAAAA,MAAA+G,QAAAvF,MAAAvB,EAAAD,EAAAA,IAAAA,MAAA+G,QAAA/E,OAAA/B,QAAA8Q,MAAAA,KAAA9Q,EAAA,EAAA;AAAA8T,MAAAA;AAAA,SAAA9T,EAAA,EAAA,MAAAD,MAAAoS,cAAAnS,EAAAD,EAAAA,MAAAA,MAAAyC,YAAAxC,UAAAD,MAAA+G,WAAA9G,EAAA,EAAA,MAAAD,MAAAqS,YAAApS,EAAAD,EAAAA,MAAAA,MAAAsS,eAAArS,UAAA8Q,MANLgD,KAAA,oBAAC,mBACa,EAAA,YAAA/T,MAAKoS,YAEf,aAAArB,IAKO,SAAA/Q,MAAK+G,SACJ,UAAA/G,MAAKqS,UACF,aAAArS,MAAKsS,aAEjBtS,UAAAA,MAAKyC,UACR,GAAoBxC,EAAA,EAAA,IAAAD,MAAAoS,YAAAnS,EAAA,EAAA,IAAAD,MAAAyC,UAAAxC,EAAA,EAAA,IAAAD,MAAA+G,SAAA9G,EAAA,EAAA,IAAAD,MAAAqS,UAAApS,EAAA,EAAA,IAAAD,MAAAsS,aAAArS,QAAA8Q,IAAA9Q,QAAA8T,MAAAA,KAAA9T,EAAA,EAAA,GAbpB8T;AAaoB;AAtGjB,SAAAF,QAAA9B,GAAA;AAAA,SAY0CA,EAAC/I,QAAArC;AAAA;ACtB3C,MAAMsN,4BACXxG,cAAyC,IAAI,GAOlCyG,wBAAwBA,MAAA;AACnC/T,QAAAA,SAAe2Q,WAAAmD,yBAAoC;AAAC,MAAA,CAE/C9T;AAAMmD,UAAAA,IAAAA,MAEP,oGAAsG;AAInGnD,SAAAA;AAAM,GChBTgU,eAAeA,CACnBC,UACAC,aACG;AACHA,WAASD,QAAQ;AACX3R,QAAAA,WAAW2R,SAAS1L,YAAAA,EAAcjG;AACpCA,cACF6R,OAAOC,OAAO9R,QAAQ,EAAE+R,QAAS9R,CAAU,UAAA;AACzCyR,iBAAazR,OAAsB2R,QAAQ;AAAA,EAAA,CAC5C;AAEL;AAEO,SAASI,UAAUL,UAAuB;AAK/C,QAAMM,qBAA8D,CAAE;AACtEP,eAAaC,UAAWO,CAAQ,QAAA;AACXtM,uBAAAA,KAAK,CAACsM,KAAKA,IAAIjM,aAAa,CAAC,GAK9CiM,IAAYC,YAAY,oBAAIC,IAAI;AAAA,EAAA,CACnC;AACKC,QAAAA,iBAAiBV,SAASW,OAAOrM,cAAc;AAErD0L,WAASY,KAAK,GACZZ,SAASW,OAAeE,YAAYH,gBACtCJ,mBAAmBF,QAAQ,CAAC,CAACG,KAAKtG,QAAQ,MAAM;AAChC6G,QAAAA,oBAAoB,GAChCP,IAAYM,YAAY5G;AAAAA,EAAAA,CAC3B;AACH;ACxCO,MAAM8G,gBAAgC;AAAA,EAC3CC,UAAU;AAAA,EACVC,WAAWA,CAAC;AAAA,IAAChH;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC1B6M,UAAAA,wBAAwBjH,SAASrF,QAAQuM,WAAW1I,KACvD2I,CAAcA,cAAAA,UAAUJ,aAAa,6BACxC;AAEA,WAAKE,wBAcE;AAAA,MACL,GANyBA,sBAAsBD,UAAU;AAAA,QACzDhH;AAAAA,QACA5F;AAAAA,MAAAA,CACD;AAAA,MAIC2M,UAAU;AAAA,MACVK,aAAahN,MAAMgN;AAAAA,IAAAA,IAhBZ;AAAA,MACLjF,MAAM;AAAA,MACN4E,UAAU;AAAA,MACVK,aAAahN,MAAMgN;AAAAA,MACnBC,QAAQ;AAAA,IACV;AAAA,EAaJ;AAAA,EACAC,aAAaA,CAAC;AAAA,IAACtH;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC5B6M,UAAAA,wBAAwBjH,SAASrF,QAAQuM,WAAW1I,KACvD2I,CAAcA,cAAAA,UAAUJ,aAAa,6BACxC;AAEA,WAAKE,wBAaE;AAAA,MACL,GAN2BA,sBAAsBK,YAAY;AAAA,QAC7DtH;AAAAA,QACA5F;AAAAA,MAAAA,CACD;AAAA,MAIC2M,UAAU;AAAA,IAAA,IAdH;AAAA,MACL5E,MAAM;AAAA,MACN4E,UAAU;AAAA,MACVM,QAAQ;AAAA,IACV;AAAA,EAAA;AAaN,GChDaE,wBAAwC;AAAA,EACnDR,UAAU;AAAA,EACVC,WAAWA,CAAC;AAAA,IAAChH;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC1B5D,UAAAA,YAAYwJ,SAASrF,QAAQnE;AAEnC,QAAI,CAACA;AACI,aAAA;AAAA,QACL2L,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVK,aAAahN,MAAMgN;AAAAA,QACnBC,QAAQ;AAAA,MACV;AAGF,UAAMG,SAASC,YAAY;AAAA,MACzB9M,SAAS;AAAA,QACPnE;AAAAA,QACA8B,QAAQ0H,SAASrF,QAAQrC;AAAAA,MAC3B;AAAA,MACAkP,QAAQxH,SAASrF,QAAQzH;AAAAA,IAAAA,CAC1B;AAEGsU,WAAAA,OAAO9R,WAAW,IACb;AAAA,MACLyM,MAAM;AAAA,MACN4E,UAAU;AAAA,MACVM,QAAQ;AAAA,MACRD,aAAahN,MAAMgN;AAAAA,IAAAA,IAIhB;AAAA,MACLjF,MAAM;AAAA,MACNuF,MAAMC,KAAKC,UAAUJ,MAAM;AAAA,MAC3BT,UAAU;AAAA,MACVK,aAAahN,MAAMgN;AAAAA,IACrB;AAAA,EACF;AAAA,EACAE,aAAaA,CAAC;AAAA,IAACtH;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAClC,UAAMoN,SAASG,KAAKE,MAAMzN,MAAMsN,IAAI;AAEhC,QAAA,CAACnU,MAAMC,QAAQgU,MAAM;AAChB,aAAA;AAAA,QACLrF,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVM,QAAQ;AAAA,MACV;AAGIS,UAAAA,eAAeN,OAAOO,QAASrU,CAAU,UAAA;AAC7C,YAAMsU,cAAcC,WAAW;AAAA,QAC7BtN,SAASqF,SAASrF;AAAAA,QAClBjH;AAAAA,QACAwU,SAAS;AAAA,UACPC,aAAa;AAAA,UACbC,gBAAgB;AAAA,QAAA;AAAA,MAClB,CACD;AACD,aAAOJ,cAAc,CAACA,WAAW,IAAI,CAAE;AAAA,IAAA,CACxC;AAED,WAAIF,aAAapS,WAAW,KAAK8R,OAAO9R,SAAS,IACxC;AAAA,MACLyM,MAAM;AAAA,MACN4E,UAAU;AAAA,MACVM,QAAQ;AAAA,IAAA,IAIL;AAAA,MACLlF,MAAM;AAAA,MACNuF,MAAMI;AAAAA,MACNf,UAAU;AAAA,IACZ;AAAA,EAAA;AAEJ;ACvEO,SAASsB,wBACdxD,cACA;AACA,SAAuB;AAAA,IACrBkC,UAAU;AAAA,IACVC,WAAWA,CAAC;AAAA,MAAChH;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAC1B5D,YAAAA,YAAYwJ,SAASrF,QAAQnE;AAEnC,UAAI,CAACA;AACI,eAAA;AAAA,UACL2L,MAAM;AAAA,UACN4E,UAAU;AAAA,UACVK,aAAahN,MAAMgN;AAAAA,UACnBC,QAAQ;AAAA,QACV;AAGF,YAAMG,SAASC,YAAY;AAAA,QACzB9M,SAAS;AAAA,UACPnE;AAAAA,UACA8B,QAAQ0H,SAASrF,QAAQrC;AAAAA,QAC3B;AAAA,QACAkP,QAAQxH,SAASrF,QAAQzH;AAAAA,MAAAA,CAC1B,GAEKoV,OAAOC,OAAOf,QAAQ;AAAA,QAC1BgB,oBAAoB;AAAA,QACpBC,YAAY;AAAA,UACVC,aAAaA,CAAC;AAAA,YAACtU;AAAAA,UACbA,MAAAA,aAAaqB,SAAY,GAAGrB,QAAQ,KAAK;AAAA,QAAA;AAAA,MAC7C,CACD;AAED,aAAIkU,SAAS,KACJ;AAAA,QACLnG,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVK,aAAahN,MAAMgN;AAAAA,QACnBC,QAAQ;AAAA,MAAA,IAIL;AAAA,QACLlF,MAAM;AAAA,QACNuF,MAAMY;AAAAA,QACNvB,UAAU;AAAA,QACVK,aAAahN,MAAMgN;AAAAA,MACrB;AAAA,IACF;AAAA,IACAE,aAAaA,CAAC;AAAA,MAACtH;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAOlC,YAAM0N,eANSa,aAAavO,MAAMsN,MAAM7C,aAAa+D,cAAc;AAAA,QACjEC,cAAc7I,SAASrF,QAAQkO;AAAAA,QAC/BC,gCACEjE,aAAanR,MAAMwU,QAAQY;AAAAA,MAAAA,CAC9B,EAE2Bf,QAASrU,CAAU,UAAA;AAC7C,cAAMsU,cAAcC,WAAW;AAAA,UAC7BtN,SAASqF,SAASrF;AAAAA,UAClBjH;AAAAA,UACAwU,SAAS;AAAA,YACPC,aAAa;AAAA,YACbC,gBAAgB;AAAA,UAAA;AAAA,QAClB,CACD;AACD,eAAOJ,cAAc,CAACA,WAAW,IAAI,CAAE;AAAA,MAAA,CACxC;AAEGF,aAAAA,aAAapS,WAAW,IACnB;AAAA,QACLyM,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVM,QAAQ;AAAA,MAAA,IAIL;AAAA,QACLlF,MAAM;AAAA,QACNuF,MAAMI;AAAAA,QACNf,UAAU;AAAA,MACZ;AAAA,IAAA;AAAA,EACF;AAEJ;ACpFO,SAASgC,yBACdlE,cACA;AACA,SAAuB;AAAA,IACrBkC,UAAU;AAAA,IACVC,WAAWA,CAAC;AAAA,MAAChH;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAC1B5D,YAAAA,YAAYwJ,SAASrF,QAAQnE;AAEnC,aAAKA,YAiDE;AAAA,QACL2L,MAAM;AAAA,QACNuF,MA1CaD,YAAY;AAAA,UACzB9M,SAAS;AAAA,YACPnE;AAAAA,YACA8B,QAAQ0H,SAASrF,QAAQrC;AAAAA,UAC3B;AAAA,UACAkP,QAAQxH,SAASrF,QAAQzH;AAAAA,QAAAA,CAC1B,EAGEO,IAAKC,CAAAA,UACA0F,YAAY4G,SAASrF,SAASjH,KAAK,IAC9BA,MAAMU,SACVX,IAAKY,CAAAA,UACAA,MAAMV,UAAUqM,SAASrF,QAAQrC,OAAO0Q,KAAKtW,OACxC2B,MAAMI,OAGR2F,MAAMgN,gBAAgB,mBACzB,IACEpH,SAASrF,QAAQrC,OAAOgM,cAAc9F,KACnCyK,CAAAA,qBACCA,iBAAiBvW,SAAS2B,MAAMV,KACpC,GAAGuV,SAAS,QAAQ,MAEtB,EACL,EACArT,KAAK,EAAE,IAGLuE,MAAMgN,gBAAgB,mBACzB,IACEpH,SAASrF,QAAQrC,OAAOS,aAAayF,KAClC2K,CAAAA,oBAAoBA,gBAAgBzW,SAASgB,MAAMC,KACtD,GAAGuV,SAAS,QAAQ,MAEtB,EACL,EACAE,OAAQ1V,CAAAA,UAAUA,UAAU,EAAE,EAC9BmC,KAAK;AAAA;AAAA,CAAM;AAAA,QAKZkR,UAAU;AAAA,QACVK,aAAahN,MAAMgN;AAAAA,MAAAA,IApDZ;AAAA,QACLjF,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVK,aAAahN,MAAMgN;AAAAA,QACnBC,QAAQ;AAAA,MACV;AAAA,IAiDJ;AAAA,IACAC,aAAaA,CAAC;AAAA,MAACtH;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAUlC,YAAMiP,aAAa,eATNC,WAAWlP,MAAMsN,IAAI,EAC/B6B,MAAM,QAAQ,EACd9V,IAAK+V,CACJA,SAAAA,OACI,MAAMA,KAAKC,QAAQ,mBAAmB,OAAO,CAAC,SAC9C,SACN,EACC5T,KAAK,EAAE,CAE4B,kBAMhCiS,eAJSa,aAAaU,YAAYxE,aAAa+D,cAAc;AAAA,QACjEC,cAAc7I,SAASrF,QAAQkO;AAAAA,MAAAA,CAChC,EAE2Bd,QAASrU,CAAU,UAAA;AAC7C,cAAMsU,cAAcC,WAAW;AAAA,UAC7BtN,SAASqF,SAASrF;AAAAA,UAClBjH;AAAAA,UACAwU,SAAS;AAAA,YACPC,aAAa;AAAA,YACbC,gBAAgB;AAAA,UAAA;AAAA,QAClB,CACD;AACD,eAAOJ,cAAc,CAACA,WAAW,IAAI,CAAE;AAAA,MAAA,CACxC;AAEGF,aAAAA,aAAapS,WAAW,IACnB;AAAA,QACLyM,MAAM;AAAA,QACN4E,UAAU;AAAA,QACVM,QAAQ;AAAA,MAAA,IAIL;AAAA,QACLlF,MAAM;AAAA,QACNuF,MAAMI;AAAAA,QACNf,UAAU;AAAA,MACZ;AAAA,IAAA;AAAA,EACF;AAEJ;AAEA,MAAM2C,YAAoC;AAAA,EACxC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACP;AAEA,SAASJ,WAAWnI,KAAa;AACxBwI,SAAAA,OAAOxI,GAAG,EAAEsI,QAAQ,eAAgB/F,CAAcgG,MAAAA,UAAUhG,CAAC,CAAC;AACvE;AC3HO,SAASkG,qBACd/E,cACA;AACO,SAAA,CACLiC,eACAS,uBACAc,wBAAwBxD,YAAY,GACpCkE,yBAAyBlE,YAAY,CAAC;AAE1C;ACbO,SAASgF,YAAYC,SAAc;AACxC,SAAOC,OAAOC,QAAQ;AAAA,IACpBtX,MAAM;AAAA,IACNuX,OAAO,CAACH,OAAO;AAAA,EAAA,CAChB,EAAEI,IAAIJ,QAAQpX,IAAI;AACrB;ACLO,SAASyX,uBACdxP,SACA;AACO,SAAA;AAAA,IACLhH,OAAOgH,QAAQrC,OAAO5E,MAAMhB;AAAAA,IAC5BS,MAAMwH,QAAQkO,aAAa;AAAA,IAC3B7U,OAAO2G,QAAQrC,OAAOxD,OAAO,CAAC,EAAEpC,QAAQ;AAAA,IACxCwB,UAAU,CAAE;AAAA,IACZE,UAAU,CACR;AAAA,MACET,OAAOgH,QAAQrC,OAAO0Q,KAAKtW;AAAAA,MAC3BS,MAAMwH,QAAQkO,aAAa;AAAA,MAC3BpU,MAAM;AAAA,MACNC,OAAO,CAAA;AAAA,IACR,CAAA;AAAA,EAEL;AACF;AChBO,SAAS0V,qBAAqB;AAAA,EACnCC;AAAAA,EACA/R;AAIF,GAAG;AACD,UAAQ+R,WAAW3V,SAAS,CAAA,GAAI0U,OAC7BkB,UACC,CAAChS,OAAOiS,WAAW9W,IAAK+W,eAAcA,UAAU9X,IAAI,EAAE+X,SAASH,IAAI,CACvE;AACF;ACXO,SAASI,oBAAoB;AAAA,EAClCC;AAAAA,EACAN;AAAAA,EACA/R;AAKF,GAAG;AACD,QAAMiS,aAAajS,OAAOiS,WAAW9W,IAAK+W,CAAAA,cAAcA,UAAU9X,IAAI;AAMlEkY,MAAAA,oBAJyBP,WAAW3V,SAAS,CAAE,GAAE0U,OAAQkB,CAC3DC,SAAAA,WAAWE,SAASH,IAAI,CAC1B;AAIA,aAAWE,aAAaG;AAClBA,mBAAeH,SAAS,MAAM,KAChCI,mBAAmBA,iBAAiBxB,OACjCyB,qBAAoBA,oBAAoBL,SAC3C,IACSG,eAAeH,SAAS,MAAM,OAClCI,iBAAiBH,SAASD,SAAS,KACtCI,iBAAiB5Q,KAAKwQ,SAAS;AAK9BI,SAAAA;AACT;AC3BO,MAAME,oCAETA,CAAC;AAAA,EAACnQ;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAM6M,mBAAmBF,oBAAoB;AAAA,IAC3CC,gBAAgB5M,UAAUjM,OAAO6Y;AAAAA,IACjCN,WAAWtM,UAAUjM,OAAOuY;AAAAA,IAC5B/R,QAAQqC,QAAQrC;AAAAA,EAAAA,CACjB,GACKyS,oBAAoBX,qBAAqB;AAAA,IAC7CC,WAAWtM,UAAUjM,OAAOuY;AAAAA,IAC5B/R,QAAQqC,QAAQrC;AAAAA,EAAAA,CACjB,GAEK,CAAC0S,SAAS,IAAInU,aAAa;AAAA,IAC/B/E,QAAQiM,UAAUjM;AAAAA,EAAAA,CACnB;AAED,MAAI,CAACkZ,WAAW;AACdC,eAAWC,WAAWnN,UAAUjM,QAAQiM,UAAUtJ,IAAI;AACtD;AAAA,EAAA;AAGF,MACEsJ,UAAUjM,OAAOuY,aACjBtM,UAAUjM,OAAOuY,UAAUc,UAAU,aACrC;AACA,UAAMC,uBAAuBrN,UAAUjM,OAAOuY,UAAU3V,SAAS,CAAA,GAAI0U,OAClEkB,CAAAA,SACC3P,QAAQrC,OAAOiS,WACZ9W,IAAK+W,CAAcA,cAAAA,UAAU9X,IAAI,EACjC+X,SAASH,IAAI,CACpB;AAGEc,QAAAA,oBAAoB1V,WAAWkV,iBAAiBlV,UAChD0V,oBAAoB/R,MAAOiR,CAAAA,SAASM,iBAAiBH,SAASH,IAAI,CAAC,GACnE;AACAW,iBAAWC,WAAWnN,UAAUjM,QAAQiM,UAAUtJ,IAAI;AACtD;AAAA,IAAA;AAAA,EACF;AAGS4W,aAAAA,YAAYtN,UAAUjM,QAAQ;AAAA,IACvC6B,OAAOqX,UAAUrX;AAAAA,IACjBR,MAAMwH,QAAQkO,aAAa;AAAA,IAC3BpU,MAAMsJ,UAAUtJ;AAAAA,IAChBC,OAAO,CAAC,GAAGkW,kBAAkB,GAAGG,iBAAiB;AAAA,EAClD,CAAA,GAEDhN,UAAUjM,OAAO6Y,iBAAiB,CAAC;AACrC;ACxCO,SAASW,mBACd7U,MAC0B;AAExB,SAAAA,KAAK9C,oBACL,UAAU8C,QACV,OAAOA,KAAKhC,QAAS,oBACbgC,KAAK/B,QAAU,OACpBnB,MAAMC,QAAQiD,KAAK/B,KAAK,KAAK+B,KAAK/B,MAAM2E,MAAOiR,UAAS,OAAOA,QAAS,QAAQ;AAEvF;AAQO,SAASiB,oBACd9U,MAC2B;AAC3B;AAAA;AAAA;AAAA,IAGE,OAAOA,KAAK9C,SAAU;AAAA,IAEtB8C,KAAK9C,MAAM,CAAC,MAAM;AAAA,KAEjB,EAAE,cAAc8C,SACdA,CAAAA,KAAKvC,YACLX,MAAMC,QAAQiD,KAAKvC,QAAQ;AAAA,IAE1BuC,KAAKvC,SAASmF,MAAOmS,SAAQ,OAAOA,IAAIrY,QAAS,QAAQ;AAAA,IAE7D,cAAcsD,QACdlD,MAAMC,QAAQiD,KAAKrC,QAAQ;AAAA,IAE3BqC,KAAKrC,SAASiF,MAAOhF,WAAU,OAAOA,SAAU,YAAY,WAAWA,KAAK;AAAA;AAEhF;ACnDO,SAASoX,gBAAgB;AAAA,EAC9B3Z;AAAAA,EACAiE;AAAAA,EACA2V;AAKF,GAAiC;AAC3BC,MAAAA;AAEJ,aAAW,CAACtX,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQiE,WAAW;AAAA,IAChE6V,SAAS;AAAA,EAAA,CACV;AACM9Z,QAAAA,OAAOgF,WAAWzC,KAAK,KAIxBwX,KAAKC,SAASnO,WAAW+N,QAAQ,GAAG;AACvBrX,qBAAAA;AACf;AAAA,IAAA;AAIGsX,SAAAA;AACT;AAEO,SAASI,YAAY;AAAA,EAC1Bja;AAAAA,EACAiE;AAAAA,EACA2V;AAKF,GAAiC;AAC3BM,MAAAA;AAEJ,aAAW,CAAC3X,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQiE,SAAS;AACzDjE,QAAAA,OAAOgF,WAAWzC,KAAK,KAIxBwX,KAAKI,QAAQtO,WAAW+N,QAAQ,GAAG;AAC1BrX,iBAAAA;AACX;AAAA,IAAA;AAIG2X,SAAAA;AACT;ACnDgBE,SAAAA,kBAAkBpa,QAAgBqa,IAAsB;AAChEC,QAAAA,OAAOC,mBAAmBva,MAAM,KAAK;AACdwa,+BAAAA,IAAIxa,QAAQ,EAAI,GAC7Cqa,GACArN,GAAAA,6BAA6BwN,IAAIxa,QAAQsa,IAAI;AAC/C;AAEO,SAASC,mBAAmBva,QAAqC;AAC/DgN,SAAAA,6BAA6BoL,IAAIpY,MAAM;AAChD;ACVA,MAAMya,YAAsDxN,oBAAAA,QAAAA,GACtDyN,iCAAuDzN,QAAQ;AAErD0N,SAAAA,YAAY3a,QAAgBqa,IAAgB;AACpDC,QAAAA,OAAOM,UAAU5a,MAAM;AACnBwa,YAAAA,IAAIxa,QAAQ,EAAI,GAC1Bqa,GACAI,GAAAA,UAAUD,IAAIxa,QAAQsa,IAAI;AAC5B;AAEO,SAASM,UAAU5a,QAAgB;AACjCya,SAAAA,UAAUrC,IAAIpY,MAAM,KAAK;AAClC;AAEgB6a,SAAAA,aAAa7a,QAAgB4a,YAAoB;AACrDJ,YAAAA,IAAIxa,QAAQ4a,UAAS;AACjC;AAEgBE,SAAAA,YAAY9a,QAAgBqa,IAAgB;AACpDC,QAAAA,OAAOS,UAAU/a,MAAM;AAClBwa,aAAAA,IAAIxa,QAAQ,EAAI,GAC3Bqa,GACAK,GAAAA,WAAWF,IAAIxa,QAAQsa,IAAI;AAC7B;AAEO,SAASS,UAAU/a,QAAgB;AACjC0a,SAAAA,WAAWtC,IAAIpY,MAAM,KAAK;AACnC;AAEgBgb,SAAAA,aAAahb,QAAgB+a,YAAoB;AACpDP,aAAAA,IAAIxa,QAAQ+a,UAAS;AAClC;ACxBA,SAASE,eAAkBC,GAAMC,GAAM;AACrC,SAAOD,MAAMC;AACf;AA+BOC,SAAAA,kBAAApb,QAAAqb,UAAAjb,IAAA;AAAA,QAAAN,IAAAC,EAAA,CAAA,GAGLub,UAAAlb,OAAiEuD,SAAAsX,iBAAjE7a;AAAiEG,MAAAA;AAAAT,SAAAA,EAAAE,CAAAA,MAAAA,UAAAF,SAAAub,YAI/D9a,KAAAgb,CAAA,wBAAA;AACE,UAAArN,WAAiBsN,kBAAA;AAAA,MAAAD;AAAAA,MAAAE,qBAEOzb,OAAM0b,UAAArT,YAAAsT;AAAAA,IAAAA,CAE7B;AAAC,WAEKN,SAASnN,QAAQ;AAAA,EAAA,GACzBpO,OAAAE,QAAAF,OAAAub,UAAAvb,OAAAS,MAAAA,KAAAT,EAAA,CAAA,GAVI6R,YACJ3R,OAAM0b,UAAAtT,aACP7H,IASA+a,OACF;AAAC;AAGI,SAASE,kBAAkB;AAAA,EAChCD;AAAAA,EACAE;AAIF,GAAmB;AACV,SAAA;AAAA,IACL5S,SAAS;AAAA,MACPuM,YAAY,CAAC,GAAGmG,oBAAoB1S,QAAQuM,UAAU;AAAA,MACtD2B,cAAcwE,oBAAoB1S,QAAQkO;AAAAA,MAC1C7E,UAAUqJ,oBAAoB/S,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY;AAAA,MAChEhC,QAAQ+U,oBAAoB1S,QAAQrC;AAAAA,MACpC9B,WAAW6W,oBAAoB1S,QAAQnE;AAAAA,MACvCtD,OAAOqa,oBAAoBra;AAAAA,IAC7B;AAAA,IACAwa,MAAM;AAAA,MACJ3C,mBAAmBX,qBAAqB;AAAA,QACtCC,WAAWkD,oBAAoBlD;AAAAA,QAC/B/R,QAAQ+U,oBAAoB1S,QAAQrC;AAAAA,MAAAA,CACrC;AAAA,MACDsS,kBAAkBF,oBAAoB;AAAA,QACpCC,gBAAgB4C,oBAAoB5C;AAAAA,QACpCN,WAAWkD,oBAAoBlD;AAAAA,QAC/B/R,QAAQ+U,oBAAoB1S,QAAQrC;AAAAA,MACrC,CAAA;AAAA,IAAA;AAAA,EAEL;AACF;ACvEA,MAAM9F,UAAQC,cAAc,kCAAkC;AAEvD,SAASkb,gCACdzT,aAC8D;AAC9D,SAAO,SAAmCpI,QAAiC;AACnE,UAAA;AAAA,MAAC8b,OAAAA;AAAAA,MAAOC;AAAAA,IAAiB/b,IAAAA,QACzByY,aAAarQ,YAChBG,YAAY,EACZM,QAAQrC,OAAOiS,WAAW9W,IAAK4B,CAAMA,MAAAA,EAAE3C,IAAI;AAG9CZ,WAAAA,OAAO+b,gBAAiBC,CAAc,cAAA;AAC9B,YAAA,CAACrX,MAAME,IAAI,IAAImX;AAEjBhc,UAAAA,OAAOsH,YAAY3C,IAAI,GAAG;AAC5B,cAAMrC,WAAW0D,KAAK1D,SAAStC,QAAQ6E,IAAI;AAE3C,mBAAW,CAACtC,OAAOsJ,SAAS,KAAKvJ,UAAU;AACzC,gBAAM2Z,WAAWtX,KAAKrC,SAASuJ,UAAU,CAAC,IAAI,CAAC;AAG7C7L,cAAAA,OAAOgF,WAAWzC,KAAK,KACvBvC,OAAOgF,WAAWiX,QAAQ,KAC1B1Z,MAAMK,OAAO2E,MAAOiR,CAASyD,SAAAA,SAASrZ,OAAO+V,SAASH,IAAI,CAAC,KAC3DyD,SAASrZ,OAAO2E,MAAOiR,CAASjW,SAAAA,MAAMK,OAAO+V,SAASH,IAAI,CAAC,GAC3D;AACA9X,oBACE,iBACAmV,KAAKC,UAAUvT,OAAO,MAAM,CAAC,GAC7BsT,KAAKC,UAAUmG,UAAU,MAAM,CAAC,CAClC,GACA7T,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAc,GACtC8I,WAAW+C,WAAWlc,QAAQ;AAAA,cAC5BqE,IAAI,CAACwH,UAAU,CAAC,GAAGA,UAAU,CAAC,IAAI,CAAC;AAAA,cACnCsQ,OAAO;AAAA,YAAA,CACR,GACD/T,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAmB;AAC3C;AAAA,UAAA;AAAA,QACF;AAAA,MACF;AAMErQ,UAAAA,OAAOsH,YAAY3C,IAAI,KAAK,CAAClD,MAAMC,QAAQiD,KAAKvC,QAAQ,GAAG;AACvD1B,gBAAA,gCAAgC,GACtC0H,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAc,GACtC8I,WAAWiD,SAASpc,QAAQ;AAAA,UAACoC,UAAU,CAAA;AAAA,QAAA,GAAK;AAAA,UAACiC,IAAIQ;AAAAA,QAAAA,CAAK,GACtDuD,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAmB;AAC3C;AAAA,MAAA;AAMErQ,UAAAA,OAAOgF,WAAWL,IAAI,KAAK,CAAClD,MAAMC,QAAQiD,KAAK/B,KAAK,GAAG;AACnDlC,gBAAA,4BAA4B,GAClC0H,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAc,GACtC8I,WAAWiD,SAASpc,QAAQ;AAAA,UAAC4C,OAAO,CAAA;AAAA,QAAA,GAAK;AAAA,UAACyB,IAAIQ;AAAAA,QAAAA,CAAK,GACnDuD,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAmB;AAC3C;AAAA,MAAA;AAMErQ,UAAAA,OAAOgF,WAAWL,IAAI,GAAG;AAC3B,cAAMV,YAAY8V,KAAKlT,OAAOhC,IAAI,GAC5B,CAACjD,KAAK,IAAIuC,OAAOQ,KAAK3E,QAAQiE,SAAS,GACvCwU,cAAarQ,YAChBG,YAAY,EACZM,QAAQrC,OAAOiS,WAAW9W,IAAK+W,CAAcA,cAAAA,UAAU9X,IAAI,GACxDgS,cAAcjO,KAAK/B,OAAO0U,OAC7BkB,CAAS,SAAA,CAACC,YAAWE,SAASH,IAAI,CACrC;AAEIxY,YAAAA,OAAOsH,YAAY1F,KAAK,KACtB+C,KAAKhC,SAAS,MAAMiQ,eAAeA,YAAYhP,SAAS,GAAG;AACvDlD,kBAAA,2CAA2C,GACjD0H,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,YAAC4C,OAAO+B,KAAK/B,OAAO0U,OAAQkB,UAASC,YAAWE,SAASH,IAAI,CAAC;AAAA,UAAA,GAC9D;AAAA,YAACnU,IAAIQ;AAAAA,UAAAA,CACP,GACAuD,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAmB;AAC3C;AAAA,QAAA;AAAA,MACF;AAOArQ,UAAAA,OAAOsH,YAAY3C,IAAI,GAAG;AACtB8T,cAAAA,cAAarQ,YAChBG,YAAAA,EACAM,QAAQrC,OAAOiS,WAAW9W,IAAK+W,CAAcA,cAAAA,UAAU9X,IAAI;AAE9D,mBAAW,CAAC2B,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQ6E,IAAI;AACrD7E,cAAAA,OAAOgF,WAAWzC,KAAK,GAAG;AACtBK,kBAAAA,QAAQL,MAAMK,SAAS,IACvByZ,sBAAsBzZ,MAAM0U,OAAQkB,CAAAA,SAEtC,CAACC,YAAWE,SAASH,IAAI,KACzB,CAAC7T,KAAKvC,UAAUsK,KAAMgN,CAAQA,QAAAA,IAAIrY,SAASmX,IAAI,CAElD;AAEG6D,gBAAAA,oBAAoBzY,SAAS,GAAG;AAC5BlD,sBAAA,8CAA8C,GACpD0H,YAAY2I,KAAK;AAAA,gBAACV,MAAM;AAAA,cAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,gBACE4C,OAAOA,MAAM0U,OACVkB,CAAAA,SAAS,CAAC6D,oBAAoB1D,SAASH,IAAI,CAC9C;AAAA,cAAA,GAEF;AAAA,gBAACnU,IAAIwH;AAAAA,cAAAA,CACP,GACAzD,YAAY2I,KAAK;AAAA,gBAACV,MAAM;AAAA,cAAA,CAAmB;AAC3C;AAAA,YAAA;AAAA,UACF;AAAA,MACF;AAOArQ,UAAAA,OAAOgF,WAAWL,IAAI,GAAG;AACrBV,cAAAA,YAAY8V,KAAKlT,OAAOhC,IAAI,GAC5B,CAACjD,KAAK,IAAIuC,OAAOQ,KAAK3E,QAAQiE,SAAS;AAEzCjE,YAAAA,OAAOsH,YAAY1F,KAAK,GAAG;AAC7B,gBAAM6W,cAAarQ,YAChBG,YAAY,EACZM,QAAQrC,OAAOiS,WAAW9W,IAAK+W,CAAAA,cAAcA,UAAU9X,IAAI,GACxDgC,QAAQ+B,KAAK/B,SAAS,CAAE,GACxByZ,sBAAsBzZ,MAAM0U,OAAQkB,CAAAA,SAEtC,CAACC,YAAWE,SAASH,IAAI,KACzB,CAAC5W,MAAMQ,UAAUsK,KAAMgN,CAAAA,QAAQA,IAAIrY,SAASmX,IAAI,CAEnD;AAEG6D,cAAAA,oBAAoBzY,SAAS,GAAG;AAC5BlD,oBAAA,8CAA8C,GACpD0H,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,cACE4C,OAAOA,MAAM0U,OACVkB,CAAAA,SAAS,CAAC6D,oBAAoB1D,SAASH,IAAI,CAC9C;AAAA,YAAA,GAEF;AAAA,cAACnU,IAAIQ;AAAAA,YAAAA,CACP,GACAuD,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAmB;AAC3C;AAAA,UAAA;AAAA,QACF;AAAA,MACF;AAIErQ,UAAAA,OAAOsH,YAAY3C,IAAI,GAAG;AACtBvC,cAAAA,WAAWuC,KAAKvC,YAAY,CAAA,GAC5Bka,cAAkB5H,oBAAAA,OAClB6H,cAAyC,CAAE;AAEjD,mBAAWC,WAAWpa;AACfka,sBAAYG,IAAID,QAAQnb,IAAI,MAC/Bib,YAAYI,IAAIF,QAAQnb,IAAI,GAC5Bkb,YAAYrU,KAAKsU,OAAO;AAIxBpa,YAAAA,SAASwB,WAAW2Y,YAAY3Y,QAAQ;AACpClD,kBAAA,6BAA6B,GACnC0H,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAc,GACtC8I,WAAWiD,SAASpc,QAAQ;AAAA,YAACoC,UAAUma;AAAAA,UAAAA,GAAc;AAAA,YAAClY,IAAIQ;AAAAA,UAAAA,CAAK,GAC/DuD,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAmB;AAC3C;AAAA,QAAA;AAAA,MACF;AAIF,UACErQ,OAAOsH,YAAY3C,IAAI,KACvB,CAAC3E,OAAO2c,WAAW5V,KAChB6V,CAAAA,OACCA,GAAGvM,SAAS,gBACZ,cAAcuM,GAAGC,cACjBD,GAAG/X,KAAKjB,WAAW,CACvB,GACA;AACM2Y,cAAAA,eAAe5X,KAAKvC,YAAY,CAAA,GAAIkV,OAAQoC,CAAAA,QACzC/U,KAAKrC,SAASoK,KAAMnK,CAAAA,UAEvBsB,KAAKC,OAAOvB,KAAK,KACjBd,MAAMC,QAAQa,MAAMK,KAAK,KACzBL,MAAMK,MAAM+V,SAASe,IAAIrY,IAAI,CAEhC,CACF;AACD,YAAIsD,KAAKvC,YAAY,CAACd,QAAQib,aAAa5X,KAAKvC,QAAQ,GAAG;AACnD1B,kBAAA,6BAA6B,GACnC0H,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,YACEoC,UAAUma;AAAAA,UAAAA,GAEZ;AAAA,YAAClY,IAAIQ;AAAAA,UAAAA,CACP,GACAuD,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAmB;AAC3C;AAAA,QAAA;AAAA,MACF;AAGF0L,oBAAcC,SAAS;AAAA,IAAA,GAGzBhc,OAAO8b,QAASc,CAAO,OAAA;AAKjBrC,UAAAA,mBAAmBva,MAAM,GAAG;AAC9B8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAOF,UAAIhC,UAAU5a,MAAM,KAAK+a,UAAU/a,MAAM,GAAG;AAC1C8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAGF,UAAIA,GAAGvM,SAAS,mBAEZuM,GAAGC,cACHD,GAAGE,iBACHF,GAAGC,WAAWhV,UACd+U,GAAGC,WAAWjY,SACdgY,GAAGE,cAAcjV,UACjB+U,GAAGE,cAAclY,OACjB;AACMmY,cAAAA,+BAA+B3X,MAAM4M,YAAY;AAAA,UACrDnK,QAAQ+U,GAAGC,WAAWhV;AAAAA,UACtBjD,OAAOgY,GAAGC,WAAWjY;AAAAA,QAAAA,CACtB,GACKoY,0BAA0B5X,MAAM4M,YAAY;AAAA,UAChDnK,QAAQ+U,GAAGE,cAAcjV;AAAAA,UACzBjD,OAAOgY,GAAGE,cAAclY;AAAAA,QAAAA,CACzB;AAED,YAAImY,gCAAgCC,yBAAyB;AAC3D,gBAAM9D,YAA0CzX,MAAMyC,KACpDC,OAAOC,MAAMpE,QAAQ;AAAA,YACnB8G,MAAM;AAAA,YACNzC,IAAIuY,GAAGC,WAAWjY;AAAAA,YAClBN,OAAQC,CAAAA,MAAMvE,OAAOgF,WAAWT,CAAC;AAAA,YACjC4X,OAAO;AAAA,UACR,CAAA,CACH,EAAE,CAAC,IAAI,CAAC,GACFc,eAA6Cxb,MAAMyC,KACvDC,OAAOC,MAAMpE,QAAQ;AAAA,YACnB8G,MAAM;AAAA,YACNzC,IAAIuY,GAAGE,cAAclY;AAAAA,YACrBN,OAAQC,CAAAA,MAAMvE,OAAOgF,WAAWT,CAAC;AAAA,YACjC4X,OAAO;AAAA,UAAA,CACR,CACH,EAAE,CAAC,IAAI,CAAC,GACFe,kBACJhE,aACA+D,gBACAL,GAAGE,cAAclY,MAAMC,KAAK,CAAC,MAAM+X,GAAGC,WAAWjY,MAAMC,KAAK,CAAC,KAC7D+X,GAAGE,cAAclY,MAAMC,KAAK,CAAC,MAC3B+X,GAAGC,WAAWjY,MAAMC,KAAK,CAAC,IAAI,KAChCqU,UAAUvW,KAAKiB,WAAWgZ,GAAGC,WAAWjY,MAAMmD,UAC9C6U,GAAGE,cAAclY,MAAMmD,WAAW,GAC9BoV,sBACJjE,aACA+D,gBACAL,GAAGE,cAAclY,MAAMC,KAAK,CAAC,MAAM+X,GAAGC,WAAWjY,MAAMC,KAAK,CAAC,KAC7D+X,GAAGE,cAAclY,MAAMC,KAAK,CAAC,MAC3B+X,GAAGC,WAAWjY,MAAMC,KAAK,CAAC,IAAI,KAChC+X,GAAGC,WAAWjY,MAAMmD,WAAW,KAC/BkV,aAAata,KAAKiB,WAAWgZ,GAAGE,cAAclY,MAAMmD;AAIlD,WAACmV,mBAAmB,CAACC,wBACvBnd,OAAO6Y,iBAAiB,CAAA;AAAA,QAAC;AAAA,MAE7B;AAIA+D,UAAAA,GAAGvM,SAAS,eAAe;AACvB,cAAA;AAAA,UAAC3L;AAAAA,QAAAA,IAAa1E;AAEpB,YAAI0E,WAAW;AACb,gBAAM,CAAC0Y,QAAQnZ,SAAS,IAAIE,OAAOQ,KAAK3E,QAAQ0E,WAAW;AAAA,YAAC2Y,OAAO;AAAA,UAAA,CAAE,GAC/DxD,eAAeF,gBAAgB;AAAA,YACnC3Z;AAAAA,YACAiE;AAAAA,YACA2V,UAAUgD,GAAG/X;AAAAA,UAAAA,CACd,GACKyY,0BAA0BzD,eAC5BA,aAAajX,OAAO0U,OAAQkB,CAAAA,SAAS,CAACC,WAAWE,SAASH,IAAI,CAAC,IAC/D,CAAE,GAEA0B,WAAWD,YAAY;AAAA,YAC3Bja;AAAAA,YACAiE;AAAAA,YACA2V,UAAU,CAACgD,GAAG/X,KAAK,CAAC,GAAG+X,GAAG/X,KAAK,CAAC,IAAI,CAAC;AAAA,UACtC,CAAA,GACK0Y,sBAAsBrD,WACxBA,SAAStX,OAAO0U,OAAQkB,CAAAA,SAAS,CAACC,WAAWE,SAASH,IAAI,CAAC,IAC3D,CAEEgF,GAAAA,oBACJF,yBAAyBhG,OACtBmG,CAAe,eAAA,CAACF,qBAAqB5E,SAAS8E,UAAU,CAC3D,KAAK,CAAA,GACDC,uBAAuBF,kBAAkB5Z,SAAS;AAExD,cACE8Z,wBACAlE,mBAAmBoD,GAAGjY,IAAI,KAC1BiY,GAAGjY,KAAK/B,OAAOmE,KAAMyR,CAASgF,SAAAA,kBAAkB7E,SAASH,IAAI,CAAC,GAC9D;AACAW,uBAAWI,YAAYvZ,QAAQ;AAAA,cAC7B,GAAG4c,GAAGjY;AAAAA,cACNtD,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,cACrDnU,OACEga,GAAGjY,KAAK/B,OAAO0U,OACZkB,CAAAA,SAAS,CAACgF,kBAAkB7E,SAASH,IAAI,CAC5C,KAAK,CAAA;AAAA,YAAA,CACR;AACD;AAAA,UAAA;AAGF,gBAAMmF,sBACJJ,qBAAqBjG,OAClBmG,CAAAA,eAAe,CAACH,yBAAyB3E,SAAS8E,UAAU,CAC/D,KAAK,CACDG,GAAAA,yBAAyBD,oBAAoB/Z,SAAS;AAE5D,cACEga,0BACApE,mBAAmBoD,GAAGjY,IAAI,KAC1BiY,GAAGjY,KAAK/B,OAAOmE,KAAMyR,CAASmF,SAAAA,oBAAoBhF,SAASH,IAAI,CAAC,GAChE;AACAW,uBAAWI,YAAYvZ,QAAQ;AAAA,cAC7B,GAAG4c,GAAGjY;AAAAA,cACNtD,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,cACrDnU,OACEga,GAAGjY,KAAK/B,OAAO0U,OACZkB,CAAAA,SAAS,CAACmF,oBAAoBhF,SAASH,IAAI,CAC9C,KAAK,CAAA;AAAA,YAAA,CACR;AACD;AAAA,UAAA;AAGIqF,gBAAAA,qBACJ3D,UAAUtX,OAAO0U,OAAQkB,CAAAA,SAASC,WAAWE,SAASH,IAAI,CAAC,KAAK,CAAE;AAGpE,cAF0BqF,mBAAmBja,SAAS,KAIpD8Z,wBACA,CAACE,0BACDpE,mBAAmBoD,GAAGjY,IAAI,KAC1BiY,GAAGjY,KAAK/B,OAAOgB,WAAW,GAC1B;AACAuV,uBAAWI,YAAYvZ,QAAQ;AAAA,cAC7B,GAAG4c,GAAGjY;AAAAA,cACNtD,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,cACrDnU,OAAOib;AAAAA,YAAAA,CACR;AACD;AAAA,UAAA;AAAA,QACF;AAAA,MACF;AAGEjB,UAAAA,GAAGvM,SAAS,eAAe;AACzB,YAAA,CAACrQ,OAAOuY,WAAW;AACrBuD,UAAAA,OAAMc,EAAE;AACR;AAAA,QAAA;AAGE5c,YAAAA,OAAOuY,UAAUc,UAAU,aAAa;AAC1CyC,UAAAA,OAAMc,EAAE;AACR;AAAA,QAAA;AAGFzD,mBAAWI,YAAYvZ,QAAQ;AAAA,UAC7B6B,OAAO;AAAA,UACPR,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,UACrDpU,MAAMia,GAAGja;AAAAA,UACTC,OAAO5C,OAAOuY,UAAU3V;AAAAA,QAAAA,CACzB;AAED;AAAA,MAAA;AAGEga,UAAAA,GAAGvM,SAAS,eAAe;AACvB,cAAA;AAAA,UAAC3L;AAAAA,QAAAA,IAAa1E;AAEpB,YAAI0E,aAAaU,MAAM0Y,WAAWpZ,SAAS,GAAG;AAC5C,gBAAM,CAAC9C,OAAOqC,SAAS,IAAIE,OAAOQ,KAAK3E,QAAQ0E,WAAW;AAAA,YACxD2Y,OAAO;AAAA,UAAA,CACR,GACK,CAACnG,MAAM0C,QAAQ,IACnBnY,MAAMyC,KACJC,OAAOC,MAAMpE,QAAQ;AAAA,YACnB8G,MAAM;AAAA,YACNzC,IAAI;AAAA,cAACQ,MAAM+X,GAAG/X;AAAAA,cAAMkD,QAAQ6U,GAAG7U;AAAAA,YAAM;AAAA,YACrCzD,OAAQC,CAAAA,MAAMvE,OAAOgF,WAAWT,CAAC;AAAA,YACjC4X,OAAO;AAAA,UACR,CAAA,CACH,EAAE,CAAC,KAAM,CAACxY,QAAWA,MAAS;AAEhC,cAAIuT,QAAQtV,SAAS6X,oBAAoB7X,KAAK,GAAG;AAC/C,kBAAMQ,WAAWR,MAAMQ,YAAY,CAAE,GAC/BQ,QAAQsU,KAAKtU,SAAS,CAAE,GACxBmb,qBAAqBnb,MAAMmE,KAAMyR,CACrCpW,SAAAA,SAASsK,KAAM8P,CAAYA,YAAAA,QAAQnb,SAASmX,IAAI,CAClD,GACMwF,qBACJpB,GAAG7U,SAAS6U,GAAGja,KAAKiB,WAAWsT,KAAKvU,KAAKiB,QACrCqa,kBAAkBrB,GAAG7U,WAAW,KAAKiW,oBAErCnE,eAAeF,gBAAgB;AAAA,cAAC3Z;AAAAA,cAAQiE;AAAAA,cAAW2V;AAAAA,YAAAA,CAAS,GAC5DM,WAAWD,YAAY;AAAA,cAACja;AAAAA,cAAQiE;AAAAA,cAAW2V;AAAAA,YAAAA,CAAS,GAEpDsE,gCAAgCrE,eAClCA,aAAajX,OAAOmE,KACjByR,CAAS,SAAA,CAACC,WAAWE,SAASH,IAAI,KAAK5V,MAAM+V,SAASH,IAAI,CAC7D,IACA,IACE2F,4BAA4BjE,WAC9BA,SAAStX,OAAOmE,KACbyR,CAAS,SAAA,CAACC,WAAWE,SAASH,IAAI,KAAK5V,MAAM+V,SAASH,IAAI,CAC7D,IACA;AAEJ,gBACEuF,sBACAE,mBACA,CAACC,iCACD,CAACC,2BACD;AACA,oBAAMjQ,WAAWsN,kBAAkB;AAAA,gBACjCD,qBAAqBnT,YAAYG,YAAY;AAAA,gBAC7CkT,qBAAqBzb;AAAAA,cAAAA,CACtB;AAEMoe,qBAAAA,mBAAmBpe,QAAQ,MAAM;AACtC8b,gBAAAA,OAAMc,EAAE,GACRzD,WAAWiD,SACTpc,QACA;AAAA,kBAAC4C,OAAOsL,SAAS0N,KAAK9C;AAAAA,gBAAAA,GACtB;AAAA,kBAACzU,IAAIuY,GAAG/X;AAAAA,gBAAAA,CACV;AAAA,cAAA,CACD,GAED7E,OAAOqe,SAAS;AAChB;AAAA,YAAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAMF,UACEzB,GAAGvM,SAAS,gBACZuM,GAAG/X,KAAKjB,WAAW,KACnB,cAAcgZ,GAAGC,cACjBD,GAAGC,WAAWhb,UACZuG,YAAYG,cAAcM,QAAQrC,OAAO5E,MAAMhB,QACjDa,MAAMC,QAAQkb,GAAGC,WAAWza,QAAQ,KACpCwa,GAAGC,WAAWza,SAASwB,SAAS,KAChCgZ,GAAG/X,KAAK,CAAC,IAAI,KAAK,GAClB;AACA,cAAM,CAACyZ,aAAaC,UAAU,IAAIpa,OAAOQ,KAAK3E,QAAQ,CAAC4c,GAAG/X,KAAK,CAAC,IAAI,CAAC,CAAC;AAElE7E,YAAAA,OAAOsH,YAAYgX,WAAW,GAAG;AACnC,gBAAME,UACH/c,MAAMC,QAAQ4c,YAAYlc,QAAQ,KAAKkc,YAAYlc,YAAa,IAC7Dma,cAAckC,KAAK,CAAC,GAAGD,SAAS,GAAG5B,GAAGC,WAAWza,QAAQ,CAAC;AAEhE1B,kBAAM,yCAAyCkc,EAAE,GACjDzD,WAAWiD,SACTpc,QACA;AAAA,YAACoC,UAAUma;AAAAA,UAAAA,GACX;AAAA,YAAClY,IAAIka;AAAAA,YAAYpC,OAAO;AAAA,UAAA,CAC1B,GACAL,OAAMc,EAAE;AACR;AAAA,QAAA;AAAA,MACF;AAGFd,MAAAA,OAAMc,EAAE;AAAA,IAAA,GAGH5c;AAAAA,EACT;AACF;AAEO,MAAM0e,yCAETA,CAAC;AAAA,EAACzS;AAAS,MAAM;AACnB,QAAMjM,SAASiM,UAAUjM,QACnBwY,OAAOvM,UAAUyM,WACjB;AAAA,IAAChU;AAAAA,EAAAA,IAAa1E;AAEpB,MAAI0E,WAAW;AACTU,QAAAA,MAAM0Y,WAAWpZ,SAAS;AAEjB0X,iBAAAA,SACTpc,QACA,IACA;AAAA,QAACsE,OAAOT,KAAKC;AAAAA,QAAQ2T,OAAO;AAAA,QAAMkH,SAAS;AAAA,MAAA,CAC7C,GACI3e,OAAO0E,aACc,CACrB,GAAGP,OAAOC,MAAMpE,QAAQ;AAAA,QACtBqE,IAAIrE,OAAO0E;AAAAA,QACXJ,OAAOT,KAAKC;AAAAA,MACb,CAAA,CAAC,EAEWuQ,QAAQ,CAAC,CAAC1P,MAAME,IAAI,MAAM;AACvC,cAAMjD,QAAQ5B,OAAOsC,SAASuC,KAAK,CAAC,CAAC;AACjC/B,kBAAQC,UAAUnB,KAAK,KAAKA,MAAMU,SAASqW,SAAShU,IAAI,KAC1DwU,WAAWiD,SACTpc,QACA;AAAA,UACE4C,QAAQnB,MAAMC,QAAQiD,KAAK/B,KAAK,IAAI+B,KAAK/B,QAAQ,CAAE,GAAE0U,OAClDsH,CAAAA,UAAkBA,UAAUpG,IAC/B;AAAA,UACA3W,OAAO;AAAA,QAAA,GAET;AAAA,UAACwC,IAAIQ;AAAAA,QAAAA,CACP;AAAA,MAAA,CAEH;AAAA,SAEE;AACL,YAAM,CAACjD,OAAOqC,SAAS,IAAIE,OAAOQ,KAAK3E,QAAQ0E,WAAW;AAAA,QACxD2Y,OAAO;AAAA,MACR,CAAA,GACKwB,kBACJ7e,OAAOsH,YAAY1F,KAAK,KACxBA,MAAMU,SAASsB,WAAW,KAC1B5D,OAAOgF,WAAWpD,MAAMU,SAAS,CAAC,CAAC,KACnCV,MAAMU,SAAS,CAAC,EAAEK,SAAS,KACvBf,MAAMU,SAAS,CAAC,IAChBqB;AAEN,UAAIkb,iBAAiB;AAEbC,cAAAA,iCADgBD,gBAAgBjc,SAAS,CAAA,GACK0U,OACjDyH,CAAAA,iBAAiBA,iBAAiBvG,IACrC;AAEAW,mBAAWiD,SACTpc,QACA;AAAA,UACE4C,OAAOkc;AAAAA,QAAAA,GAET;AAAA,UACEza,IAAIJ;AAAAA,UACJK,OAAQK,CAAAA,SAAS3E,OAAOgF,WAAWL,IAAI;AAAA,QAAA,CAE3C;AAAA,MACF;AACSkU,eAAAA,eAAeL,IAAI,IAAI;AAAA,IAAA;AAIlC,QAAIxY,OAAO0E,WAAW;AAEpB,YAAMA,aAAY1E,OAAO0E;AACzB1E,aAAO0E,YAAY;AAAA,QAAC,GAAGA;AAAAA,MAAS;AAAA,IAAA;AAAA,EAClC;AAEJ;AChmBO,SAASsa,UAAUC,OAAkB;AACpC,QAAA,CAAC5O,MAAM6O,KAAK,IAAID;AACf,SAAC5O,CAAAA,MAAM6O,KAAK;AACrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA,MAAMC,wCACAlS,QAAQ;AAEEmS,SAAAA,aAAapf,QAAgBqa,IAAgB;AACrDgF,QAAAA,UAAUF,kBAAkB/G,IAAIpY,MAAM;AAE5C,MAAIqf,SAAS;AACR,OAAA;AACH;AAAA,EAAA;AAGgB7E,oBAAAA,IAChBxa,QACAqf,WAAW;AAAA,IACTC,YAAY5Q,oBAAoB;AAAA,EAAA,CAEpC,GACA2L,GAAAA,GACA8E,kBAAkB3E,IAAIxa,QAAQ2D,MAAS;AACzC;AAEO,SAAS4b,qBAAqBvf,QAAgB;AAC5Cmf,SAAAA,kBAAkB/G,IAAIpY,MAAM,GAAGsf;AACxC;ACYA,MAAM5e,UAAQC,cAAc,qBAAqB,GAG3C6e,6BAAavS,WACbwS,iBAAqBxS,oBAAAA,WASrByS,kBAAkB,KAElBC,WAAY3f,CAAwC,WAAA;AAClDqZ,QAAAA,QAAQmG,OAAOpH,IAAIpY,MAAM;AACxBqZ,SAAAA,UAAU1V,SAAY,KAAO0V;AACtC,GAOMuG,mBAAoB5f,CACnByf,YAAAA,eAAerH,IAAIpY,MAAM,KAC5Byf,eAAejF,IAAIxa,QAAQ,CAAA,CAAE,GAExByf,eAAerH,IAAIpY,MAAM,KAAK,CAAE;AAGlC,SAAS6f,mBACdzJ,SAC8D;AACxD,QAAA;AAAA,IAAChO;AAAAA,EAAAA,IAAegO;AAEtB,SAAQpW,CAAoC,WAAA;AACtC8f,QAAAA,mBAAoD7c,eACtDjD,OAAOsC,UACP8F,YAAYG,cAAcM,QAAQrC,OAAO5E,MAAMhB,IACjD;AACMmf,UAAAA,gBAAgBH,iBAAiB5f,MAAM;AACzCggB,QAAAA,qBAAqBT,qBAAqBvf,MAAM;AAE5CigB,YAAAA,cAAc/X,KAAK,MAAM;AAC/BxH,cAAM,wBAAwB;AAC9B,YAAMwf,MAAM9X,YAAYlI,GAAG,WAAW,CAAC;AAAA,QAACigB;AAAAA,QAASjS;AAAAA,MAAAA,MAAc;AAC7D,YAAIkS,QAAQ;AACZD,gBAAQ9L,QAAS6K,CAAU,UAAA;AACzB,cAAI,CAACkB,SAASlB,MAAMmB,WAAW,WAAWN,eAAe;AACvD,gBAAIb,MAAM7O,SAAS,WAAW6O,MAAMra,KAAKjB,WAAW,GAAG;AAEnDlD,sBAAA,+DACF,GACAV,OAAOsgB,UAAU;AAAA,gBAACC,OAAO,CAAE;AAAA,gBAAEC,OAAO,CAAA;AAAA,cACpCT,GAAAA,cAAcU,OAAO,GAAGV,cAAcnc,MAAM,GAC5C4b,OAAOhF,IAAIxa,QAAQ,EAAI,GACvBogB,QAAQ;AACR;AAAA,YAAA;AAEFL,0BAAc7X,KAAK;AAAA,cACjBgX;AAAAA,cACAwB,0BAAUC,KAAK;AAAA,cACfzS;AAAAA,cACA4R;AAAAA,YAAAA,CACD;AAAA,UAAA;AAAA,QACH,CACD,GACDA,mBAAmB5R;AAAAA,MAAAA,CACpB;AACD,aAAO,MAAM;AACLxN,gBAAA,0BAA0B,GAChCwf,IAAI5f,YAAY;AAAA,MAClB;AAAA,IAAA,CACD,GAEDN,OAAOsgB,UAAU;AAAA,MAACC,OAAO,CAAE;AAAA,MAAEC,OAAO,CAAA;AAAA,IAAE;AAEhC,UAAA;AAAA,MAAC1E,OAAAA;AAAAA,IAAAA,IAAS9b;AAEhBA,WAAAA,OAAO8b,QAASc,CAAkB,OAAA;AAC5BxU,UAAAA,YAAYG,YAAY,EAAEC,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY,GAAG;AACjEsT,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAOErC,UAAAA,mBAAmBva,MAAM,GAAG;AAC9B8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAOF,UAAIhC,UAAU5a,MAAM,KAAK+a,UAAU/a,MAAM,GAAG;AAC1C8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAGI,YAAA;AAAA,QAACD;AAAAA,QAAY2D;AAAAA,UAAWtgB,QACxB;AAAA,QAACugB;AAAAA,MAASD,IAAAA,SACVM,OAAOL,MAAMA,MAAM3c,SAAS,CAAC,GAC7Bid,SACJD,QAAQA,KAAKjE,cAAciE,KAAKjE,WAAWiE,KAAKjE,WAAW/Y,SAAS,CAAC,GACjEkd,YAAYC,gBAAgBnE,IAAIiE,MAAM,GACtCG,OAAOrB,SAAS3f,MAAM,GAEtBihB,oBAAoB1B,qBAAqBvf,MAAM;AAEjDkhB,UAAAA,QACFD,sBAAsBtd,UAAaqc,uBAAuBrc,SACtD,KACAsd,sBAAsBtd,UAAaqc,uBAAuBrc,SACxDsd,sBAAsBjB,qBACtB;AAER,UAAIgB,MAAM;AAUR,YATKJ,OAEMjE,WAAW/Y,WAAW,MAC/Bsd,QACED,sBAAsBtd,UAAaqc,uBAAuBrc,SACtDwd,YAAYvE,IAAIiE,MAAM,KAAKC,YAC3BI,SALNA,QAAQ,IAQNN,QAAQM;AACLvE,eAAAA,WAAWzU,KAAK0U,EAAE;AAAA,aAClB;AACL,gBAAMwE,UAAU;AAAA,YACdzE,YAAY,CACV,GAAI3c,OAAO0E,cAAc,OACrB,KACA,CAAC2c,sBAAsBrhB,MAAM,CAAC,GAClC4c,EAAE;AAAA,YAEJ0E,+BAAeX,KAAK;AAAA,UACtB;AACAJ,gBAAMrY,KAAKkZ,OAAO,GAClB1gB,QAAM,yBAAyBkgB,IAAI;AAAA,QAAA;AAGrC,eAAOL,MAAM3c,SAAS8b;AACpBa,gBAAMgB,MAAM;AAGVC,oBAAY5E,EAAE,MAChB0D,QAAQE,QAAQ,CAAA;AAAA,MAAE;AAIDS,2BAAAA,mBAErBnF,OAAMc,EAAE;AAAA,IAAA,GAIH5c;AAAAA,EACT;AACF;AAEO,MAAMyhB,qCAETA,CAAC;AAAA,EAACxV;AAAS,MAAM;AACbjM,QAAAA,SAASiM,UAAUjM,QACnB;AAAA,IAACugB;AAAAA,EAASvgB,IAAAA,OAAOsgB,SACjBP,gBAAgBH,iBAAiB5f,MAAM;AAEzCugB,MAAAA,MAAM3c,SAAS,GAAG;AACpB,UAAMgd,OAAOL,MAAMA,MAAM3c,SAAS,CAAC;AAEnC,QADAlD,QAAM,WAAWkgB,IAAI,GACjBA,KAAKjE,WAAW/Y,SAAS,GAAG;AAC9B,YAAM8d,eAAe3B,cAAczI,OAChCqK,UAASA,KAAKjB,QAAQE,KAAKU,SAC9B;AACA,UAAIM,wBAAwBhB,KAAKjE;AACjC+E,mBAAarN,QAASsN,CAAS,SAAA;AAC7BC,gCAAwBC,QACtBD,sBAAsBjgB,IAAKib,CAAAA,OACzBkF,mBACE9hB,QACA2hB,KAAKzC,OACLtC,IACA+E,KAAKzT,UACLyT,KAAK7B,gBACP,CACF,CACF;AAAA,MAAA,CACD;AACD,YAAMiC,qBAAqBH,sBACxBjgB,IAAIqgB,UAAUC,OAAO,EACrBnI,QAAQ;AAEP,UAAA;AACKsE,eAAAA,mBAAmBpe,QAAQ,MAAM;AACtC2a,sBAAY3a,QAAQ,MAAM;AACxBkiB,0BAAcliB,QAAQ,MAAM;AAC1B+hB,iCAAmB1N,QAASuI,CAAO,OAAA;AACjC5c,uBAAO8b,MAAMc,EAAE;AAAA,cAAA,CAChB;AAAA,YAAA,CACF;AAAA,UAAA,CACF;AAAA,QAAA,CACF;AAAA,eACMuF,KAAK;AACZzhB,gBAAM,+BAA+ByhB,GAAG,GACxCpC,cAAcU,OAAO,GAAGV,cAAcnc,MAAM,GAC5CuV,WAAWiJ,SAASpiB,MAAM,GAC1BA,OAAOsgB,UAAU;AAAA,UAACC,OAAO,CAAE;AAAA,UAAEC,OAAO,CAAA;AAAA,QAAE,GACtChB,OAAOhF,IAAIxa,QAAQ,EAAI,GACvB6a,aAAa7a,QAAQ,EAAK,GAC1BA,OAAOqe,SAAS;AAChB;AAAA,MAAA;AAEKiC,aAAAA,QAAQE,MAAMtY,KAAK0Y,IAAI,GAC9B5gB,OAAOsgB,QAAQC,MAAM8B,IAAI;AAAA,IAAA;AAAA,EAC3B;AAEJ,GAEaC,qCAETA,CAAC;AAAA,EAACrW;AAAS,MAAM;AACbjM,QAAAA,SAASiM,UAAUjM,QACnB;AAAA,IAACwgB;AAAAA,EAASxgB,IAAAA,OAAOsgB,SACjBP,gBAAgBH,iBAAiB5f,MAAM;AAEzCwgB,MAAAA,MAAM5c,SAAS,GAAG;AACpB,UAAMgd,OAAOJ,MAAMA,MAAM5c,SAAS,CAAC;AAEnC,QADAlD,QAAM,WAAWkgB,IAAI,GACjBA,KAAKjE,WAAW/Y,SAAS,GAAG;AAC9B,YAAM8d,eAAe3B,cAAczI,OAChCqK,UAASA,KAAKjB,QAAQE,KAAKU,SAC9B;AACA,UAAIM,wBAAwBhB,KAAKjE;AACjC+E,mBAAarN,QAASsN,CAAS,SAAA;AAC7BC,gCAAwBC,QACtBD,sBAAsBjgB,IAAKib,CAAAA,OACzBkF,mBACE9hB,QACA2hB,KAAKzC,OACLtC,IACA+E,KAAKzT,UACLyT,KAAK7B,gBACP,CACF,CACF;AAAA,MAAA,CACD;AACG,UAAA;AACK1B,eAAAA,mBAAmBpe,QAAQ,MAAM;AACtC8a,sBAAY9a,QAAQ,MAAM;AACxBkiB,0BAAcliB,QAAQ,MAAM;AAC1B4hB,oCAAsBvN,QAASuI,CAAO,OAAA;AACpC5c,uBAAO8b,MAAMc,EAAE;AAAA,cAAA,CAChB;AAAA,YAAA,CACF;AAAA,UAAA,CACF;AAAA,QAAA,CACF;AAAA,eACMuF,KAAK;AACZzhB,gBAAM,+BAA+ByhB,GAAG,GACxCpC,cAAcU,OAAO,GAAGV,cAAcnc,MAAM,GAC5CuV,WAAWiJ,SAASpiB,MAAM,GAC1BA,OAAOsgB,UAAU;AAAA,UAACC,OAAO,CAAE;AAAA,UAAEC,OAAO,CAAA;AAAA,QAAE,GACtChB,OAAOhF,IAAIxa,QAAQ,EAAI,GACvBgb,aAAahb,QAAQ,EAAK,GAC1BA,OAAOqe,SAAS;AAChB;AAAA,MAAA;AAEKiC,aAAAA,QAAQC,MAAMrY,KAAK0Y,IAAI,GAC9B5gB,OAAOsgB,QAAQE,MAAM6B,IAAI;AAAA,IAAA;AAAA,EAC3B;AAEJ;AAMA,SAASP,mBACP9hB,QACAkf,OACAjT,WACAiC,UACA4R,kBACa;AASb,QAAMyC,uBAAuB;AAAA,IAAC,GAAGtW;AAAAA,EAAS;AAE1C,MAAIiT,MAAM7O,SAAS,YAAY6O,MAAMra,KAAKjB,WAAW,GAAG;AACtD,UAAM4e,oBAAoBtU,YAAY,CAAA,GAAIpC,UAAWa,SACnDrL,QAAQ;AAAA,MAACD,MAAMsL,IAAItL;AAAAA,IAAO6d,GAAAA,MAAMra,KAAK,CAAC,CAAC,CACzC;AACAnE,WAAAA,QACE,0BAA0Bwe,MAAMuD,MAAM7e,MAAM,UAAU2e,qBAAqBlS,IAAI,0BAA0B6O,MAAM7O,IAAI,GACrH,GACO,CACLqS,gBACEH,sBACArD,MAAMuD,MAAM7e,QACZ4e,gBACF,CAAC;AAAA,EAAA;AAIL,MAAItD,MAAM7O,SAAS,WAAW6O,MAAMra,KAAKjB,WAAW,GAAG;AACrD,UAAM+e,mBAAmB7C,oBAAoB,CAAA,GAAIhU,UAAWa,SAC1DrL,QAAQ;AAAA,MAACD,MAAMsL,IAAItL;AAAAA,IAAO6d,GAAAA,MAAMra,KAAK,CAAC,CAAC,CACzC;AAEA,WACE,UAAU0d,wBACV9gB,MAAMC,QAAQ6gB,qBAAqB1d,IAAI,KACvC0d,qBAAqB1d,KAAK,CAAC,MAAM8d,mBAEjCjiB,QAAM,qDAAqD,GACpD,MAQF,CAACgiB,gBAAgBH,sBAAsB,IAAII,eAAe,CAAC;AAAA,EAAA;AAIpE,MAAIzD,MAAM7O,SAAS,WAAW6O,MAAMra,KAAKjB,WAAW;AAClDlD,WAAAA,QACE,sDAAsDuL,UAAUoE,IAAI,YACtE,GACO,CAAE;AAGP6O,MAAAA,MAAM7O,SAAS,kBAAkB;AAC7BuS,UAAAA,uBAAuBC,yBAC3B7iB,QACAuiB,oBACF;AAEE,WAAA,CAACK,wBACD,CAACthB,QAAQ;AAAA,MAACD,MAAMuhB,qBAAqBvhB;AAAAA,IAAO6d,GAAAA,MAAMra,KAAK,CAAC,CAAC,IAElD,CAAC0d,oBAAoB,KAEVO,MAAW5D,MAAM9d,KAAK,EAC9BiT,QAAS0O,CAAc,cAAA;AAC7BC,UAAAA,iBAAiB,GACjBC,gBAAgBF,UAAUG;AACxB,YAAA;AAAA,QAACC;AAAAA,MAAAA,IAASJ;AAgChB,UA/BAI,MAAM9O,QAAQ,CAAC+O,OAAMC,UAAU;AACvB,cAAA,CAACC,UAAU3gB,IAAI,IAAIygB;AACrBE,qBAAaC,eACfP,kBAAkBrgB,KAAKiB,QACvBqf,iBAAiBtgB,KAAKiB,UACb0f,aAAaE,eACtBR,kBAAkBrgB,KAAKiB,QACvBqf,iBAAiBtgB,KAAKiB,UACb0f,aAAaG,eAEjBN,MAAMre,MAAMue,KAAK,EAAE9b,MAAM,CAAC,CAACmc,KAAK,MAAMA,UAAUD,UAAU,MAC7DR,iBAAiBtgB,KAAKiB;AAAAA,MAG3B,CAAA,GAEG2e,qBAAqBlS,SAAS,iBAC5B4S,gBAAgBV,qBAAqBxa,WACvCwa,qBAAqBxa,UAAUib,iBAI/BT,qBAAqBlS,SAAS,iBAE9B4S,iBACAV,qBAAqBxa,SAASwa,qBAAqB5f,KAAKiB,WAExD2e,qBAAqBxa,UAAUib,iBAI/BT,qBAAqBlS,SAAS,iBAAiB;AAC3CsT,cAAAA,eAAepB,qBAAqB1F,YAAYjY,QAClD;AAAA,UAAC,GAAG2d,qBAAqB1F,WAAWjY;AAAAA,QACpCjB,IAAAA,QACEigB,gBAAgBrB,sBAAsB1F,YAAYhV,SACpD;AAAA,UAAC,GAAG0a,qBAAqB1F,WAAWhV;AAAAA,QACpClE,IAAAA,QACEoJ,WAAWwV,sBAAsBzF,eAAelY,QAClD;AAAA,UAAC,GAAG2d,qBAAqBzF,cAAclY;AAAAA,QACvCjB,IAAAA,QACEmJ,YAAYyV,sBAAsBzF,eAAejV,SACnD;AAAA,UAAC,GAAG0a,qBAAqBzF,cAAcjV;AAAAA,QAAAA,IACvClE;AACCggB,SAAAA,gBAAgBC,iBAAmB7W,YAAYD,eACnC,CAAC6W,cAAcC,eAAe7W,UAAUD,SAAS,EACzDuH,QAAS9O,CAAU,UAAA;AACpBA,mBAAS0d,gBAAgB1d,MAAMwC,WACjCxC,MAAMwC,UAAUib;AAAAA,QAEnB,CAAA,GACGW,gBAAgBC,kBAClBrB,qBAAqB1F,aAAa;AAAA,UAChCjY,OAAO+e;AAAAA,UACP9b,QAAQ+b;AAAAA,QAGR7W,IAAAA,YAAYD,cACdyV,qBAAqBzF,gBAAgB;AAAA,UACnClY,OAAOmI;AAAAA,UACPlF,QAAQiF;AAAAA,QAAAA;AAAAA,MACV;AAAA,IAGN,CACD,GACM,CAACyV,oBAAoB;AAAA,EAAA;AAE9B,SAAO,CAACA,oBAAoB;AAC9B;AAIA,SAASG,gBACPzW,WACAsH,OACA/O,YACW;AACX,QAAM+d,uBAAuB;AAAA,IAAC,GAAGtW;AAAAA,EAAS;AAExCzH,MAAAA,cAAc,KACd+d,qBAAqBlS,SAAS,mBAC9B5O,MAAMC,QAAQ6gB,qBAAqB1d,IAAI,KACvC0d,qBAAqB1d,KAAK,CAAC,KAAKL,aAAa+O,SAC7CgP,qBAAqB1d,KAAK,CAAC,IAAI0O,QAAQ,IACvC;AACA,UAAMjH,UAAU,CACdiW,qBAAqB1d,KAAK,CAAC,IAAI0O,OAC/B,GAAGgP,qBAAqB1d,KAAKC,MAAM,CAAC,CAAC;AAEvCyd,yBAAqB1d,OAAOyH;AAAAA,EAAAA;AAE1BiW,MAAAA,qBAAqBlS,SAAS,iBAAiB;AAC3CsT,UAAAA,eAAepB,qBAAqB1F,YAAYjY,QAClD;AAAA,MAAC,GAAG2d,qBAAqB1F,WAAWjY;AAAAA,IACpCjB,IAAAA,QACEigB,gBAAgBrB,sBAAsB1F,YAAYhV,SACpD;AAAA,MAAC,GAAG0a,qBAAqB1F,WAAWhV;AAAAA,IACpClE,IAAAA,QACEoJ,WAAWwV,sBAAsBzF,eAAelY,QAClD;AAAA,MAAC,GAAG2d,qBAAqBzF,cAAclY;AAAAA,IACvCjB,IAAAA,QACEmJ,YAAYyV,sBAAsBzF,eAAejV,SACnD;AAAA,MAAC,GAAG0a,qBAAqBzF,cAAcjV;AAAAA,IAAAA,IACvClE;AACCggB,KAAAA,gBAAgBC,iBAAmB7W,YAAYD,eACnC,CAAC6W,cAAcC,eAAe7W,UAAUD,SAAS,EACzDuH,QAAS9O,CAAU,UAAA;AAEtBA,eACAA,MAAMV,KAAK,CAAC,KAAKL,aAAa+O,SAC9BhO,MAAMV,KAAK,CAAC,IAAI0O,QAAQ,OAExBhO,MAAMV,OAAO,CAACU,MAAMV,KAAK,CAAC,IAAI0O,OAAO,GAAGhO,MAAMV,KAAKC,MAAM,CAAC,CAAC;AAAA,IAE9D,CAAA,GACG6e,gBAAgBC,kBAClBrB,qBAAqB1F,aAAa;AAAA,MAChCjY,OAAO+e;AAAAA,MACP9b,QAAQ+b;AAAAA,IAGR7W,IAAAA,YAAYD,cACdyV,qBAAqBzF,gBAAgB;AAAA,MACnClY,OAAOmI;AAAAA,MACPlF,QAAQiF;AAAAA,IAAAA;AAAAA,EACV;AAKCyV,SAAAA;AACT;AAIA,MAAMpB,cAAcA,CAACvE,IAAetC,SAC9BsC,CAAGvM,EAAAA,GAAAA,SAAS,mBAMdiK,QACAsC,GAAGvM,SAAS,iBACZiK,KAAKjK,SAAS,iBACduM,GAAG7U,WAAWuS,KAAKvS,SAASuS,KAAK3X,KAAKiB,UACtCmW,KAAK3N,OAAOwQ,GAAG/X,MAAMyV,KAAKzV,IAAI,KAC9B+X,GAAGja,SAAS,OAOZ2X,QACAsC,GAAGvM,SAAS,iBACZiK,KAAKjK,SAAS,iBACduM,GAAG7U,SAAS6U,GAAGja,KAAKiB,WAAW0W,KAAKvS,UACpCgS,KAAK3N,OAAOwQ,GAAG/X,MAAMyV,KAAKzV,IAAI,IAS5Bkc,kBAAkBA,CACtBnE,IACAtC,SAEIA,WAAQsC,GAAGvM,SAAS,mBAAmBiK,KAAKjK,SAAS,kBAOrDmR,cAAe5E,CAAAA,OACfA,GAAGvM,SAAS;AAOF6R,SAAAA,cAAcliB,QAAgBqa,IAAsB;AAC5DC,QAAAA,OAAOqF,SAAS3f,MAAM;AACrBwa,SAAAA,IAAIxa,QAAQ,EAAK,GACxBqa,GACAmF,GAAAA,OAAOhF,IAAIxa,QAAQsa,IAAI;AACzB;AAEA,SAAS+G,sBAAsBrhB,QAAoC;AAC1D,SAAA;AAAA,IACLqQ,MAAM;AAAA,IACNwM,YAAY;AAAA,MAAC,GAAG7c,OAAO0E;AAAAA,IAAS;AAAA,IAChCoY,eAAe;AAAA,MAAC,GAAG9c,OAAO0E;AAAAA,IAAAA;AAAAA,EAC5B;AACF;AAEA,SAASme,yBACP7iB,QACAiM,WACwB;AACpBrK,MAAAA;AACAqK,SAAAA,UAAUoE,SAAS,mBAAmBrQ,OAAO0E,YAC/C9C,QAAQ5B,OAAOsC,SAAStC,OAAO0E,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC7C,UAAUoH,cACnBrK,QAAQ5B,OAAOsC,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,IAEpCjD;AACT;AC9kBO,MAAMiiB,uCAGTA,CAAC;AAAA,EAAChb;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAM6X,mBAAmBC,gBAAgB;AAAA,IACvCtG,YAAY;AAAA,MACV5b,OAAOoK,UAAUwR,WAAW7c;AAAAA,MAC5B,GAAGqL,UAAUwR,WAAWrc;AAAAA,IAC1B;AAAA,IACAyH;AAAAA,IACAuN,SAAS;AAAA,MAACC,aAAa;AAAA,MAAOC,gBAAgB;AAAA,IAAA;AAAA,EAAI,CACnD;AAED,MAAI,CAACwN;AACG,UAAA,IAAI3gB,MACR,8BAA8B0S,KAAKC,UAAU7J,UAAUwR,UAAU,CAAC,EACpE;AAGF,QAAMzd,SAASiM,UAAUjM;AAEzB,MAAI,CAACA,OAAO0E,aAAaU,MAAM4M,YAAYhS,OAAO0E,SAAS;AACzD;AAGF,MAAIsf,OACApK,UACAqK;AACJ,QAAMC,eAAuB,CAAA,GAEvB7c,iBAAiBlD,OAAOC,MAAMpE,QAAQ;AAAA,IAC1CqE,IAAIrE,OAAO0E;AAAAA,IACXJ,OAAQK,CAAAA,SAAS3E,OAAOsH,YAAY3C,IAAI;AAAA,IACxCmV,SAAS1U,MAAM6C,WAAWjI,OAAO0E,SAAS;AAAA,EAAA,CAC3C;AAED,MAAIF,aAAa;AAEjB,aAAW,CAAC5C,OAAOqC,SAAS,KAAKoD,gBAAgB;AAK/C,QAJIzF,MAAMU,SAASsB,WAAW,KAI1BhC,MAAMU,SAASsB,WAAW,KAAKhC,MAAMU,SAAS,CAAC,EAAEK,SAAS;AAC5D;AAIIwhB,UAAAA,gBACJ3f,eAAe,IAAIsf,iBAAiBziB,OAAOwH,QAAQkO,gBAC/C3U,WAAWR,MAAMQ,YAAY,CAAE;AACbA,aAASsK,KAC9B8P,CACCA,YAAAA,QAAQ3a,UAAUiiB,iBAAiBjiB,SACnC2a,QAAQnb,SAAS8iB,aACrB,MAEwBxgB,WACtBwV,WAAWiD,SACTpc,QACA;AAAA,MACEoC,UAAU,CACR,GAAGA,UACH;AAAA,QACE,GAAG0hB;AAAAA,QACHziB,MAAM8iB;AAAAA,MACP,CAAA;AAAA,IAAA,GAGL;AAAA,MAAC9f,IAAIJ;AAAAA,IAAAA,CACP,GAEAggB,cAAc,CAAC;AAAA,MAAC5iB,MAAMO,MAAMP;AAAAA,OAAO,YAAY;AAAA,MAACA,MAAM8iB;AAAAA,IAAAA,CAAc,GAEhE/e,MAAM6C,WAAWjI,OAAO0E,SAAS,IACnCwf,aAAaE,QAAQH,WAAW,IAEhCC,aAAahc,KAAK+b,WAAW,IAIjC9K,WAAWiD,SAASpc,QAAQ,IAAI;AAAA,MAACsE,OAAOT,KAAKC;AAAAA,MAAQ2T,OAAO;AAAA,IAAA,CAAK;AAEjE,UAAMnV,WAAW0D,KAAK1D,SAAStC,QAAQiE,SAAS;AAEhD,eAAW,CAACiT,MAAMrS,IAAI,KAAKvC,UAAU;AAC/B,UAAA,CAACtC,OAAOgF,WAAWkS,IAAI,KAIvB,CAAC9R,MAAMuT,SAAS3Y,OAAO0E,WAAWG,IAAI;AACxC;AAGF,YAAMjC,QAAQsU,KAAKtU,SAAS,CAAA,GACtByhB,8BAA8BzhB,MAAM0U,OAAQkB,CAAAA,SAChDpW,SAAS2E,KACNyV,CAAAA,YACCA,QAAQnb,SAASmX,QAAQgE,QAAQ3a,UAAUiiB,iBAAiBjiB,KAChE,CACF;AAEAsX,iBAAWiD,SACTpc,QACA;AAAA,QACE4C,OAAO,CACL,GAAGA,MAAM0U,OACNkB,CAAAA,SAAS,CAAC6L,4BAA4B1L,SAASH,IAAI,CACtD,GACA2L,aAAa;AAAA,MAAA,GAGjB;AAAA,QAAC9f,IAAIQ;AAAAA,MAAAA,CACP,GAEA+U,WAAW,CAAC;AAAA,QAACvY,MAAMO,MAAMP;AAAAA,SAAO,YAAY;AAAA,QAACA,MAAM6V,KAAK7V;AAAAA,MAAAA,CAAK;AAAA,IAAA;AAG/DmD;AAAAA,EAAAA;AAGEyf,SAAAA,eAAerK,aACjBoK,QAAQ;AAAA,IACNC;AAAAA,IACAC;AAAAA,IACAtK;AAAAA,EAIGoK,IAAAA;AACT,GCrJaM,0CAETA,CAAC;AAAA,EAACrY;AAAS,MAAM;AACnB,QAAMjM,SAASiM,UAAUjM;AAEzB,MAAKA,OAAO0E;AAIZ,QAAIU,MAAM4M,YAAYhS,OAAO0E,SAAS,GAAG;AACjC,YAAA,CAAC9C,OAAOqC,SAAS,IAAIE,OAAOQ,KAAK3E,QAAQA,OAAO0E,WAAW;AAAA,QAC/D2Y,OAAO;AAAA,MAAA,CACR;AAEG,UAAA,CAACrd,OAAOsH,YAAY1F,KAAK;AAC3B;AAII2iB,YAAAA,wBADW3iB,MAAMQ,YAAY,CAAA,GACGkV,OACnCkF,CAAAA,YAAYA,QAAQ3a,UAAUoK,UAAUwR,WAAW7c,IACtD,GAEM,CAAC4jB,eAAeC,iBAAiB,IAAItgB,OAAOQ,KAChD3E,QACAA,OAAO0E,WACP;AAAA,QACE2Y,OAAO;AAAA,MAAA,CAEX;AAEI,UAAA,CAACrd,OAAOgF,WAAWwf,aAAa;AAClC;AAGIE,YAAAA,qBAAqBF,cAAc5hB,OAAO8J,KAAM8L,CAAAA,SACpD+L,qBAAqBxd,KAAMyV,CAAYA,YAAAA,QAAQnb,SAASmX,IAAI,CAC9D;AAEA,UAAI,CAACkM;AACH;AAGF,YAAMC,kCAEF,CAAE;AAEN,iBAAW,CAACpiB,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQiE,WAAW;AAAA,QAChE6V,SAAS;AAAA,MAAA,CACV;AACC,YAAK9Z,OAAOgF,WAAWzC,KAAK,KAIvBwX,KAAKC,SAASnO,WAAW4Y,iBAAiB;AAI3CliB,cAAAA,MAAMK,OAAO+V,SAAS+L,kBAAkB;AAC1CC,4CAAgCzc,KAAK,CAAC3F,OAAOsJ,SAAS,CAAC;AAAA;AAEvD;AAIJ,YAAM+Y,8BAEF,CAAE;AAEN,iBAAW,CAACriB,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQiE,SAAS;AAC9D,YAAKjE,OAAOgF,WAAWzC,KAAK,KAIvBwX,KAAKI,QAAQtO,WAAW4Y,iBAAiB;AAI1CliB,cAAAA,MAAMK,OAAO+V,SAAS+L,kBAAkB;AAC1CE,wCAA4B1c,KAAK,CAAC3F,OAAOsJ,SAAS,CAAC;AAAA;AAEnD;AAIJ,iBAAW,CAACtJ,OAAOsJ,SAAS,KAAK,CAC/B,GAAG8Y,iCACH,CAACH,eAAeC,iBAAiB,GACjC,GAAGG,2BAA2B;AAE9BzL,mBAAWiD,SACTpc,QACA;AAAA,UACE4C,OAAOL,MAAMK,OAAO0U,OAAQkB,CAAAA,SAASA,SAASkM,kBAAkB;AAAA,QAAA,GAElE;AAAA,UAACrgB,IAAIwH;AAAAA,QAAAA,CACP;AAAA,IAAA,OAEG;AACMuQ,iBAAAA,SACTpc,QACA,IACA;AAAA,QACEsE,OAAQK,CAAAA,SAAS3E,OAAOgF,WAAWL,IAAI;AAAA,QACvC8S,OAAO;AAAA,QACPkH,SAAS;AAAA,MAAA,CAEb;AAEMjJ,YAAAA,SAASvR,OAAOC,MAAMpE,QAAQ;AAAA,QAClCqE,IAAIrE,OAAO0E;AAAAA,QACXJ,OAAQK,CAAAA,SAAS3E,OAAOsH,YAAY3C,IAAI;AAAA,MAAA,CACzC;AAED,iBAAW,CAAC/C,OAAOqC,SAAS,KAAKyR,QAAQ;AACvC,cAAMpT,WAAW0D,KAAK1D,SAAStC,QAAQiE,SAAS;AAEhD,mBAAW,CAAC1B,OAAOsJ,SAAS,KAAKvJ,UAAU;AACrC,cAAA,CAACtC,OAAOgF,WAAWzC,KAAK,KAIxB,CAAC6C,MAAMuT,SAAS3Y,OAAO0E,WAAWmH,SAAS;AAC7C;AAGIzJ,gBAAAA,WAAWR,MAAMQ,YAAY,IAC7BQ,QAAQL,MAAMK,SAAS,CAAA,GACvBiiB,yBAAyBjiB,MAAM0U,OAAQkB,CAC3BpW,SAAAA,SAASsK,KAAM8P,CAAAA,aAAYA,SAAQnb,SAASmX,IAAI,GAChD3W,UAAUoK,UAAUwR,WAAW7c,IAChD;AAEGikB,iCAAuBjhB,WAAWhB,MAAMgB,UAC1CuV,WAAWiD,SACTpc,QACA;AAAA,YACE4C,OAAOiiB;AAAAA,UAAAA,GAET;AAAA,YAACxgB,IAAIwH;AAAAA,UAAAA,CACP;AAAA,QAAA;AAAA,MAEJ;AAAA,IACF;AAEJ,GC9IaiZ,kCAETA,CAAC;AAAA,EAACjc;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAM8Y,WAAWxZ,aACf;AAAA,IACE1D,QAAQ;AAAA,MAAChD,MAAMoH,UAAU5H;AAAAA,MAAI0D,QAAQ;AAAA,IAAC;AAAA,IACtCnD,OAAO;AAAA,MAACC,MAAMoH,UAAU5H;AAAAA,MAAI0D,QAAQ;AAAA,IAAA;AAAA,EAAC,GAEvCkE,UAAUjM,MACZ;AAEA,MAAI,CAAC+kB;AACG,UAAA,IAAI5hB,MACR,qBAAqB0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,qBACnD;AAIF,QAAMzC,QADauC,OAAOQ,KAAKsH,UAAUjM,QAAQ+kB,UAAU;AAAA,IAAC1H,OAAO;AAAA,EAAE,CAAA,IAC1C,CAAC;AAE5B,MAAI,CAACzb;AACG,UAAA,IAAIuB,MAAM,2BAA2B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAG3E,QAAM6R,cAAcjT,eAClB,CAACrB,KAAK,GACNiH,QAAQrC,OAAO5E,MAAMhB,MACrBuM,qBAAqBiL,IAAInM,UAAUjM,MAAM,CAC3C,EAAEqE,GAAG,CAAC;AAEN,MAAI,CAAC6R;AACG,UAAA,IAAI/S,MAAM,4BAA4B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAGtE,QAAA;AAAA,IAACxC;AAAAA,IAAO,GAAGmjB;AAAAA,EAAiB/Y,IAAAA,UAAUpM,OAEtColB,eAAe9O,WAAW;AAAA,IAC9BtN;AAAAA,IACAjH,OAAO;AAAA,MACL,GAAGsU;AAAAA,MACH,GAAG8O;AAAAA,IACL;AAAA,IACA5O,SAAS;AAAA,MAACC,aAAa;AAAA,MAAOC,gBAAgB;AAAA,IAAA;AAAA,EAAI,CACnD;AAED,MAAI,CAAC2O;AACG,UAAA,IAAI9hB,MAAM,6BAA6B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAG7E,QAAM6gB,aAAa3jB,aAAa,CAAC0jB,YAAY,GAAG;AAAA,IAC9CzjB,aAAaqH,QAAQrC;AAAAA,EAAAA,CACtB,GAAGnC,GAAG,CAAC;AAER,MAAI,CAAC6gB;AACG,UAAA,IAAI/hB,MAAM,wCAAwC;AAG/CiZ,aAAAA,SAASnQ,UAAUjM,QAAQklB,YAAY;AAAA,IAAC7gB,IAAI0gB;AAAAA,EAAAA,CAAS;AAClE,GCzDaI,oCAETA,CAAC;AAAA,EAACtc;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAM8Y,WAAWxZ,aACf;AAAA,IACE1D,QAAQ;AAAA,MAAChD,MAAMoH,UAAU5H;AAAAA,MAAI0D,QAAQ;AAAA,IAAC;AAAA,IACtCnD,OAAO;AAAA,MAACC,MAAMoH,UAAU5H;AAAAA,MAAI0D,QAAQ;AAAA,IAAA;AAAA,EAAC,GAEvCkE,UAAUjM,MACZ;AAEA,MAAI,CAAC+kB;AACG,UAAA,IAAI5hB,MACR,qBAAqB0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,qBACnD;AAIF,QAAMzC,QADauC,OAAOQ,KAAKsH,UAAUjM,QAAQ+kB,UAAU;AAAA,IAAC1H,OAAO;AAAA,EAAE,CAAA,IAC1C,CAAC;AAE5B,MAAI,CAACzb;AACG,UAAA,IAAIuB,MAAM,2BAA2B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAG3E,QAAM6R,cAAcjT,eAClB,CAACrB,KAAK,GACNiH,QAAQrC,OAAO5E,MAAMhB,MACrBuM,qBAAqBiL,IAAInM,UAAUjM,MAAM,CAC3C,EAAEqE,GAAG,CAAC;AAEN,MAAI,CAAC6R;AACG,UAAA,IAAI/S,MAAM,4BAA4B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAGxEiD,MAAAA,YAAYuB,SAASqN,WAAW,GAAG;AAC/BkP,UAAAA,gBAAgBnZ,UAAUpM,MAAMyX,OAAQ+N,UAASA,SAAS,OAAO,GAEjEC,mBAAmBnP,WAAW;AAAA,MAClCtN;AAAAA,MACAjH,OAAO2jB,KAAKrP,aAAakP,aAAa;AAAA,MACtChP,SAAS;AAAA,QAACC,aAAa;AAAA,QAAOC,gBAAgB;AAAA,MAAA;AAAA,IAAI,CACnD;AAED,QAAI,CAACgP;AACG,YAAA,IAAIniB,MACR,6BAA6B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAC3D;AAGF,UAAMmhB,aAAsC,CAAC;AAE7C,eAAWH,QAAQD;AACXC,cAAQC,mBAGZE,WAAWH,IAAI,IAAKC,iBAA6CD,IAAI,IAFrEG,WAAWH,IAAI,IAAI1hB;AAMZyY,eAAAA,SAASnQ,UAAUjM,QAAQwlB,YAAY;AAAA,MAACnhB,IAAI0gB;AAAAA,IAAAA,CAAS;AAEhE;AAAA,EAAA;AAGF,QAAMU,qBAAqBtP,WAAW;AAAA,IACpCtN;AAAAA,IACAjH,OAAO2jB,KACLrP,aACAjK,UAAUpM,MAAMyX,OAAQ+N,CAAAA,SAASA,SAAS,OAAO,CACnD;AAAA,IACAjP,SAAS;AAAA,MAACC,aAAa;AAAA,MAAOC,gBAAgB;AAAA,IAAA;AAAA,EAAI,CACnD;AAED,MAAI,CAACmP;AACG,UAAA,IAAItiB,MAAM,6BAA6B0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EAAE;AAGvE,QAAA;AAAA,IAACxC;AAAAA,IAAOR;AAAAA,IAAM,GAAGxB;AAAAA,EAAAA,IAAS4lB;AAErBrJ,aAAAA,SACTnQ,UAAUjM,QACV;AAAA,IACE6B;AAAAA,IACAR;AAAAA,IACAD,OAAOvB;AAAAA,EAAAA,GAET;AAAA,IAACwE,IAAI0gB;AAAAA,EAAAA,CACP;AACF,GCvFaW,sCAETA,CAAC;AAAA,EAAC7c;AAAAA,EAASoD;AAAS,MAAM;AACtBjM,QAAAA,SAASiM,UAAUjM,QACnBwY,OAAOvM,UAAUyM,WACjBtX,QAAQ6B,eACZjD,OAAOsC,UACPuG,QAAQrC,OAAO5E,MAAMhB,MACrBuM,qBAAqBiL,IAAIpY,MAAM,CACjC,GAEM2lB,eAAe1Z,UAAU5H,IAAIwD,SAC/BqB,gCAAsC;AAAA,IACpCL,SAAS;AAAA,MACP,GAAGA;AAAAA,MACHzH;AAAAA,IACF;AAAA,IACAwkB,aAAa3Z,UAAU5H,GAAGwD;AAAAA,IAC1Bge,WAAW;AAAA,EAAA,CACZ,IACDliB,QACEmiB,cAAc7Z,UAAU5H,IAAIO,QAC9BsE,gCAAsC;AAAA,IACpCL,SAAS;AAAA,MACP,GAAGA;AAAAA,MACHzH;AAAAA,IACF;AAAA,IACAwkB,aAAa3Z,UAAU5H,GAAGO;AAAAA,IAC1BihB,WAAW;AAAA,EACZ,CAAA,IACDliB,QACEoiB,kBACJJ,gBAAgBG,cACZ;AAAA,IACEje,QAAQ8d;AAAAA,IACR/gB,OAAOkhB;AAAAA,EACT,IACAniB,QAEAe,YAAYqhB,kBACbxa,aAAawa,iBAAiB9Z,UAAUjM,MAAM,KAAKA,OAAO0E,YAC3D1E,OAAO0E;AAEX,MAAI,CAACA;AACH;AAGF,QAAMshB,kBAAkBte,sBAAsB;AAAA,IAC5ClB,QAAQqC,QAAQrC;AAAAA,IAChBxG;AAAAA,IACA2H,OAAOjD;AAAAA,EAAAA,CACR,GACKuhB,eAAeD,kBACjB9c,4BAAkC;AAAA,IAChCL,SAAS;AAAA,MACP,GAAGA;AAAAA,MACHzH;AAAAA,IACF;AAAA,IACA8kB,gBAAgBF,gBAAgBne;AAAAA,EACjC,CAAA,IACDlE,QACEwiB,cAAcH,kBAChB9c,4BAAkC;AAAA,IAChCL,SAAS;AAAA,MACP,GAAGA;AAAAA,MACHzH;AAAAA,IACF;AAAA,IACA8kB,gBAAgBF,gBAAgBphB;AAAAA,EACjC,CAAA,IACDjB;AAEA,MAAA,CAACsiB,gBAAgB,CAACE;AACd,UAAA,IAAIhjB,MAAM,uCAAuC;AAGrDiC,MAAAA,MAAM0Y,WAAWpZ,SAAS,GAAG;AAEpB0X,eAAAA,SACTpc,QACA,IACA;AAAA,MAACqE,IAAIK;AAAAA,MAAWJ,OAAOT,KAAKC;AAAAA,MAAQ2T,OAAO;AAAA,MAAMkH,SAAS;AAAA,IAAA,CAC5D;AAGA,UAAMyH,WAAWnjB,eACfjD,OAAOsC,UACPuG,QAAQrC,OAAO5E,MAAMhB,MACrBuM,qBAAqBiL,IAAIpY,MAAM,CACjC,GAGMqmB,eAAend,wBAA8B;AAAA,MACjDL,SAAS;AAAA,QACP,GAAGA;AAAAA,QACHzH,OAAOglB;AAAAA,MACT;AAAA,MACAE,SAAS;AAAA,QAACze,QAAQoe;AAAAA,QAAcrhB,OAAOuhB;AAAAA,MAAW;AAAA,MAClDne,UAAUge,iBAAiBhe;AAAAA,IAAAA,CAC5B,GAEKue,mBAAmBnY,oBAA8B;AAAA,MAKrDvF,SAAS;AAAA,QACPuM,YAAY,CAAE;AAAA,QACd2B,cAAclO,QAAQkO;AAAAA,QACtB7E,UAAU;AAAA,QACV1L,QAAQqC,QAAQrC;AAAAA,QAChB9B,WAAW2hB;AAAAA,QACXjlB,OAAOglB;AAAAA,MAAAA;AAAAA,IACT,CACD;AAED,QAAI,CAACG;AACG,YAAA,IAAIpjB,MAAM,kCAAkC;AAG9CqjB,UAAAA,WAAWjb,aAAagb,kBAAkBvmB,MAAM;AAEtD,QAAI,CAACwmB;AACG,YAAA,IAAIrjB,MAAM,8BAA8B;AAI1CsjB,UAAAA,iBAAiBrhB,MAAMshB,QAAQF,QAAQ,IACzC,CACE,GAAGriB,OAAOC,MAAMpE,QAAQ;AAAA,MACtBqE,IAAImiB;AAAAA,MACJliB,OAAQK,CAAAA,SAASd,KAAKC,OAAOa,IAAI;AAAA,IAClC,CAAA,CAAC,IAEJ,CAAE;AAEN,eAAW,CAACA,MAAME,IAAI,KAAK4hB,gBAAgB;AACzC,YAAM7jB,QAAQ,CACZ,IAAInB,MAAMC,QAAQiD,KAAK/B,KAAK,IAAI+B,KAAK/B,QAAQ,CAAA,GAAI0U,OAC9CsH,WAAkBA,UAAUpG,IAC/B,GACAA,IAAI;AAENW,iBAAWiD,SACTpc,QACA;AAAA,QAAC4C;AAAAA,MAAAA,GACD;AAAA,QAACyB,IAAIQ;AAAAA,QAAMP,OAAOT,KAAKC;AAAAA,QAAQ2T,OAAO;AAAA,QAAMkH,SAAS;AAAA,MAAA,CACvD;AAAA,IAAA;AAAA,EACF,OACK;AAQL,QAAI,CAPiBld,MAAMyC,KACzBC,OAAOC,MAAMpE,QAAQ;AAAA,MACnBqE,IAAIK;AAAAA,MACJJ,OAAQK,CAAAA,SAAS3E,OAAOgF,WAAWL,IAAI;AAAA,IAAA,CACxC,CACH,GAAGN,GAAG,CAAC;AAGL;AAGF,UAAM,CAACzC,OAAOqC,SAAS,IAAIE,OAAOQ,KAAK3E,QAAQ0E,WAAW;AAAA,MACxD2Y,OAAO;AAAA,IACR,CAAA,GACKwB,kBACJ7e,OAAOsH,YAAY1F,KAAK,KACxBA,MAAMU,SAASsB,WAAW,KAC1B5D,OAAOgF,WAAWpD,MAAMU,SAAS,CAAC,CAAC,KACnCV,MAAMU,SAAS,CAAC,EAAEK,SAAS,KACvBf,MAAMU,SAAS,CAAC,IAChBqB;AAEN,QAAIkb,iBAAiB;AACb8H,YAAAA,gBAAgB9H,gBAAgBjc,SAAS,IACzCkc,gCAAgC6H,cAAcrP,OACjDyH,CAAiBA,iBAAAA,iBAAiBvG,IACrC;AAEAW,iBAAWiD,SACTpc,QACA;AAAA,QACE4C,OACE+jB,cAAc/iB,WAAWkb,8BAA8Blb,SACnD,CAAC,GAAG+iB,eAAenO,IAAI,IACvBsG;AAAAA,MAAAA,GAER;AAAA,QACEza,IAAIJ;AAAAA,QACJK,OAAQK,CAAAA,SAAS3E,OAAOgF,WAAWL,IAAI;AAAA,MAAA,CAE3C;AAAA,IACF;AACSkU,aAAAA,eAAeL,IAAI,IAAI;AAAA,EAAA;AAIlC,MAAIxY,OAAO0E,WAAW;AAEpB,UAAMA,aAAY1E,OAAO0E;AACzB1E,WAAO0E,YAAY;AAAA,MAAC,GAAGA;AAAAA,IAAS;AAAA,EAAA;AAEpC,GC3MakiB,gCAETA,CAAC;AAAA,EAAC3a;AAAS,MAAM;AACnB,QAAM4a,iBAAiBzd,8BAA8B6C,UAAU5H,GAAGwD,MAAM,GAClEif,gBAAgB1d,8BAA8B6C,UAAU5H,GAAGO,KAAK,GAEhEmiB,kBACJF,mBAAmBljB,SACfK,aAAa;AAAA,IACXhE,QAAQiM,UAAUjM;AAAAA,IAClBqB,MAAMwlB;AAAAA,EACP,CAAA,IACDljB,QACAkC,iBACJihB,kBAAkBnjB,SACdK,aAAa;AAAA,IACXhE,QAAQiM,UAAUjM;AAAAA,IAClBqB,MAAMylB;AAAAA,EACP,CAAA,IACDnjB;AAEN,MACEsI,UAAU5H,GAAGwD,OAAOhD,KAAKjB,WAAW,KACpCqI,UAAU5H,GAAGO,MAAMC,KAAKjB,WAAW,KACnCmjB,mBACAlhB,kBACAkhB,gBAAgB,CAAC,MAAMlhB,eAAe,CAAC,GACvC;AACWmhB,eAAAA,YAAY/a,UAAUjM,QAAQ;AAAA,MACvCqE,IAAI,CAAC0iB,gBAAgB,CAAC,CAAC;AAAA,IAAA,CACxB;AAED;AAAA,EAAA;AAGF,QAAMpf,QAAQ4D,aAAaU,UAAU5H,IAAI4H,UAAUjM,MAAM;AAEzD,MAAI,CAAC2H;AACG,UAAA,IAAIxE,MACR,2CAA2C0S,KAAKC,UAAU7J,UAAU5H,EAAE,CAAC,EACzE;AAGF4H,YAAUjM,OAAOinB,OAAO;AAAA,IACtB5iB,IAAIsD;AAAAA,IACJmS,SAAS7N,UAAU4Z,cAAc;AAAA,IACjCqB,MAAMjb,UAAUib;AAAAA,EAAAA,CACjB;AACH,GCjDaC,4CAETA,CAAC;AAAA,EAACte;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAMmb,qBAAqBC,kBAAkB;AAAA,IAC3Cxe;AAAAA,IACAmF,cAAc;AAAA,MACZnM,OAAOoK,UAAU+B,aAAapN;AAAAA,MAC9B,GAAIqL,UAAU+B,aAAa5M,SAAS,CAAA;AAAA,IACtC;AAAA,IACAgV,SAAS;AAAA,MAACC,aAAa;AAAA,MAAOC,gBAAgB;AAAA,IAAA;AAAA,EAAI,CACnD;AAED,MAAI,CAAC8Q;AACG,UAAA,IAAIjkB,MACR,iCAAiC0S,KAAKC,UAAU7J,UAAU+B,YAAY,CAAC,EACzE;AAGE,MAAA,CAAC/B,UAAUjM,OAAO0E,WAAW;AAC/B2G,YAAQyG,MAAM,kDAAkD;AAChE;AAAA,EAAA;AAGI,QAAA,CAACwV,cAAc,IAAI7lB,MAAMyC,KAC7BC,OAAOC,MAAM6H,UAAUjM,QAAQ;AAAA,IAC7BqE,IAAI4H,UAAUjM,OAAO0E,UAAUE,MAAMC;AAAAA,IACrCP,OAAQK,CAAAA,SAASsH,UAAUjM,OAAOsH,YAAY3C,IAAI;AAAA,EAAA,CACnD,CACH,EAAEN,GAAG,CAAC,KAAK,CAACV,QAAWA,MAAS;AAEhC,MAAI,CAAC2jB,gBAAgB;AACnBjc,YAAQyG,MAAM,mDAAmD;AACjE;AAAA,EAAA;AAaIvP,QAAAA,QAVQhB,aACZ,CACE;AAAA,IACEM,OAAOgH,QAAQrC,OAAO5E,MAAMhB;AAAAA,IAC5BS,MAAMwH,QAAQkO,aAAa;AAAA,IAC3BzU,UAAU,CAAC8kB,kBAAkB;AAAA,EAAA,CAC9B,GAEH;AAAA,IAAC5lB,aAAaqH,QAAQrC;AAAAA,EAAAA,CACxB,EAAEnC,GAAG,CAAC,GACe/B,SAAS+B,GAAG,CAAC;AAElC,MAAI,CAAC9B,OAAO;AACV8I,YAAQyG,MAAM,gCAAgC;AAC9C;AAAA,EAAA;AAGSyH,aAAAA,YAAYtN,UAAUjM,QAAQuC,KAAK;AAChD,GCvDaglB,oCAETA,CAAC;AAAA,EAAC1e;AAAAA,EAASoD;AAAS,MAAM;AACxB,MAAA,CAACA,UAAUjM,OAAO0E,WAAW;AACvBoN,YAAAA,MAAM,8CAA8C7F,SAAS;AACrE;AAAA,EAAA;AAGI,QAAA,CAACrG,YAAYC,cAAc,IAAIpE,MAAMyC,KACzCC,OAAOC,MAAM6H,UAAUjM,QAAQ;AAAA,IAC7BqE,IAAI4H,UAAUjM,OAAO0E,UAAUE,MAAMC;AAAAA,IACrCP,OAAQK,CAAAA,SAASsH,UAAUjM,OAAOsH,YAAY3C,IAAI;AAAA,EACnD,CAAA,CACH,EAAE,CAAC,KAAK,CAAChB,QAAWA,MAAS;AAEzB,MAAA,CAACiC,cAAc,CAACC,gBAAgB;AAC1BiM,YAAAA,MAAM,gDAAgD7F,SAAS;AACvE;AAAA,EAAA;AAGI7J,QAAAA,WAAWwD,WAAWxD,YAAY,CAAE,GACpCwQ,cAAc3G,UAAU2G,cAC1B3G,UAAU2G,YAAYjR,IAAK8b,CAAgB,gBAAA;AAAA,IACzC5b,OAAO4b,WAAW7c;AAAAA,IAClBS,MAAMwH,QAAQkO,aAAa;AAAA,IAC3B,GAAG0G,WAAWrc;AAAAA,IACd,IACFuC;AAEAiP,iBAAeA,YAAYhP,SAAS,KACtCuV,WAAWiD,SAASnQ,UAAUjM,QAAQ;AAAA,IACpCoC,UAAU,CAAC,GAAGA,UAAU,GAAGwQ,WAAW;AAAA,EACvC,CAAA,GAGHuG,WAAWI,YAAYtN,UAAUjM,QAAQ;AAAA,IACvC6B,OAAO;AAAA,IACPR,MAAMwH,QAAQkO,aAAa;AAAA,IAC3BpU,MAAMsJ,UAAUtJ;AAAAA,IAChBC,OAAO,CACL,GAAIgQ,aAAajR,IAAK8b,CAAeA,eAAAA,WAAWpc,IAAI,KAAK,CACzD,GAAA,GAAI4K,UAAUwM,cAAc,CAAG,CAAA;AAAA,EAAA,CAElC;AACH,GChCa+O,qCAETA,CAAC;AAAA,EAAC3e;AAAAA,EAASoD;AAAS,MAAM;AAC5B,QAAMiK,cAAcC,WAAW;AAAA,IAC7BvU,OAAOqK,UAAUrK;AAAAA,IACjBiH;AAAAA,IACAuN,SAAS;AAAA,MAACC,aAAa;AAAA,MAAOC,gBAAgB;AAAA,IAAA;AAAA,EAAI,CACnD;AAED,MAAI,CAACJ;AACG,UAAA,IAAI/S,MAAM,yBAAyB0S,KAAKC,UAAU7J,UAAUrK,KAAK,CAAC,EAAE;AAG5E,QAAM6lB,WAAWlmB,aAAa,CAAC2U,WAAW,GAAG;AAAA,IAAC1U,aAAaqH,QAAQrC;AAAAA,EAAO,CAAA,EAAE,CAAC;AAE7E,MAAI,CAACihB;AACH,UAAM,IAAItkB,MACR,6CAA6C0S,KAAKC,UAAUI,WAAW,CAAC,EAC1E;AAGU,cAAA;AAAA,IACVtU,OAAO6lB;AAAAA,IACPC,WAAWzb,UAAUyb;AAAAA,IACrBC,QAAQ1b,UAAU0b,UAAU;AAAA,IAC5B3nB,QAAQiM,UAAUjM;AAAAA,IAClBwG,QAAQqC,QAAQrC;AAAAA,EAAAA,CACjB;AACH;AAEO,SAASohB,YAAY;AAAA,EAC1BhmB;AAAAA,EACA8lB;AAAAA,EACAC;AAAAA,EACA3nB;AAAAA,EACAwG;AAOF,GAAG;AACD,QAAM,CAACqhB,YAAYC,cAAc,IAAI5iB,uBAAuB;AAAA,IAAClF;AAAAA,EAAO,CAAA,GAC9D,CAAC+nB,UAAUC,YAAY,IAAIxiB,qBAAqB;AAAA,IAACxF;AAAAA,EAAAA,CAAO;AAG5D,MAAA,CAACA,OAAO0E,aACR,CAACmjB,cACD,CAACC,kBACD,CAACC,YACD,CAACC,cACD;AACIL,eAAW,UACbte,UAAUzE,MAAM5E,MAAM;AAGxB,UAAM,CAAC+J,WAAWzD,aAAa,IAAID,aAAa;AAAA,MAACrG;AAAAA,IAAAA,CAAO;AAExD,QAAI0nB,cAAc;AAChBvO,iBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QAACyC,IAAI,CAAC,CAAC;AAAA,MAAE,CAAA,GAE7CsjB,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQ,CAAC,CAAC,CAAC,CAAC,IAC1C2nB,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQ,CAAC,CAAC,CAAC,CAAC;AAAA,aAE1C0nB,cAAc,SAAS;AAC1BO,YAAAA,WAAW3hB,gBAAgB,CAACA,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5D6S,iBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QAACyC,IAAI4jB;AAAAA,MAAAA,CAAS,GAElDN,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC,IAC/CN,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQioB,QAAQ,CAAC;AAAA,IAAA,OAEnD;AAGL,UAAIle,aAAarG,qBAAqB,CAACqG,SAAS,GAAGvD,MAAM,GAAG;AAG1D2S,mBAAW6N,YAAYhnB,QAAQ;AAAA,UAACqE,IAAIiC;AAAAA,QAAc,CAAA,GAElD6S,WAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACtCyC,IAAIiC;AAAAA,UACJqhB,QAAQ;AAAA,QACT,CAAA,GAEDxO,WAAWiJ,SAASpiB,MAAM,GAEtB2nB,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQsG,aAAa,CAAC,IACpDqhB,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQsG,aAAa,CAAC;AAG7D;AAAA,MAAA;AAIAtG,UAAAA,OAAOsH,YAAY1F,KAAK,KACxBmI,aACA/J,OAAOsH,YAAYyC,SAAS,GAC5B;AACA,cAAMme,kBAAkB/jB,OAAOuB,IAAI1F,QAAQsG,aAAa;AAExD6S,mBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACzCyC,IAAIF,OAAOuB,IAAI1F,QAAQsG,aAAa;AAAA,QACrC,CAAA,GAEGqhB,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQkoB,eAAe,IAChCP,WAAW,UACpBxO,WAAWiJ,SAASpiB,MAAM;AAG5B;AAAA,MAAA;AAGIioB,YAAAA,WAAW3hB,gBAAgB,CAACA,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAE5D6S,iBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QAACyC,IAAI4jB;AAAAA,QAAUN,QAAQ;AAAA,MAAA,CAAM,GAEjEA,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC,IAC/CN,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQioB,QAAQ,CAAC;AAAA,IAAA;AAAA,EAE1D,WAEIP,cAAc,UAAU;AAC1B,UAAMU,mBAAmBpoB,OAAO0E,WAC1BS,sBAAsBC,MAAMC,MAAM+iB,gBAAgB;AAExDjP,eAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,MACtCyC,IAAI,CAACc,oBAAoBN,KAAK,CAAC,CAAC;AAAA,MAChC8iB,QAAQ;AAAA,IACT,CAAA,GAEGA,WAAW,UACbxO,WAAWwO,OACT3nB,QACAmE,OAAOkB,MAAMrF,QAAQ,CAACmF,oBAAoBN,KAAK,CAAC,CAAC,CAAC,CACpD,IACS8iB,WAAW,SACpBxO,WAAWwO,OACT3nB,QACAmE,OAAOuB,IAAI1F,QAAQ,CAACmF,oBAAoBN,KAAK,CAAC,CAAC,CAAC,CAClD;AAAA,EAAA,WAEO6iB,cAAc,SAAS;AAChC,UAAMU,mBAAmBpoB,OAAO0E,WAG1BujB,WAAW,CAFS7iB,MAAMM,IAAI0iB,gBAAgB,EAEhBvjB,KAAK,CAAC,IAAI,CAAC;AAE/CsU,eAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,MACtCyC,IAAI4jB;AAAAA,MACJN,QAAQ;AAAA,IAAA,CACT,GAEGA,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC,IAC/CN,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQioB,QAAQ,CAAC;AAAA,EAAA,OAEnD;AAGL,UAAMG,mBAAmBpoB,OAAO0E,WAC1B2jB,mBAAmBlkB,OAAOkB,MAAMrF,QAAQgoB,YAAY;AAEtD5iB,QAAAA,MAAM0Y,WAAWsK,gBAAgB,KAAK,CAACpoB,OAAOsH,YAAY1F,KAAK,GAAG;AACpEuX,iBAAW8N,OAAOjnB,QAAQ;AAAA,QAACqE,IAAI+jB;AAAAA,MAAAA,CAAiB;AAEhD,YAAM/B,eAAermB,OAAO0E,WAEtB,CAACkB,YAAYC,cAAc,IAAIpB,cAAc;AAAA,QAACzE;AAAAA,MAAAA,CAAO;AAE3DmZ,iBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QACtCua,OAAO;AAAA,MAAA,CACR;AAED,YAAMmM,oBACJjC,aAAaxe,OAAOE,WAAW,IAC3B3C,MAAM+G,UAAUka,cAAc;AAAA,QAC5BhW,MAAM;AAAA,QACN1L,MAAM/C;AAAAA,QACNiD,MAAM,CAACwhB,aAAaxe,OAAOhD,KAAK,CAAC,CAAC;AAAA,MACnC,CAAA,IACDwhB;AAEFsB,iBAAW,UAAUW,qBACvBnP,WAAWwO,OAAO3nB,QAAQsoB,iBAAiB,GAGzC1iB,cAAclC,qBAAqB,CAACkC,UAAU,GAAGY,MAAM,KACzD2S,WAAW6N,YAAYhnB,QAAQ;AAAA,QAACqE,IAAIwB;AAAAA,MAAAA,CAAe;AAGrD;AAAA,IAAA;AAGF,QAAI7F,OAAOsH,YAAYygB,QAAQ,KAAK/nB,OAAOsH,YAAY1F,KAAK,GAAG;AACvDuD,YAAAA,sBAAsBC,MAAMC,MAAM+iB,gBAAgB;AAExD,UAAI1kB,qBAAqB,CAACqkB,QAAQ,GAAGvhB,MAAM,GAAG;AAC5C,cAAM4hB,oBAAmBpoB,OAAO0E;AAEhCyU,mBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACtCyC,IAAI2jB;AAAAA,UACJL,QAAQ;AAAA,QAAA,CACT,GACDxO,WAAW6N,YAAYhnB,QAAQ;AAAA,UAACqE,IAAI0V,KAAKwO,KAAKP,YAAY;AAAA,QAAA,CAAE,GAExDL,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmF,mBAAmB,IACpCwiB,WAAW,QACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQgoB,YAAY,CAAC,IAE1D7O,WAAWwO,OAAO3nB,QAAQooB,iBAAgB;AAG5C;AAAA,MAAA;AAGF,UAAIT,WAAW,OAAO;AACpBxO,mBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACzCua,OAAO;AAAA,QAAA,CACR;AAED;AAAA,MAAA;AAGFhD,iBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QACzCyC,IAAI+jB;AAAAA,QACJjM,OAAO;AAAA,MAAA,CACR,GAEGwL,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmF,mBAAmB,IAExC+G,MAAME,OAAOjH,qBAAqBkjB,gBAAgB,KACrDlP,WAAWwO,OAAO3nB,QAAQmF,mBAAmB;AAAA,IAI5CnF,WAAAA,OAAOsH,YAAYygB,QAAQ,GAUzB;AACCS,YAAAA,qBAAqBrkB,OAAOkB,MAAMrF,QAAQgoB,YAAY,GACtDK,oBAAmBlkB,OAAOuB,IAAI1F,QAAQgoB,YAAY,GAClD7iB,sBAAsBC,MAAMC,MAAM+iB,gBAAgB,GAClD3iB,oBAAoBL,MAAMM,IAAI0iB,gBAAgB;AAEpD,UACEhjB,MAAM4M,YAAYoW,gBAAgB,KAClClc,MAAME,OAAOjH,qBAAqBqjB,kBAAkB;AAEpDrP,mBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACtCyC,IAAI2jB;AAAAA,UACJL,QAAQ;AAAA,QAAA,CACT,IAEGA,WAAW,WAAWA,WAAW,UACnCxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQgoB,YAAY,CAAC,GAG1DtkB,qBAAqB,CAACqkB,QAAQ,GAAGvhB,MAAM,KACzC2S,WAAW6N,YAAYhnB,QAAQ;AAAA,UAACqE,IAAI0V,KAAKwO,KAAKP,YAAY;AAAA,QAAA,CAAE;AAAA,eAG9D5iB,MAAM4M,YAAYoW,gBAAgB,KAClClc,MAAME,OAAO3G,mBAAmB4iB,iBAAgB,GAChD;AACA,cAAMJ,WAAW,CAACD,aAAa,CAAC,IAAI,CAAC;AAErC7O,mBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACtCyC,IAAI4jB;AAAAA,UACJN,QAAQ;AAAA,QACT,CAAA,IAEGA,WAAW,WAAWA,WAAW,UACnCxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC;AAAA,MAG1D7iB,WAAAA,MAAM0Y,WAAWsK,gBAAgB,KACjClc,MAAME,OAAOjH,qBAAqBqjB,kBAAkB,KACpDtc,MAAME,OAAO3G,mBAAmB4iB,iBAAgB;AAEhDlP,mBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACzCyC,IAAI+jB;AAAAA,QAAAA,CACL,GAEGT,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQgoB,YAAY,CAAC,IACnDL,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQgoB,YAAY,CAAC;AAAA,eAG5D5iB,MAAM0Y,WAAWsK,gBAAgB,KACjClc,MAAME,OAAOjH,qBAAqBqjB,kBAAkB;AAEpDrP,mBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACzCyC,IAAI+jB;AAAAA,QAAAA,CACL,GAEGT,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQgoB,YAAY,CAAC,IACnDL,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQgoB,YAAY,CAAC;AAAA,eAG5D5iB,MAAM0Y,WAAWsK,gBAAgB,KACjClc,MAAME,OAAO3G,mBAAmB4iB,iBAAgB;AAEhDlP,mBAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,UACzCyC,IAAI+jB;AAAAA,QACL,CAAA,GAEGT,WAAW,UACbxO,WAAWwO,OACT3nB,QACAmE,OAAOkB,MAAMrF,QAAQ+Z,KAAKwO,KAAKP,YAAY,CAAC,CAC9C,IACSL,WAAW,SACpBxO,WAAWwO,OACT3nB,QACAmE,OAAOuB,IAAI1F,QAAQ+Z,KAAKwO,KAAKP,YAAY,CAAC,CAC5C;AAAA,WAEG;AACL,cAAMI,oBAAmBpoB,OAAO0E,WAC1B,CAACqB,UAAU,IAAIJ,cAAc;AAAA,UAAC3F;AAAAA,QAAAA,CAAO;AAEvC+F,YAAAA,cAAc/F,OAAOgF,WAAWe,UAAU;AAC5CoT,qBAAWsP,WAAWzoB,QAAQ;AAAA,YAC5BqE,IAAI+jB;AAAAA,UACL,CAAA,GAEDjP,WAAWgP,eAAenoB,QAAQ,CAAC4B,KAAK,GAAG;AAAA,YACzCyC,IAAI+jB;AAAAA,UAAAA,CACL,GAEGT,WAAW,WAAWA,WAAW,QACnCxO,WAAWwO,OAAO3nB,QAAQ,CAACgoB,aAAa,CAAC,IAAI,CAAC,CAAC,IAE/C7O,WAAWwO,OAAO3nB,QAAQooB,iBAAgB;AAAA,aAEvC;AACL,gBAAMH,WAAW,CAACD,aAAa,CAAC,IAAI,CAAC;AACrC7O,qBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,YACtCyC,IAAI4jB;AAAAA,YACJN,QAAQ;AAAA,UACT,CAAA,GACDxO,WAAWwO,OAAO3nB,QAAQooB,iBAAgB,GAEtCT,WAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC,IAC/CN,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQioB,QAAQ,CAAC;AAAA,QAAA;AAAA,MAE1D;AAAA,IACF,OA5HiC;AACjC9O,iBAAWI,YAAYvZ,QAAQ,CAAC4B,KAAK,GAAG;AAAA,QAAC+lB,QAAQ;AAAA,MAAA,CAAM;AAEvD,YAAMM,WAAW,CAACD,aAAa,CAAC,IAAI,CAAC;AAEjCL,iBAAW,UACbxO,WAAWwO,OAAO3nB,QAAQmE,OAAOkB,MAAMrF,QAAQioB,QAAQ,CAAC,IAC/CN,WAAW,SACpBxO,WAAWwO,OAAO3nB,QAAQmE,OAAOuB,IAAI1F,QAAQioB,QAAQ,CAAC;AAAA,IAAA;AAAA,EAE1D;AAuHR;ACrYO,MAAMS,sCAETA,CAAC;AAAA,EAACzc;AAAS,MAAM;AACR0c,aAAAA,KAAK1c,UAAUjM,QAAQ;AAAA,IAChCknB,MAAM;AAAA,IACN0B,UAAU3c,UAAU2c;AAAAA,IACpB9O,SAAS;AAAA,EAAA,CACV;AACH,GCPa+O,mCAETA,CAAC;AAAA,EAAC5c;AAAS,MAAM;AACb5H,QAAAA,KAAK,CAACqH,YAAYO,UAAU5H,IAAI4H,UAAUjM,MAAM,EAAE,CAAC,CAAC,GACpD8oB,KAAK,CAACpd,YAAYO,UAAU6c,IAAI7c,UAAUjM,MAAM,EAAE,CAAC,CAAC;AAE/C+oB,aAAAA,UAAU9c,UAAUjM,QAAQ;AAAA,IACrCqE;AAAAA,IACAykB;AAAAA,IACAhiB,MAAM;AAAA,EAAA,CACP;AACH,GCZakiB,qCAETA,CAAC;AAAA,EAAC/c;AAAS,MAAM;AACR0c,aAAAA,KAAK1c,UAAUjM,QAAQ;AAAA,IAChCknB,MAAM;AAAA,IACN0B,UAAU3c,UAAU2c;AAAAA,EAAAA,CACrB;AACH,GCNaK,gCAETA,CAAC;AAAA,EAAChd;AAAS,MAAM;AACnB,QAAMoa,eAAe9a,aAAaU,UAAU5H,IAAI4H,UAAUjM,MAAM;AAE5DqmB,iBACFlN,WAAWwO,OAAO1b,UAAUjM,QAAQqmB,YAAY,IAEhDlN,WAAWiJ,SAASnW,UAAUjM,MAAM;AAExC,GCyCMkpB,mCAAqE;AAAA,EACzE,kBAAkBrF;AAAAA,EAClB,qBAAqBS;AAAAA,EACrB,aAAaQ;AAAAA,EACb,eAAeK;AAAAA,EACf,iBAAiBO;AAAAA,EACjB,oBAAoBhH;AAAAA,EACpB,QAAUkI;AAAAA,EACV,gBAAgBtE;AAAAA,EAChB,gBAAgBb;AAAAA,EAChB,gBAAgB+F;AAAAA,EAChB,wBAAwBL;AAAAA,EACxB,eAAeI;AAAAA,EACf,eAAevO;AAAAA,EACf,iBAAiB0P;AAAAA,EACjB,cAAcG;AAAAA,EACd,gBAAgBG;AAAAA,EAChB,QAAUC;AACZ;AAEO,SAASE,iBAAiB;AAAA,EAC/BtgB;AAAAA,EACAoD;AAIF,GAAG;AACG,MAAA;AACF,YAAQA,UAAUoE,MAAI;AAAA,MACpB,KAAK,kBAAkB;AACrB6Y,yCAAiC,gBAAgB,EAAE;AAAA,UACjDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,qBAAqB;AACxBid,yCAAiC,mBAAmB,EAAE;AAAA,UACpDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,aAAa;AAChBid,yCAAiC,WAAW,EAAE;AAAA,UAC5CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,eAAe;AAClBid,yCAAiC,aAAa,EAAE;AAAA,UAC9CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,iBAAiB;AACpBid,yCAAiC,eAAe,EAAE;AAAA,UAChDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,oBAAoB;AACvBid,yCAAiC,kBAAkB,EAAE;AAAA,UACnDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,UAAU;AACbid,yCAAiCjC,OAAO;AAAA,UACtCpe;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,gBAAgB;AACnBid,yCAAiC,cAAc,EAAE;AAAA,UAC/CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,gBAAgB;AACnBid,yCAAiC,cAAc,EAAE;AAAA,UAC/CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,gBAAgB;AACnBid,yCAAiC,cAAc,EAAE;AAAA,UAC/CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,wBAAwB;AAC3Bid,yCAAiC,sBAAsB,EAAE;AAAA,UACvDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,eAAe;AAClBid,yCAAiC,aAAa,EAAE;AAAA,UAC9CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,eAAe;AAClBid,yCAAiC,aAAa,EAAE;AAAA,UAC9CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,iBAAiB;AACpBid,yCAAiC,eAAe,EAAE;AAAA,UAChDrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,cAAc;AACjBid,yCAAiC,YAAY,EAAE;AAAA,UAC7CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,KAAK,gBAAgB;AACnBid,yCAAiC,cAAc,EAAE;AAAA,UAC/CrgB;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,MAEF,SAAS;AACPid,yCAAiCvB,OAAO;AAAA,UACtC9e;AAAAA,UACAoD;AAAAA,QAAAA,CACD;AACD;AAAA,MAAA;AAAA,IACF;AAAA,WAEK6F,OAAO;AACNA,YAAAA,MACN,IAAI3O,MACF,cAAc8I,UAAUoE,IAAI,oBAAoByB,MAAMsX,OAAO,EAC/D,CACF;AAAA,EAAA;AAEJ;AChNA,MAAMC,2CAAgEpc,QAAQ;AAE9Dqc,SAAAA,+BAA+BtpB,QAAgBqa,IAAgB;AAC7EgP,uBAAqB7O,IAAIxa,QAAQ0O,oBAAqB,CAAA,GACtDvK,OAAOia,mBAAmBpe,QAAQqa,EAAE,GACpCgP,qBAAqB7O,IAAIxa,QAAQ2D,MAAS;AAC5C;AAEO,SAAS4lB,sBAAsBvpB,QAAgB;AAC7CqpB,SAAAA,qBAAqBjR,IAAIpY,MAAM;AACxC;AAEO,SAASwpB,6BAA6BxpB,QAAgB;AACpDupB,SAAAA,sBAAsBvpB,MAAM,MAAM2D;AAC3C;ACVO,SAAS8lB,yBAAyBrhB,aAA0B;AACjE,SAAO,SAA4BpI,QAAgB;AACjD,QAAIoI,YAAYG,YAAAA,EAAcM,QAAQ6gB,cAAc/lB;AAC3C3D,aAAAA;AAGH,UAAA;AAAA,MAACinB,QAAQ0C;AAAAA,MAAchC;AAAAA,IAAAA,IAAU3nB;AAEvCA,WAAAA,OAAOinB,SAAU7Q,CAAY,YAAA;AACvBoT,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxC2pB,qBAAavT,OAAO;AACpB;AAAA,MAAA;AAGI/R,YAAAA,KAAK+R,SAAS/R,MAAMrE,OAAO0E;AAEjC,UAAI,CAACL,IAAI;AACPgH,gBAAQyG,MAAM,qDAAqD;AACnE;AAAA,MAAA;AAGF,YAAMnK,QAAQxD,OAAOwD,MAAM3H,QAAQqE,EAAE,GAE/BK,YAAYgD,sBAAsB;AAAA,QACtClB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,QAC1CxG;AAAAA,QACA2H;AAAAA,MAAAA,CACD;AAED,UAAI,CAACjD,WAAW;AACd2G,gBAAQyG,MACN,0DACF;AACA;AAAA,MAAA;AAGF1J,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNhM,IAAIK;AAAAA,UACJmhB,WAAWzP,SAAS0D,UAAU,aAAa;AAAA,UAC3CoN,MAAM9Q,SAAS8Q;AAAAA,QACjB;AAAA,QACAlnB;AAAAA,MAAAA,CACD;AAAA,IAAA,GAGHA,OAAO6pB,iBAAkB3C,CAAS,SAAA;AAC5BsC,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxCqL,gBAAQyG,MAAM,yCAAyC;AACvD;AAAA,MAAA;AAGF1J,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACN6W;AAAAA,QACF;AAAA,QACAlnB;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAO8pB,gBAAiB5C,CAAS,SAAA;AAC3BsC,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxCqL,gBAAQyG,MAAM,wCAAwC;AACtD;AAAA,MAAA;AAGF1J,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACN6W;AAAAA,QACF;AAAA,QACAlnB;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAO+pB,cAAc,MAAM;AACrBP,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxCqL,gBAAQyG,MAAM,sCAAsC;AACpD;AAAA,MAAA;AAGF1J,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAOgqB,aAAcC,CAAiB,iBAAA;AAChCT,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxCqL,gBAAQyG,MAAM,qCAAqC;AACnD;AAAA,MAAA;AAGF1J,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U;AAAAA,UAAAA;AAAAA,QAEJ;AAAA,QACAjqB;AAAAA,MAAAA,CACD;AAAA,IAAA,GAGHA,OAAOkqB,kBAAkB,MAAM;AACzBV,UAAAA,6BAA6BxpB,MAAM,GAAG;AACN,0CAAA;AAAA,UAChC6I,SAAS;AAAA,YACPkO,cAAc3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,YAChDvQ,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC5C;AAAA,UACAyF,WAAW;AAAA,YAAsBtJ,MAAM;AAAA;AAAA,YAAM3C;AAAAA,UAAAA;AAAAA,QAAM,CACpD;AACD;AAAA,MAAA;AAGFoI,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAOoZ,aAAczW,CAAS,SAAA;AACxB6mB,UAAAA,6BAA6BxpB,MAAM,GAAG;AACN,0CAAA;AAAA,UAChC6I,SAAS;AAAA,YACPkO,cAAc3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,YAChDvQ,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC5C;AAAA,UACAyF,WAAW;AAAA,YAAsBtJ;AAAAA,YAAM3C;AAAAA,UAAAA;AAAAA,QAAM,CAC9C;AACD;AAAA,MAAA;AAGFoI,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACN1N;AAAAA,QACF;AAAA,QACA3C;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAOmqB,OAAO,MAAM;AACdX,UAAAA,6BAA6BxpB,MAAM,GAAG;AACvB,yBAAA;AAAA,UACf6I,SAAS;AAAA,YACPkO,cAAc3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,YAChDvQ,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC5C;AAAA,UACAyF,WAAW;AAAA,YACToE,MAAM;AAAA,YACNrQ;AAAAA,UAAAA;AAAAA,QACF,CACD;AACD;AAAA,MAAA;AAGFoI,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAO2nB,SAAU5C,CAAa,aAAA;AACxByE,UAAAA,6BAA6BxpB,MAAM,GAAG;AACxC2nB,eAAO5C,QAAQ;AACf;AAAA,MAAA;AAGF,YAAMpd,QAAQxD,OAAOwD,MAAM3H,QAAQ+kB,QAAQ;AAE3C3c,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNhM,IAAIqD,sBAAsB;AAAA,YACxBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,YAC1CxG;AAAAA,YACA2H;AAAAA,UACD,CAAA;AAAA,QACH;AAAA,QACA3H;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIHA,OAAOoqB,kBAAkB,MAAM;AAC7B/e,cAAQyG,MAAM,0CAA0C;AAAA,IAAA,GAI1D9R,OAAOqqB,OAAO,MAAM;AACdb,UAAAA,6BAA6BxpB,MAAM,GAAG;AACvB,yBAAA;AAAA,UACf6I,SAAS;AAAA,YACPkO,cAAc3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,YAChDvQ,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC5C;AAAA,UACAyF,WAAW;AAAA,YACToE,MAAM;AAAA,YACNrQ;AAAAA,UAAAA;AAAAA,QACF,CACD;AACD;AAAA,MAAA;AAGFoI,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IAAA,GAIIA;AAAAA,EACT;AACF;AC/OO,SAASsqB,oBAAoBliB,aAA0B;AAC5D,SAAO,SACLpI,QACyB;AACnB,UAAA;AAAA,MAAC8b,OAAAA;AAAAA,IAAAA,IAAS9b;AAChBA,WAAAA,OAAO8b,QAAS7P,CAAc,cAAA;AACxB7D,UAAAA,YAAYG,YAAY,EAAEC,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY,GAAG;AACjEsT,QAAAA,OAAM7P,SAAS;AACf;AAAA,MAAA;AAOEsO,UAAAA,mBAAmBva,MAAM,GAAG;AAC9B8b,QAAAA,OAAM7P,SAAS;AACf;AAAA,MAAA;AAOF,UAAI2O,UAAU5a,MAAM,KAAK+a,UAAU/a,MAAM,GAAG;AAC1C8b,QAAAA,OAAM7P,SAAS;AACf;AAAA,MAAA;AAGF,YAAMse,OAAOniB,YAAYG,YAAY,EAAEM,QAAQ6gB,aAAa;AACxDa,aAAO,KAAKvqB,OAAOsC,SAASsB,UAAU2mB,SAErCte,UAAUoE,SAAS,iBAClBpE,UAAUoE,SAAS,iBACrBpE,UAAUpH,KAAKjB,WAAW,KAK9BkY,OAAM7P,SAAS;AAAA,IAAA,GAEVjM;AAAAA,EACT;AACF;AC1CO,SAASwqB,qBAAqBpiB,aAA0B;AAC7D,SAAO,SACLpI,QACyB;AACnB,UAAA;AAAA,MAAC8b,OAAAA;AAAAA,MAAOC;AAAAA,IAAAA,IAAiB/b;AAK/BA,WAAAA,OAAO8b,QAAS7P,CAAc,cAAA;AAKxBsO,UAAAA,mBAAmBva,MAAM,GAAG;AAC9B8b,QAAAA,OAAM7P,SAAS;AACf;AAAA,MAAA;AAOF,UAAI2O,UAAU5a,MAAM,KAAK+a,UAAU/a,MAAM,GAAG;AAC1C8b,QAAAA,OAAM7P,SAAS;AACf;AAAA,MAAA;AAGEA,UAAAA,UAAUoE,SAAS,cAAc;AACnC,cAAMoa,eAAe,CAAC,GAAGzkB,KAAK0kB,YAAY1qB,MAAM,CAAC,EAAE2B,IACjD,CAAC,CAACgD,IAAI,MAAMA,KAAKtD,IACnB;AAEM,QAAAya,OAAA;AAAA,UACJ,GAAG7P;AAAAA,UACH4Q,YAAY;AAAA,YACV,GAAG5Q,UAAU4Q;AAAAA,YACbxb,MACE4K,UAAU4Q,WAAWxb,SAASsC,UAC9B8mB,aAAa9R,SAAS1M,UAAU4Q,WAAWxb,IAAI,IAC3C+G,YAAYG,YAAY,EAAEM,QAAQkO,aAAa,IAC/C9K,UAAU4Q,WAAWxb;AAAAA,UAAAA;AAAAA,QAC7B,CACD;AAED;AAAA,MAAA;AAGE4K,UAAAA,UAAUoE,SAAS,iBACjB,CAAClM,OAAOsC,SAASwF,UAAUtH,IAAI,GAAG;AACpC,cAAM8lB,eAAe,CAAC,GAAGzkB,KAAK0kB,YAAY1qB,MAAM,CAAC,EAAE2B,IACjD,CAAC,CAACgD,IAAI,MAAMA,KAAKtD,IACnB;AAEM,QAAAya,OAAA;AAAA,UACJ,GAAG7P;AAAAA,UACHtH,MAAM;AAAA,YACJ,GAAGsH,UAAUtH;AAAAA,YACbtD,MACE4K,UAAUtH,KAAKtD,SAASsC,UACxB8mB,aAAa9R,SAAS1M,UAAUtH,KAAKtD,IAAI,IACrC+G,YAAYG,YAAY,EAAEM,QAAQkO,aAAa,IAC/C9K,UAAUtH,KAAKtD;AAAAA,UAAAA;AAAAA,QACvB,CACD;AAED;AAAA,MAAA;AAIJya,MAAAA,OAAM7P,SAAS;AAAA,IAAA,GAGjBjM,OAAO+b,gBAAiB4O,CAAU,UAAA;AAC1B,YAAA,CAAChmB,MAAME,IAAI,IAAI8lB;AACrB,UACE7nB,UAAQC,UAAU4B,IAAI,KACtBA,KAAK9C,UAAUuG,YAAYG,YAAcM,EAAAA,QAAQrC,OAAO5E,MAAMhB,MAC9D;AAEI,YAAA,CAAC+D,KAAKtD,MAAM;AACd+G,sBAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,YAACqB,MAAM+G,YAAYG,YAAY,EAAEM,QAAQkO,aAAa;AAAA,UAAA,GACtD;AAAA,YAAC1S,IAAIQ;AAAAA,UAAAA,CACP,GACAuD,YAAY2I,KAAK;AAAA,YAACV,MAAM;AAAA,UAAA,CAAmB;AAC3C;AAAA,QAAA;AAGF,mBAAW,CAAC9N,OAAOsJ,SAAS,KAAK7F,KAAK1D,SAAStC,QAAQ6E,IAAI;AACrD,cAAA,CAACtC,MAAMlB,MAAM;AACf+G,wBAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,cAACqB,MAAM+G,YAAYG,YAAY,EAAEM,QAAQkO,aAAa;AAAA,YAAA,GACtD;AAAA,cAAC1S,IAAIwH;AAAAA,YAAAA,CACP,GACAzD,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAmB;AAC3C;AAAA,UAAA;AAAA,MACF;AAGJ0L,oBAAc4O,KAAK;AAAA,IAAA,GAGd3qB;AAAAA,EACT;AACF;AC3FO,SAAS4qB,iBACdpkB,QAC4D;AACrD,SAAA,CAACxG,QAAiCkf,UAA0B;AACjE,QAAI2L,UAAU;AAEV,QAAA;AACF,cAAQ3L,MAAM7O,MAAI;AAAA,QAChB,KAAK;AACOya,oBAAAA,YAAY9qB,QAAQkf,OAAO1Y,MAAM;AAC3C;AAAA,QACF,KAAK;AACOukB,oBAAAA,WAAW/qB,QAAQkf,KAAK;AAClC;AAAA,QACF,KAAK;AACO8L,oBAAAA,SAAShrB,QAAQkf,KAAK;AAChC;AAAA,QACF,KAAK;AACO+L,oBAAAA,eAAejrB,QAAQkf,KAAK;AACtC;AAAA,MAAA;AAAA,aAEGiD,KAAK;AACZ9W,cAAQyG,MAAMqQ,GAAG;AAAA,IAAA;AAGZ0I,WAAAA;AAAAA,EACT;AACF;AAEA,SAASI,eACPjrB,QAIAkf,OACS;AACT,QAAMtd,QAAQspB,UAAUlrB,OAAOsC,UAAU4c,MAAMra,IAAI;AAEnD,MAAI,CAACjD;AACI,WAAA;AAGT,QAAMW,QAAQ4oB,eAAevpB,OAAOsd,MAAMra,IAAI;AAE1C,MAAA,CAACtC,SAWD,EANFX,SACA5B,OAAOsH,YAAY1F,MAAM+C,IAAI,KAC7Bua,MAAMra,KAAKjB,WAAW,KACtBsb,MAAMra,KAAK,CAAC,MAAM,cAClBqa,MAAMra,KAAK,CAAC,MAAM,WAEa,CAAChB,KAAKC,OAAOvB,MAAMoC,IAAI;AAC/C,WAAA;AAGT,QAAMwb,UAAU2C,MAAW5D,MAAM9d,KAAK,GAChC,CAACglB,QAAQ,IAAIgF,MAA2BjL,SAAS5d,MAAMoC,KAAKhC,MAAM;AAAA,IACtE0oB,uBAAuB;AAAA,EAAA,CACxB,GACKjI,SAAOkI,kBAAkBC,KAAShpB,MAAMoC,KAAKhC,MAAMyjB,QAAQ,GAAG,CAAC;AAErE,MAAIre,SAAS;AACF,aAAA,CAAC6U,IAAIja,IAAI,KAAKygB;AACnBxG,WAAO2G,eACTvjB,OAAO8b,MAAM;AAAA,MACXzL,MAAM;AAAA,MACNxL,MAAM,CAACjD,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,MAC/Btb;AAAAA,MACApF;AAAAA,IAAAA,CACD,GACDoF,UAAUpF,KAAKiB,UACNgZ,OAAO4G,cAChBxjB,OAAO8b,MAAM;AAAA,MACXzL,MAAM;AAAA,MACNxL,MAAM,CAACjD,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,MAC/Btb;AAAAA,MACApF;AAAAA,IACD,CAAA,IACQia,OAAO6G,eAChB1b,UAAUpF,KAAKiB;AAIZ,SAAA;AACT;AAEA,SAASknB,YACP9qB,QACAkf,OACA1Y,QACA;AACA,QAAM5E,QAAQspB,UAAUlrB,OAAOsC,UAAU4c,MAAMra,IAAI;AAE/C,MAAA,CAACjD,SAIDsd,MAAMra,KAAKjB,SAAS,KAAKsb,MAAMra,KAAK,CAAC,MAAM;AACtC,WAAA;AAILqa,MAAAA,MAAMra,KAAKjB,WAAW,GAAG;AACrB,UAAA;AAAA,MAAC6e,OAAAA;AAAAA,MAAO5X,UAAAA;AAAAA,IAAYqU,IAAAA,OACpBsM,iBAAiBjqB,aACrBkhB,QACA;AAAA,MAACjhB,aAAagF;AAAAA,IAAAA,GACd0G,qBAAqBkL,IAAIpY,MAAM,CACjC,GACMyrB,mBAAmB7pB,MAAMyhB,OACzBqI,iBACJ7gB,cAAa,UAAU4gB,mBAAmB,IAAIA,kBAE1CE,uBAAuBjoB,qBAAqB1D,OAAOsC,UAAUkE,MAAM;AAE9D+S,WAAAA,WAAAA,YAAYvZ,QAAQwrB,gBAAgB;AAAA,MAACnnB,IAAI,CAACqnB,cAAa;AAAA,IAAA,CAAE,GAGlEC,wBACA,OAAOzM,MAAMra,KAAK,CAAC,KAAM,YACzBqa,MAAMra,KAAK,CAAC,MAAM,KAElBsU,WAAW6N,YAAYhnB,QAAQ;AAAA,MAC7BqE,IAAI,CAACwG,cAAa,WAAW4gB,mBAAmB,IAAIA,gBAAgB;AAAA,IACrE,CAAA,GAGI;AAAA,EAAA;AAIH,QAAA;AAAA,IAAChJ;AAAAA,IAAO5X;AAAAA,EAAAA,IAAYqU,OAEpB0M,cAAcT,eAAevpB,OAAOsd,MAAMra,IAAI;AAEpD,MAAI,CAAC+mB;AACI,WAAA;AAGHC,QAAAA,mBAAmBtqB,aACvB,CAAC;AAAA,IAAC,GAAGK,MAAM+C;AAAAA,IAAMrC,UAAUmgB;AAAAA,EAAAA,CAA6B,GACxD;AAAA,IAACjhB,aAAagF;AAAAA,EAAAA,GACd0G,qBAAqBkL,IAAIpY,MAAM,CACjC,GACM0rB,gBACJ7gB,aAAa,UAAU+gB,YAAYvI,QAAQ,IAAIuI,YAAYvI,OACvDyI,kBAAkB,CAAClqB,MAAMyhB,OAAOqI,aAAa;AAEnD,SAAIG,oBAAoB/oB,UAAQC,UAAU8oB,iBAAiB,CAAC,CAAC,KAC3D1S,WAAWI,YAAYvZ,QAAQ6rB,iBAAiB,CAAC,EAAEvpB,UAAU;AAAA,IAC3D+B,IAAIynB;AAAAA,EACL,CAAA,GAGI;AACT;AAEA,SAASd,SAAShrB,QAAiCkf,OAAiB;AAClE,MAAI9d,QAAQ8d,MAAM9d;AACd,SAAO8d,MAAMra,KAAK,CAAC,KAAM,aAC3BzD,QAAQ,CAAA,GACRA,MAAM8d,MAAMra,KAAK,CAAC,CAAC,IAAIqa,MAAM9d;AAG/B,QAAMQ,QAAQspB,UAAUlrB,OAAOsC,UAAU4c,MAAMra,IAAI;AAEnD,MAAI,CAACjD;AACI,WAAA;AAGT,QAAM0F,eAActH,OAAOsH,YAAY1F,MAAM+C,IAAI;AAG7C2C,MAAAA,gBAAe4X,MAAMra,KAAKjB,SAAS,KAAKsb,MAAMra,KAAK,CAAC,MAAM;AACrD,WAAA;AAGT,QAAMtC,QAAQ4oB,eAAevpB,OAAOsd,MAAMra,IAAI;AAG9C,MAAIyC,gBAAe/E,OAAO;AACpBsB,QAAAA,KAAKC,OAAOvB,MAAMoC,IAAI;AACpBd,UAAAA,KAAKC,OAAO1C,KAAK,GAAG;AACtB,cAAM2qB,UAAUxpB,MAAMoC,KAAKhC,MACrBqpB,UAAU5qB,MAAMuB;AAClBopB,oBAAYC,YACdhsB,OAAO8b,MAAM;AAAA,UACXzL,MAAM;AAAA,UACNxL,MAAM,CAACjD,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,UAC/Btb,QAAQ;AAAA,UACRpF,MAAMopB;AAAAA,QAAAA,CACP,GACD/rB,OAAO8b,MAAM;AAAA,UACXzL,MAAM;AAAA,UACNxL,MAAM,CAACjD,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,UAC/Btb,QAAQ;AAAA,UACRpF,MAAMqpB;AAAAA,QAAAA,CACP,GAGDhsB,OAAOqe;MAAS,OAEb;AAGL,cAAM4N,WAAW/M,MAAMra,KAAKC,MAAM,CAAC,GAC7BonB,YAAYD,SAAS5nB,GAAG,CAAC;AAO/B,YAJI6nB,cAAcvoB,UAKhB,OAAOuoB,aAAc,YAPD,CAAC,QAAQ,SAAS,MAAM,EAQ9BvT,SAASuT,SAAS;AAEzB,iBAAA;AAGT,cAAMC,UAAUC,SAAS7pB,MAAMoC,MAAM,CACnC;AAAA,UACE,GAAGua;AAAAA,UACHra,MAAMonB;AAAAA,QAAAA,CACP,CACF;AAEU7P,mBAAAA,SAASpc,QAAQmsB,SAAS;AAAA,UAAC9nB,IAAI,CAACzC,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,QAAA,CAAE;AAAA,MAAA;AAAA,SAElE;AAGL,YAAM4I,WAAW/M,MAAMra,KAAKC,MAAM,CAAC,GAC7BunB,gBAAgB,CAAC,QAAQ,SAAS,YAAY,UAAU,GACxDH,YAAYD,SAAS5nB,GAAG,CAAC;AAM/B,UAJI6nB,cAAcvoB,UAId,OAAOuoB,aAAc,YAAYG,cAAc1T,SAASuT,SAAS;AAC5D,eAAA;AAKT,YAAM9qB,SACJ,WAAWmB,MAAMoC,QAAQ,OAAOpC,MAAMoC,KAAKvD,SAAU,WACjDmB,MAAMoC,KAAKvD,QACX,CAAA,GAEAglB,WAAWgG,SAAShrB,QAAO,CAC/B;AAAA,QACE,GAAG8d;AAAAA,QACHra,MAAMqa,MAAMra,KAAKC,MAAM,CAAC;AAAA,MAAA,CACzB,CACF;AAEDqU,iBAAWiD,SACTpc,QACA;AAAA,QAAC,GAAGuC,MAAMoC;AAAAA,QAAMvD,OAAOglB;AAAAA,MAAAA,GACvB;AAAA,QAAC/hB,IAAI,CAACzC,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,MAAA,CAChC;AAAA,IAAA;AAGK,WAAA;AAAA,EAAA,WACEvgB,UAAQC,UAAUnB,MAAM+C,IAAI,KAAKua,MAAMra,KAAKjB,WAAW,GAAG;AAC7D,UAAA;AAAA,MAACtB;AAAAA,MAAU,GAAGgqB;AAAAA,QAAYlrB,OAC1B;AAAA,MAACkB,UAAUiqB;AAAAA,MAAc,GAAGC;AAAAA,IAAAA,IAAY5qB,MAAM+C,QAAQ;AAAA,MAC1DrC,UAAUqB;AAAAA,IACZ;AAGA3D,WAAO8b,MAAM;AAAA,MACXzL,MAAM;AAAA,MACNxL,MAAM,CAACjD,MAAMyhB,KAAK;AAAA,MAClBxG,YAAY;AAAA,QAAC,GAAG2P;AAAAA,MAAQ;AAAA,MACxB1P,eAAewP;AAAAA,IAAAA,CAChB;AAID,UAAMG,YAAY7qB,MAAM+C;AAExB8nB,cAAUnqB,SAAS+R,QAAQ,CAAC9R,QAAOuD,eAAe;AAChD9F,aAAO8b,MAAM;AAAA,QACXzL,MAAM;AAAA,QACNxL,MAAM,CAACjD,MAAMyhB,OAAOoJ,UAAUnqB,SAASsB,SAAS,IAAIkC,UAAU;AAAA,QAC9DnB,MAAMpC;AAAAA,MAAAA,CACP;AAAA,IAAA,CACF,GAEGd,MAAMC,QAAQY,QAAQ,KACxBA,SAAS+R,QAAQ,CAAC9R,QAAOuD,eAAe;AACtC9F,aAAO8b,MAAM;AAAA,QACXzL,MAAM;AAAA,QACNxL,MAAM,CAACjD,MAAMyhB,OAAOvd,UAAU;AAAA,QAC9BnB,MAAMpC;AAAAA,MAAAA,CACP;AAAA,IAAA,CACF;AAAA,EAEL,WAAWX,SAAS,WAAWA,MAAM+C;AAC/Bua,QAAAA,MAAMra,KAAKjB,SAAS,KAAKsb,MAAMra,KAAK,CAAC,MAAM,YAAY;AACzD,YAAM6nB,SAASN,SAASxqB,MAAM+C,KAAKvD,OAAO,CACxC;AAAA,QACE,GAAG8d;AAAAA,QACHra,MAAMqa,MAAMra,KAAKC,MAAM,CAAC;AAAA,MAAA,CACzB,CACF;AAEDqU,iBAAWiD,SACTpc,QACA;AAAA,QAAC,GAAG4B,MAAM+C;AAAAA,QAAMvD,OAAOsrB;AAAAA,MAAAA,GACvB;AAAA,QAACroB,IAAI,CAACzC,MAAMyhB,KAAK;AAAA,MAAA,CACnB;AAAA,IACF;AACS,aAAA;AAIJ,SAAA;AACT;AAEA,SAAS0H,WAAW/qB,QAAiCkf,OAAmB;AAElEA,MAAAA,MAAMra,KAAKjB,WAAW,GAAG;AAC3B,UAAM+oB,oBAAoB3sB,OAAO0E;AACjCyU,eAAWiJ,SAASpiB,MAAM;AAE1B,UAAMsC,WAAW0D,KAAK1D,SAAStC,QAAQ,CAAA,GAAI;AAAA,MACzC8Z,SAAS;AAAA,IAAA,CACV;AAEU,eAAA,CAAC8S,GAAG/nB,IAAI,KAAKvC;AACtB6W,iBAAW6N,YAAYhnB,QAAQ;AAAA,QAACqE,IAAIQ;AAAAA,MAAAA,CAAK;AAGhC0U,WAAAA,WAAAA,YAAYvZ,QAAQA,OAAO6sB,mBAAmB;AAAA,MAACpU,YAAY,CAAA;AAAA,IAAG,CAAA,CAAC,GACtEkU,qBACFxT,WAAWwO,OAAO3nB,QAAQ;AAAA,MACxB6H,QAAQ;AAAA,QAAChD,MAAM,CAAC,GAAG,CAAC;AAAA,QAAGkD,QAAQ;AAAA,MAAC;AAAA,MAChCnD,OAAO;AAAA,QAACC,MAAM,CAAC,GAAG,CAAC;AAAA,QAAGkD,QAAQ;AAAA,MAAA;AAAA,IAAC,CAChC,GAGH/H,OAAOqe,SAAAA,GACA;AAAA,EAAA;AAGT,QAAMzc,QAAQspB,UAAUlrB,OAAOsC,UAAU4c,MAAMra,IAAI;AAEnD,MAAI,CAACjD;AACI,WAAA;AAILsd,MAAAA,MAAMra,KAAKjB,WAAW;AACxBuV,WAAAA,WAAW6N,YAAYhnB,QAAQ;AAAA,MAACqE,IAAI,CAACzC,MAAMyhB,KAAK;AAAA,IAAE,CAAA,GAE3C;AAGT,QAAM9gB,QAAQ4oB,eAAevpB,OAAOsd,MAAMra,IAAI;AAG9C,MAAI7E,OAAOsH,YAAY1F,MAAM+C,IAAI,KAAKpC,SAChC2c,MAAMra,KAAK,CAAC,MAAM,cAAcqa,MAAMra,KAAKjB,WAAW;AACxDuV,WAAAA,WAAW6N,YAAYhnB,QAAQ;AAAA,MAACqE,IAAI,CAACzC,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,IAAE,CAAA,GAExD;AAIX,MAAI9gB,SAAS,CAACsB,KAAKC,OAAOvB,MAAMoC,IAAI,GAAG;AAIrC,UAAMunB,YADWhN,MAAMra,KAAKC,MAAM,CAAC,EACRT,GAAG,CAAC;AAO/B,QAJI6nB,cAAcvoB,UAId,OAAOuoB,aAAc,YANH,CAAC,QAAQ,SAAS,YAAY,UAAU,EAMXvT,SAASuT,SAAS;AAI5D,aAAA;AAGT,UAAM9qB,QACJ,WAAWmB,MAAMoC,QAAQ,OAAOpC,MAAMoC,KAAKvD,SAAU,WACjDmB,MAAMoC,KAAKvD,QACX,CAAA,GAEAglB,WAAWgG,SAAShrB,OAAO,CAC/B;AAAA,MACE,GAAG8d;AAAAA,MACHra,MAAMqa,MAAMra,KAAKC,MAAM,CAAC;AAAA,IAAA,CACzB,CACF;AAEDqU,WAAAA,WAAWiD,SACTpc,QACA;AAAA,MAAC,GAAGuC,MAAMoC;AAAAA,MAAMvD,OAAOglB;AAAAA,IAAAA,GACvB;AAAA,MAAC/hB,IAAI,CAACzC,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,IAChC,CAAA,GAEO;AAAA,EAAA;AAGT,MAAI9gB,SAASsB,KAAKC,OAAOvB,MAAMoC,IAAI,GAAG;AACpC,UAAMsnB,WAAW/M,MAAMra,KAAKC,MAAM,CAAC,GAC7BonB,YAAYD,SAAS5nB,GAAG,CAAC;AAO/B,QAJI6nB,cAAcvoB,UAId,OAAOuoB,aAAc,YANH,CAAC,QAAQ,OAAO,EAMavT,SAASuT,SAAS;AAC5D,aAAA;AAGL,QAAA,OAAOA,aAAc,YAAYA,cAAc;AACjDlsB,aAAAA,OAAO8b,MAAM;AAAA,QACXzL,MAAM;AAAA,QACNxL,MAAM,CAACjD,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,QAC/Btb,QAAQ;AAAA,QACRpF,MAAMJ,MAAMoC,KAAKhC;AAAAA,MAClB,CAAA,GAEM;AAGT,UAAMwpB,UAAUC,SAAS7pB,MAAMoC,MAAM,CACnC;AAAA,MACE,GAAGua;AAAAA,MACHra,MAAMonB;AAAAA,IAAAA,CACP,CACF,GACKa,UAAU3Y,OAAO4Y,KAAKZ,OAAO,GAE7Ba,oBAAoB7Y,OAAO4Y,KAAKxqB,MAAMoC,IAAI,EAAE2S,OAC/C2V,CAAAA,aAAa,CAACH,QAAQnU,SAASsU,QAAQ,CAC1C;AAEWC,WAAAA,WAAAA,WAAWltB,QAAQgtB,mBAAmB;AAAA,MAC/C3oB,IAAI,CAACzC,MAAMyhB,OAAO9gB,MAAM8gB,KAAK;AAAA,IAC9B,CAAA,GAEM;AAAA,EAAA;AAGT,MAAI,CAAC9gB,OAAO;AACN,QAAA,WAAWX,MAAM+C,MAAM;AACzB,YAAM+nB,SAASN,SAASxqB,MAAM+C,KAAKvD,OAAO,CACxC;AAAA,QACE,GAAG8d;AAAAA,QACHra,MAAMqa,MAAMra,KAAKC,MAAM,CAAC;AAAA,MAAA,CACzB,CACF;AAEDqU,aAAAA,WAAWiD,SACTpc,QACA;AAAA,QAAC,GAAG4B,MAAM+C;AAAAA,QAAMvD,OAAOsrB;AAAAA,MAAAA,GACvB;AAAA,QAACroB,IAAI,CAACzC,MAAMyhB,KAAK;AAAA,MACnB,CAAA,GAEO;AAAA,IAAA;AAGF,WAAA;AAAA,EAAA;AAGF,SAAA;AACT;AAEA,SAAS6H,UACP5oB,UACAuC,MAC+C;AAC/C,MAAIL,aAAa;AAEjB,QAAM5C,QAAQU,SAASoK,KAAK,CAAC/H,MAAkB0e,UAAkB;AAC/D,UAAM8J,UAAUC,eAAevoB,KAAK,CAAC,CAAC,IAClCF,KAAKtD,SAASwD,KAAK,CAAC,EAAExD,OACtBgiB,UAAUxe,KAAK,CAAC;AAEhBsoB,WAAAA,YACF3oB,aAAa6e,QAGR8J;AAAAA,EAAAA,CACR;AAEIvrB,MAAAA;AAIE,WAAA;AAAA,MAAC+C,MAAM/C;AAAAA,MAAOyhB,OAAO7e;AAAAA,IAAU;AACxC;AAEA,SAAS2mB,eACPvpB,OACAiD,MAC+C;AAC/C,QAAM4nB,YAAY7qB,MAAM+C;AAExB,MAAI,CAAC7B,UAAQC,UAAU0pB,SAAS,KAAK5nB,KAAK,CAAC,MAAM;AAC/C;AAGF,MAAIiB,aAAa;AAEjB,QAAMvD,QAAQkqB,UAAUnqB,SAASoK,KAAK,CAAC/H,MAAM0e,UAAkB;AAC7D,UAAM8J,UAAUC,eAAevoB,KAAK,CAAC,CAAC,IAClCF,KAAKtD,SAASwD,KAAK,CAAC,EAAExD,OACtBgiB,UAAUxe,KAAK,CAAC;AAEhBsoB,WAAAA,YACFrnB,aAAaud,QAGR8J;AAAAA,EAAAA,CACR;AAEI5qB,MAAAA;AAIE,WAAA;AAAA,MACLoC,MAAMpC;AAAAA,MACN8gB,OAAOvd;AAAAA,IACT;AACF;AC7hBO,SAASunB,gBACd7mB,QACAlE,UACA2J,WACAqhB,aACc;AACd,QAAM1rB,QACJ0F,YAAY;AAAA,IAACd;AAAAA,EAASlE,GAAAA,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,CAAC,KACjDvC,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAC5B,MAAI,CAACjD;AACG,UAAA,IAAIuB,MAAM,sBAAsB;AAExC,QAAMoqB,YACJjmB,YAAY;AAAA,IAACd;AAAAA,EAAAA,GAAS5E,KAAK,KAC3B4rB,OAAO;AAAA,IAAChnB;AAAAA,EAAS5E,GAAAA,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,CAAC,KACjDjD,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACnC,MAAI,CAAC0oB;AACG,UAAA,IAAIpqB,MAAM,sBAAsB;AAExC,QAAM0B,OAAa,CACjB;AAAA,IAACxD,MAAMO,MAAMP;AAAAA,KACb,YACA;AAAA,IAACA,MAAMksB,UAAUlsB;AAAAA,EAAAA,GACjB,MAAM,GAEFosB,YAAYH,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC,GACzC6oB,YACJpmB,YAAY;AAAA,IAACd;AAAAA,EAAAA,GAASinB,SAAS,KAAKA,UAAUnrB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,GACpE8oB,WAAWH,OAAO;AAAA,IAAChnB;AAAAA,EAAM,GAAGknB,SAAS,IAAIA,UAAU/qB,OAAO,IAC1Duc,QAAQ+L,iBAAe0C,UAAUJ,UAAU5qB,MAAMkC,IAAI;AAC3D,SAAOqa,MAAM9d,MAAMwC,SAAS,CAACsb,KAAK,IAAI,CAAE;AAC1C;AAEO,SAAS0O,gBACdpnB,QACAlE,UACA2J,WACAqhB,aACc;AACd,QAAM1rB,QAAQU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACxC,MAAI,CAACjD;AACG,UAAA,IAAIuB,MAAM,sBAAsB;AAExC,QAAMZ,QACH+E,YAAY;AAAA,IAACd;AAAAA,EAAS5E,GAAAA,KAAK,KAAKA,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,KACjElB,QACI4pB,YAA0CC,OAAO;AAAA,IAAChnB;AAAAA,EAAAA,GAASjE,KAAK,IAClEA,QACAoB;AACJ,MAAIpB,SAAS,CAACgrB;AACN,UAAA,IAAIpqB,MAAM,eAAe;AAEjC,MAAI,CAACoqB;AACG,UAAA,IAAIpqB,MAAM,sBAAsB;AAExC,QAAM0B,OAAa,CACjB;AAAA,IAACxD,MAAMO,MAAMP;AAAAA,KACb,YACA;AAAA,IAACA,MAAMksB,UAAUlsB;AAAAA,EAAAA,GACjB,MAAM,GAEFwsB,cAAcP,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC,GAC3CipB,gBACJxmB,YAAY;AAAA,IAACd;AAAAA,EAAAA,GAASqnB,WAAW,KACjCA,YAAYvrB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,GAClC8oB,WAAWH,OAAO;AAAA,IAAChnB;AAAAA,EAAM,GAAGsnB,aAAa,KAAKA,cAAcnrB,MAC5Duc,QAAQ+L,iBAAe0C,YAAY,IAAIJ,UAAU5qB,MAAMkC,IAAI;AACjE,SAAOqa,MAAM9d,QAAQ,CAAC8d,KAAK,IAAI,CAAE;AACnC;AAEgB6O,SAAAA,aACdvnB,QACAlE,UACA2J,WACc;AACVA,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AAC/B,UAAMhC,QAAQU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACpC,QAAA,OAAOjD,MAAMP,QAAS;AAClB,YAAA,IAAI8B,MAAM,+BAA+B;AAEjD,UAAM6qB,UAAUC,OACd;AAAA,MAAC,GAAG3rB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAAA,MAAG,GAAGoH,UAAU6Q;AAAAA,OAC9CoR,WACF;AACA,WAAO,CACL1T,IAAIvX,eAAe,CAAC+qB,OAAO,GAAGxnB,OAAO5E,MAAMhB,IAAI,EAAE,CAAC,GAAG,CACnD;AAAA,MAACS,MAAMO,MAAMP;AAAAA,IAAK,CAAA,CACnB,CAAC;AAAA,EAEK4K,WAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AACtC,UAAMhC,QAAQU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACxC,QAAIyC,YAAY;AAAA,MAACd;AAAAA,IAAM,GAAG5E,KAAK,GAAG;AAChC,YAAMW,QAAQX,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAC9C,UAAItC,OAAO;AACT,cAAMiK,WAAW5K,MAAMP,MACjBoL,WAAWlK,MAAMlB,MACjB8e,UAAmB,CAAA,GACnB4M,OAAO5Y,OAAO4Y,KAAK9gB,UAAU6Q,aAAa;AAChDiQ,eAAAA,KAAK1Y,QAAS8Z,CAAY,YAAA;AAExB,cAAIpB,KAAKnpB,WAAW,KAAKuqB,YAAY,QAAQ;AAC3C,kBAAMC,MAAMhW,IAAInM,UAAU6Q,eAAeqR,OAAO;AACxCjmB,oBAAAA,KACNsS,IAAI4T,KAAK,CACP;AAAA,cAAC/sB,MAAMmL;AAAAA,YAAAA,GACP,YACA5K,MAAMU,SAAS+rB,QAAQ9rB,KAAK,GAC5B4rB,OAAO,CACR,CACH;AAAA,UAAA,OACK;AACL,kBAAMC,MAAMhW,IAAInM,UAAU6Q,eAAeqR,OAAO;AACxCjmB,oBAAAA,KACNsS,IAAI4T,KAAK,CACP;AAAA,cAAC/sB,MAAMmL;AAAAA,eACP,YACA;AAAA,cAACnL,MAAMoL;AAAAA,YAAAA,GACP0hB,OAAO,CACR,CACH;AAAA,UAAA;AAAA,QAEH,CAAA,GACMhO;AAAAA,MAAAA;AAEH,YAAA,IAAIhd,MAAM,8BAA8B;AAAA,IAAA;AAE1C,UAAA,IAAIA,MAAM,8BAA8B;AAAA,EAChD;AACQ,UAAA,IAAIA,MACR,gCAAgC0S,KAAKC,UAAU7J,UAAUpH,IAAI,CAAC,EAChE;AAEJ;AAEO,SAASypB,gBACd9nB,QACAlE,UACA2J,WACAqhB,aACc;AACd,QAAM1rB,QAAQ0rB,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC;AACvCoH,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AACzBiH,UAAAA,WAAWoB,UAAUpH,KAAK,CAAC,MAAM,IAAI,WAAW,SAChDgpB,cAAcP,YAAYrhB,UAAUpH,KAAK,CAAC,IAAI,CAAC,GAC/C0pB,YAAYtiB,UAAUpH,KAAK,CAAC,MAAM,IAAIjD,OAAOP,OAAOwsB,aAAaxsB;AACvE,WAAIktB,YACK,CACLC,OACE,CACEvrB,eACE,CAACgJ,UAAUtH,IAAI,GACf6B,OAAO5E,MAAMhB,IACf,EAAE,CAAC,CAAC,GAENiK,UACA,CAAC;AAAA,MAACxJ,MAAMktB;AAAAA,IAAU,CAAA,CACpB,CAAC,IAGE,CACLE,aAAanB,aAAa,CAAA,CAAE,GAC5BkB,OACE,CAACvrB,eAAe,CAACgJ,UAAUtH,IAAI,GAAiB6B,OAAO5E,MAAMhB,IAAI,EAAE,CAAC,CAAC,GACrE,UACA,CAACqL,UAAUpH,KAAK,CAAC,CAAC,CACpB,CAAC;AAAA,aAGHyC,YAAY;AAAA,IAACd;AAAAA,EAAS5E,GAAAA,KAAK,KAC3BqK,UAAUpH,KAAKjB,WAAW,KAC1BtB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,GAC1B;AACA,UAAMgG,WACJjJ,MAAMU,SAASsB,WAAW,KAAK,CAAChC,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,IAChE,WACA,SACAF,OAAO;AAAA,MAAC,GAAGsH,UAAUtH;AAAAA,IAAI;AAC3B,KAACA,KAAK9C,SAASgC,KAAKC,OAAOa,IAAI,MACjCA,KAAK9C,QAAQ,QACb8C,KAAK/B,QAAQ,CAAA;AAYTL,UAAAA,QAVMU,eACV,CACE;AAAA,MACE5B,MAAM;AAAA,MACNQ,OAAO2E,OAAO5E,MAAMhB;AAAAA,MACpB0B,UAAU,CAACqC,IAAI;AAAA,IAAA,CAChB,GAEH6B,OAAO5E,MAAMhB,IACf,EAAE,CAAC,EACe0B,SAAS,CAAC;AAC5B,WAAO,CACLksB,OAAO,CAACjsB,KAAK,GAAGsI,UAAU,CACxB;AAAA,MAACxJ,MAAMO,MAAMP;AAAAA,IACb,GAAA,YACAO,MAAMU,SAASsB,UAAU,KAAK,CAAChC,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,IAC/D,IACA;AAAA,MAACxD,MAAMO,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,EAAExD;AAAAA,IAAK,CAAA,CACvD,CAAC;AAAA,EAAA;AAGN,SAAO,CAAE;AACX;AAEO,SAASqtB,eACdloB,QACAlE,UACA2J,WACAqhB,aACc;AACRnN,QAAAA,UAAmB,CAAA,GACnBwO,aAAarsB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAC7C,MAAI,CAACyC,YAAY;AAAA,IAACd;AAAAA,KAASmoB,UAAU;AAC7B,UAAA,IAAIxrB,MACR,mBAAmB0S,KAAKC,UACtB7J,UAAUpH,KAAK,CAAC,CAClB,CAAC,yCACH;AAEEoH,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AAC/B,UAAMgrB,WAAWtB,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC;AAC9C,QAAIyC,YAAY;AAAA,MAACd;AAAAA,IAAM,GAAGooB,QAAQ,GAAG;AACnC,YAAMC,cAAc5rB,eAClB,CAACX,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,CAAC,GAChC2B,OAAO5E,MAAMhB,IACf,EAAE,CAAC;AACCiuB,sBACF1O,QAAQjY,KAAKsmB,OAAO,CAACK,WAAW,GAAG,SAAS,CAAC;AAAA,QAACxtB,MAAMstB,WAAWttB;AAAAA,MAAAA,CAAK,CAAC,CAAC,GACjDutB,SAAStsB,SAASwC,MAAMmH,UAAUpB,QAAQ,EAClDwJ,QAAS6C,CAAS,SAAA;AAC7B,cAAMrS,OAAO,CAAC;AAAA,UAACxD,MAAMutB,SAASvtB;AAAAA,WAAO,YAAY;AAAA,UAACA,MAAM6V,KAAK7V;AAAAA,QAAAA,CAAK;AAC1D6G,gBAAAA,KAAK4mB,MAAMjqB,IAAI,CAAC;AAAA,MAAA,CACzB;AAAA,IAAA;AAGEsb,WAAAA;AAAAA,EAAAA;AAELlU,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AAC/B,UAAMmrB,YAAYJ,WAAWrsB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACvD,QAAI2oB,OAAO;AAAA,MAAChnB;AAAAA,IAAM,GAAGuoB,SAAS,GAAG;AACzBC,YAAAA,cACJ/rB,eACE,CACE;AAAA,QACE,GAAG0rB;AAAAA,QACHrsB,UAAUqsB,WAAWrsB,SAASwC,MAC5BmH,UAAUpH,KAAK,CAAC,IAAI,GACpBoH,UAAUpH,KAAK,CAAC,IAAI,CACtB;AAAA,MAAA,CACD,GAEH2B,OAAO5E,MAAMhB,IACf,EAAE,CAAC,EACH0B;AAEF6d,cAAQjY,KACNsmB,OAAOQ,aAAa,SAAS,CAC3B;AAAA,QAAC3tB,MAAMstB,WAAWttB;AAAAA,SAClB,YACA;AAAA,QAACA,MAAM0tB,UAAU1tB;AAAAA,MAAAA,CAAK,CACvB,CACH,GACA8e,QAAQjY,KACNsS,IAAIuU,UAAUpsB,MAAM,CAClB;AAAA,QAACtB,MAAMstB,WAAWttB;AAAAA,SAClB,YACA;AAAA,QAACA,MAAM0tB,UAAU1tB;AAAAA,MAAAA,GACjB,MAAM,CACP,CACH;AAAA,IAAA;AAEK8e,WAAAA;AAAAA,EAAAA;AAEFA,SAAAA;AACT;AAEgB8O,SAAAA,gBACdzoB,QACA8mB,aACArhB,WACc;AACd,QAAMrK,QAAQ0rB,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC;AACvCoH,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AAE/B,QAAIhC,SAASA,MAAMP;AACV,aAAA,CAACytB,MAAM,CAAC;AAAA,QAACztB,MAAMO,MAAMP;AAAAA,MAAK,CAAA,CAAC,CAAC;AAE/B,UAAA,IAAI8B,MAAM,iBAAiB;AAAA,aACxBmE,YAAY;AAAA,IAACd;AAAAA,KAAS5E,KAAK,KAAKqK,UAAUpH,KAAKjB,WAAW,GAAG;AACtE,UAAMsrB,eAAettB,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAErD,WAAIqqB,eACuBttB,MAAMU,SAASgV,OACrCJ,CAASA,SAAAA,KAAK7V,SAAS4K,UAAUtH,KAAKtD,IACzC,EAEqBuC,SAAS,KAC5ByH,QAAQC,KACN,gCAAgCW,UAAUtH,KAAKtD,IAAI,yCACnDwU,KAAKC,UAAUlU,OAAO,MAAM,CAAC,CAC/B,GACO,CAAA,KAGF,CACLktB,MAAM,CAAC;AAAA,MAACztB,MAAMO,MAAMP;AAAAA,OAAO,YAAY;AAAA,MAACA,MAAM6tB,aAAa7tB;AAAAA,IAAAA,CAAK,CAAC,CAAC,IAG/D,CAAE;AAAA,EACX;AACE,WAAO,CAAE;AAEb;AAEO,SAAS8tB,eACd3oB,QACAlE,UACA2J,WACAqhB,aACc;AACd,QAAMnN,UAAmB,CAEnBve,GAAAA,QAAQ0rB,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC,GACrCogB,eAAe3iB,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AAE3CoH,MAAAA,UAAUpH,KAAKjB,WAAW;AAC5B,QAAIhC,OAAOP,MAAM;AACf,YAAM+tB,WAAWnsB,eACf,CAACX,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,CAAC,GAChC2B,OAAO5E,MAAMhB,IACf,EAAE,CAAC;AACKsH,cAAAA,KAAKsS,IAAI4U,UAAU,CAAC;AAAA,QAAC/tB,MAAM+tB,SAAS/tB;AAAAA,MAAK,CAAA,CAAC,CAAC,GACnD8e,QAAQjY,KAAK4mB,MAAM,CAAC;AAAA,QAACztB,MAAMO,MAAMP;AAAAA,MAAK,CAAA,CAAC,CAAC;AAAA,IAC1C;AACQ,YAAA,IAAI8B,MAAM,uBAAuB;AAAA,WAGzCmE,YAAY;AAAA,IAACd;AAAAA,EAAAA,GAAS5E,KAAK,KAC3B0F,YAAY;AAAA,IAACd;AAAAA,KAASye,YAAY,KAClChZ,UAAUpH,KAAKjB,WAAW,GAC1B;AACMyrB,UAAAA,cACJpK,aAAa3iB,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,KAC3C2oB,OAAO;AAAA,MAAChnB;AAAAA,IAAM,GAAGye,aAAa3iB,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,CAAC,IACzDogB,aAAa3iB,SAAS2J,UAAUpH,KAAK,CAAC,IAAI,CAAC,IAC3ClB,QACA2rB,cACJ1tB,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,KAChC2oB,OAAO;AAAA,MAAChnB;AAAAA,IAAS5E,GAAAA,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,CAAC,IAC9CjD,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,IAChClB;AAEF0rB,oBACuBztB,MAAMU,SAASgV,OACrCJ,CAAAA,SAASA,KAAK7V,SAASguB,YAAYhuB,IACtC,EAEqBuC,WAAW,IAC9Buc,QAAQjY,KACNsS,IAAI6U,YAAY1sB,MAAM,CACpB;AAAA,MAACtB,MAAMO,MAAMP;AAAAA,OACb,YACA;AAAA,MAACA,MAAMguB,YAAYhuB;AAAAA,IAAAA,GACnB,MAAM,CACP,CACH,IAEAgK,QAAQC,KACN,gCAAgC+jB,YAAYhuB,IAAI,yCAChDwU,KAAKC,UAAUlU,OAAO,MAAM,CAAC,CAC/B,IAIA0tB,gBACuB1tB,MAAMU,SAASgV,OACrCJ,UAASA,KAAK7V,SAASiuB,YAAYjuB,IACtC,EAEqBuC,WAAW,IAC9Buc,QAAQjY,KACN4mB,MAAM,CAAC;AAAA,MAACztB,MAAMO,MAAMP;AAAAA,OAAO,YAAY;AAAA,MAACA,MAAMiuB,YAAYjuB;AAAAA,IAAAA,CAAK,CAAC,CAClE,IAEAgK,QAAQC,KACN,gCAAgCgkB,YAAYjuB,IAAI,yCAChDwU,KAAKC,UAAUlU,OAAO,MAAM,CAAC,CAC/B;AAAA,EAAA;AAICue,SAAAA;AACT;AAEgBoP,SAAAA,cACd/oB,QACA8mB,aACArhB,WACc;AACd,QAAMkU,UAAmB,CACnBve,GAAAA,QAAQ0rB,YAAYrhB,UAAUpH,KAAK,CAAC,CAAC,GACrCyZ,cAAcgP,YAAYrhB,UAAUK,QAAQ,CAAC,CAAC;AAEpD,MAAI,CAACgS;AACI6B,WAAAA;AAGLlU,MAAAA,UAAUpH,KAAKjB,WAAW,GAAG;AACzBiH,UAAAA,WACJoB,UAAUpH,KAAK,CAAC,IAAIoH,UAAUK,QAAQ,CAAC,IAAI,WAAW;AAChDpE,YAAAA,KAAK4mB,MAAM,CAAC;AAAA,MAACztB,MAAMO,MAAMP;AAAAA,IAAAA,CAAK,CAAC,CAAC,GACxC8e,QAAQjY,KACNsmB,OAAO,CAACvrB,eAAe,CAACrB,KAAK,GAAG4E,OAAO5E,MAAMhB,IAAI,EAAE,CAAC,CAAC,GAAGiK,UAAU,CAChE;AAAA,MAACxJ,MAAMid,YAAYjd;AAAAA,IAAK,CAAA,CACzB,CACH;AAAA,EAEA4K,WAAAA,UAAUpH,KAAKjB,WAAW,KAC1B0D,YAAY;AAAA,IAACd;AAAAA,EAAAA,GAAS5E,KAAK,KAC3B0F,YAAY;AAAA,IAACd;AAAAA,EAAM,GAAG8X,WAAW,GACjC;AACA,UAAM/b,QAAQX,MAAMU,SAAS2J,UAAUpH,KAAK,CAAC,CAAC,GACxC+mB,cAActN,YAAYhc,SAAS2J,UAAUK,QAAQ,CAAC,CAAC,GACvDzB,WACJoB,UAAUK,QAAQ,CAAC,MAAMgS,YAAYhc,SAASsB,SAAS,UAAU,UAC7D4rB,gBACJvsB,eAAe,CAACrB,KAAK,GAAG4E,OAAO5E,MAAMhB,IAAI,EAAE,CAAC,EAC5C0B,SAAS2J,UAAUpH,KAAK,CAAC,CAAC;AACpBqD,YAAAA,KAAK4mB,MAAM,CAAC;AAAA,MAACztB,MAAMO,MAAMP;AAAAA,OAAO,YAAY;AAAA,MAACA,MAAMkB,MAAMlB;AAAAA,IAAAA,CAAK,CAAC,CAAC,GACxE8e,QAAQjY,KACNsmB,OAAO,CAACgB,aAAa,GAAG3kB,UAAU,CAChC;AAAA,MAACxJ,MAAMid,YAAYjd;AAAAA,OACnB,YACA;AAAA,MAACA,MAAMuqB,YAAYvqB;AAAAA,IAAK,CAAA,CACzB,CACH;AAAA,EAAA;AAEK8e,SAAAA;AACT;AChdasP,MAAAA,+BAAqDxiB,QAAQ;AAE1DyiB,SAAAA,gBAAgB1vB,QAAgBqa,IAAsB;AAC9DC,QAAAA,OAAOqV,WAAW3vB,MAAM;AACrBwa,WAAAA,IAAIxa,QAAQ,EAAK,GAC1Bqa,GACAoV,GAAAA,SAASjV,IAAIxa,QAAQsa,IAAI;AAC3B;AAEO,SAASqV,WAAW3vB,QAAqC;AACvDyvB,SAAAA,SAASrX,IAAIpY,MAAM;AAC5B;ACkBA,MAAMU,UAAQC,cAAc,oBAAoB;AASzC,SAASivB,kBAAkB;AAAA,EAChCxnB;AAAAA,EACAynB;AAAAA,EACA5P;AACO,GAAiE;AAGpE6P,MAAAA;AAEJ,QAAMC,aAAanF,iBAAiBxiB,YAAYG,YAAY,EAAEM,QAAQrC,MAAM;AAE5E,SAAO,SAAqBxG,QAAiC;AAC3DgN,iCAA6BwN,IAAIxa,QAAQ,EAAK,GAC9CyvB,SAASjV,IAAIxa,QAAQ,EAAI,GACzB8vB,mBAAmB,CAAC,GAAG9vB,OAAOsC,QAAQ;AAEhC,UAAA;AAAA,MAACwZ,OAAAA;AAAAA,IAAAA,IAAS9b;AAChB,QAAIgwB,kBAA2B,CAAE;AAEjC,UAAMC,8BAA8BA,MAAM;AACxC,UAAID,gBAAgBpsB,WAAW;AAC7B;AAEF,YAAMuc,UAAU6P;AAChBA,wBAAkB,CAAE;AACpB,UAAInF,UAAU;AAEdzQ,wBAAkBpa,QAAQ,MAAM;AACvBoe,eAAAA,mBAAmBpe,QAAQ,MAAM;AACtC0vB,0BAAgB1vB,QAAQ,MAAM;AAC5BkiB,0BAAcliB,QAAQ,MAAM;AAC1B,yBAAWkf,SAASiB,SAAS;AACvBzf,wBAAMI,WACRJ,QAAM,yBAAyBmV,KAAKC,UAAUoJ,KAAK,CAAC,EAAE;AAEpD,oBAAA;AACQ6Q,4BAAAA,WAAW/vB,QAAQkf,KAAK;AAAA,yBAC3BpN,OAAO;AACNA,0BAAAA,MACN,kBAAkB+D,KAAKC,UAAUoJ,KAAK,CAAC,mBAAmBpN,MAAMsX,OAAO,EACzE;AAAA,gBAAA;AAAA,cACF;AAAA,YACF,CACD;AAAA,UAAA,CACF;AAAA,QAAA,CACF,GACGyB,YACF7qB,OAAOkwB,UAAU,GACjBlwB,OAAOqe;MAAS,CAEnB;AAAA,IACH,GAEM8R,gBAAgBA,CAAC;AAAA,MAAChQ;AAAAA,IAAAA,MAAiC;AACvD,YAAMJ,gBAAgBI,QAAQ7I,OAAQ8Y,CAAMA,MAAAA,EAAE/P,WAAW,OAAO;AAC5DN,oBAAcnc,WAAW,MAG7BosB,kBAAkBA,gBAAgBjkB,OAAOgU,aAAa,GACtDkQ;IACF;AAEAhQ,WAAAA,cAAc/X,KAAK,MAAM;AACvBxH,cAAM,+BAA+B;AACrC,YAAMwf,MAAM9X,YAAYlI,GAAG,WAAWiwB,aAAa;AACnD,aAAO,MAAM;AACLzvB,gBAAA,iCAAiC,GACvCwf,IAAI5f,YAAY;AAAA,MAClB;AAAA,IACD,CAAA,GAEDN,OAAO8b,QAAS7P,CAAwC,cAAA;AACtD,UAAIkU,UAAmB,CAAE;AAGzB2P,yBAAmB9vB,OAAOsC;AAE1B,YAAM+tB,iBAAiB3sB,qBACrBosB,kBACA1nB,YAAYG,YAAY,EAAEM,QAAQrC,MACpC;AAGAsV,MAAAA,OAAM7P,SAAS;AAETqkB,YAAAA,gBAAgB5sB,qBACpB1D,OAAOsC,UACP8F,YAAYG,YAAY,EAAEM,QAAQrC,MACpC;AAEI,UAAA,CAACmpB,WAAW3vB,MAAM;AAChBuwB,eAKGvwB;AAYT,cAPEqwB,kBACA,CAACC,iBACDrkB,UAAUoE,SAAS,mBAEnB8P,QAAQjY,KAAKsmB,OAAOsB,kBAAkB,UAAU,CAAC,CAAC,CAAC,CAAC,GAG9C7jB,UAAUoE,MAAI;AAAA,QACpB,KAAK;AACH8P,oBAAU,CACR,GAAGA,SACH,GAAGkN,gBACDjlB,YAAYG,YAAAA,EAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,WACA6jB,gBACF,CAAC;AAEH;AAAA,QACF,KAAK;AACH3P,oBAAU,CACR,GAAGA,SACH,GAAGyN,gBACDxlB,YAAYG,YAAAA,EAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,WACA6jB,gBACF,CAAC;AAEH;AAAA,QACF,KAAK;AACH3P,oBAAU,CACR,GAAGA,SACH,GAAG8O,gBACD7mB,YAAYG,YAAY,EAAEM,QAAQrC,QAClCspB,kBACA7jB,SACF,CAAC;AAEH;AAAA,QACF,KAAK;AACHkU,oBAAU,CACR,GAAGA,SACH,GAAGuO,eACDtmB,YAAYG,YAAAA,EAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,WACA6jB,gBACF,CAAC;AAEH;AAAA,QACF,KAAK;AACH3P,oBAAU,CACR,GAAGA,SACH,GAAGmO,gBACDlmB,YAAYG,YAAAA,EAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,WACA6jB,gBACF,CAAC;AAEH;AAAA,QACF,KAAK;AACH3P,oBAAU,CACR,GAAGA,SACH,GAAG4N,aACD3lB,YAAYG,cAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,SACF,CAAC;AAEH;AAAA,QACF,KAAK;AACHkU,oBAAU,CACR,GAAGA,SACH,GAAGgP,eACD/mB,YAAYG,YAAAA,EAAcM,QAAQrC,QAClCxG,OAAOsC,UACP2J,WACA6jB,gBACF,CAAC;AAEH;AAAA,QACF,KAAK;AACH3P,oBAAU,CACR,GAAGA,SACH,GAAGoP,cACDnnB,YAAYG,YAAY,EAAEM,QAAQrC,QAClCspB,kBACA7jB,SACF,CAAC;AAEH;AAAA,MACF;AAMA,UAAA,CAACokB,kBACDC,iBACA,CAAC,cAAc,YAAY,eAAe,aAAa,EAAE3X,SACvD1M,UAAUoE,IACZ,MAEA8P,UAAU,CAAC,GAAGA,SAAS2O,MAAM,EAAE,CAAC,GAChCe,WAAW9e,KAAK;AAAA,QACdV,MAAM;AAAA,QACNmgB,eAAevtB,eACb6sB,kBACA1nB,YAAYG,YAAY,EAAEM,QAAQrC,OAAO5E,MAAMhB,MAC/CuM,qBAAqBiL,IAAIpY,MAAM,CACjC;AAAA,MAAA,CACD,IAICqwB,kBAAkBlQ,QAAQvc,SAAS,MACrCuc,UAAU,CAACsO,aAAa,CAAA,GAAI,CAAA,CAAE,GAAG,GAAGtO,OAAO,IAIzCA,QAAQvc,SAAS;AACnB,mBAAWsb,SAASiB;AAClB/X,sBAAY2I,KAAK;AAAA,YACfV,MAAM;AAAA,YACN6O,OAAO;AAAA,cAAC,GAAGA;AAAAA,cAAOmB,QAAQ;AAAA,YAAO;AAAA,YACjCoQ,aAAalH,sBAAsBvpB,MAAM;AAAA,YACzCoB,OAAO6B,eACLjD,OAAOsC,UACP8F,YAAYG,YAAY,EAAEM,QAAQrC,OAAO5E,MAAMhB,MAC/CuM,qBAAqBiL,IAAIpY,MAAM,CACjC;AAAA,UAAA,CACD;AAGEA,aAAAA;AAAAA,IAAAA,GAEFA;AAAAA,EACT;AACF;ACjRA,MAAMU,UAAQC,cAAc,6BAA6B;AAMlD,SAAS+vB,2BACdtoB,aAC8D;AAC9D,SAAO,SACLpI,QACyB;AACnB,UAAA;AAAA,MAAC8b,OAAAA;AAAAA,IAAAA,IAAS9b;AAEhBA,WAAAA,OAAO8b,QAASc,CAAO,OAAA;AACjBxU,UAAAA,YAAYG,YAAY,EAAEC,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY,GAAG;AACjEsT,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAOErC,UAAAA,mBAAmBva,MAAM,GAAG;AAC9B8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAOF,UAAIhC,UAAU5a,MAAM,KAAK+a,UAAU/a,MAAM,GAAG;AAC1C8b,QAAAA,OAAMc,EAAE;AACR;AAAA,MAAA;AAGEA,UAAAA,GAAGvM,SAAS,eAAe;AAC7B,cAAM1L,OAAOiY,GAAGjY;AACZiY,YAAAA,GAAG/X,KAAK,CAAC,MAAM,KAAKV,OAAOyH,OAAO5L,QAAQ2E,IAAI,GAAG;AAEnD,gBAAMsjB,WAAWlO,KAAKwO,KAAK3L,GAAG/X,IAAI;AAE7B7E,iBAAOsC,SAAS2lB,SAAS,CAAC,CAAC,MAC9BvnB,QAAM,0BAA0B,GAChCyD,OAAOwsB,WACL3wB,QACAA,OAAO6sB,mBAAmB;AAAA,YAACpU,YAAY,CAAA;AAAA,UAAG,CAAA,CAC5C;AAAA,QAAA;AAAA,MAEJ;AAEFqD,MAAAA,OAAMc,EAAE;AAAA,IAAA,GAEH5c;AAAAA,EACT;AACF;AC5DA,MAAMU,UAAQC,cAAc,mCAAmC;AAExD,SAASiwB,iCACdxoB,aAC8D;AACxDyoB,QAAAA,eAAezoB,YAAYG,YAAY,EAAEM,QAAQrC,OAAOxD,OAAO,CAAC,EAAEpC;AACxE,SAAO,SACLZ,QACyB;AAGnB,UAAA;AAAA,MAAC+b;AAAAA,IAAAA,IAAiB/b;AAExBA,WAAAA,OAAO+b,gBAAiBC,CAAc,cAAA;AAC9B,YAAA,CAAA,EAAGnX,IAAI,IAAImX;AAEjB,iBAAWY,MAAM5c,OAAO2c;AACtB,YACEC,GAAGvM,SAAS,gBACZuM,GAAG/X,KAAKjB,WAAW,KACnB5D,OAAOsH,YAAYsV,GAAGC,UAAU,KAChCD,GAAGC,WAAW3a,UAAU2uB,gBACxBjU,GAAG/X,KAAK,CAAC,MAAMA,KAAK,CAAC,KACrB,CAACkV,KAAK3N,OAAOvH,MAAM+X,GAAG/X,IAAI,GAC1B;AACA,gBAAM,CAACtC,KAAK,IAAI4B,OAAOQ,KAAK3E,QAAQ,CAAC4c,GAAG/X,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC;AACvD,cAAIisB,KAAUhtB,OAAOvB,KAAK,KAAKA,MAAMI,SAAS,IAAI;AAChDjC,oBAAM,6BAA6BmwB,YAAY,UAAUjU,EAAE,GAC3DxU,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,cAACkC,OAAO2uB;AAAAA,YAAAA,GACR;AAAA,cAACxsB,IAAI,CAACuY,GAAG/X,KAAK,CAAC,IAAI,CAAC;AAAA,cAAGsX,OAAO;AAAA,YAAA,CAChC,GACA/T,YAAY2I,KAAK;AAAA,cAACV,MAAM;AAAA,YAAA,CAAmB;AAC3C;AAAA,UAAA;AAAA,QACF;AAIJ0L,oBAAcC,SAAS;AAAA,IAAA,GAGlBhc;AAAAA,EACT;AACF;AC3CcW,cAAc,mCAAmC;AAIxD,SAASowB,iCACd3oB,aAC8D;AAC9D,MAAI4oB,gBAAkC;AACtC,SAAO,SACLhxB,QACyB;AACzB,UAAMixB,4BAA4BA,MAAM;AAClCD,UAAAA,kBAAkBhxB,OAAO0E,WAAW;AACtC,YAAIwsB,UAAkC;AACtC,YAAIlxB,OAAO0E,WAAW;AACpB,gBAAMysB,WAAW/jB,6BAA6BgL,IAAIpY,OAAO0E,SAAS;AAC9DysB,qBACFD,UAAUC,YAEVD,UAAUxpB,sBAAsB;AAAA,YAC9BlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,YAC1CxG;AAAAA,YACA2H,OAAO3H,OAAO0E;AAAAA,UAAAA,CACf,GACD0I,6BAA6BoN,IAAIxa,OAAO0E,WAAWwsB,OAAO;AAAA,QAAA;AAU1DA,kBACF9oB,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,UAAoB3L,WAAWwsB;AAAAA,QAAAA,CAAQ,IAE/D9oB,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,UAAoB3L,WAAW;AAAA,QAAA,CAAK;AAAA,MAAA;AAGhEssB,sBAAgBhxB,OAAO0E;AAAAA,IAAAA,GAGnB;AAAA,MAAC2Z;AAAAA,IAAAA,IAAYre;AACnBA,WAAAA,OAAOqe,WAAW,MAAM;AACtBA,kBACKjW,YAAYG,YAAY,EAAEC,QAAQ;AAAA,QAACC,OAAO;AAAA,MAAa,CAAA,KAC1DwoB,0BAA0B;AAAA,IAAA,GAGvBjxB;AAAAA,EACT;AACF;AC5CA,MAAMU,UAAQC,cAAc,wBAAwB;AAK7C,SAASywB,sBAAsB;AAAA,EACpChpB;AAGF,GAAG;AACD,SAAO,SACLpI,QACyB;AAClBsH,WAAAA,cAAelG,CAChB+C,UAAAA,OAAOsC,SAASrF,KAAK,IAChB,KAGFkG,YAAYc,YAAYG,YAAY,EAAEM,SAASzH,KAAK,GAE7DpB,OAAOgF,aAAc5D,CACf+C,UAAAA,OAAOsC,SAASrF,KAAK,IAChB,KAGFosB,OAAOplB,YAAYG,YAAY,EAAEM,SAASzH,KAAK,GAExDpB,OAAOwH,cAAepG,CAChB+C,UAAAA,OAAOsC,SAASrF,KAAK,IAChB,KAGFoG,YAAYY,YAAYG,YAAY,EAAEM,SAASzH,KAAK,GAE7DpB,OAAO4L,SAAUhF,CACXzC,YAAAA,OAAOsC,SAASG,OAAO,IAClB,KAIPwB,YAAYG,YAAcM,EAAAA,QAAQrC,OAAO5E,MAAMhB,SAASgG,QAAQ/E,UAC/DuG,YACEG,cACAM,QAAQrC,OAAOS,aAAatF,IAAK0vB,CAAAA,QAAQA,IAAIzwB,IAAI,EACjD+X,SAAS/R,QAAQ/E,KAAK,KACvBuG,YACGG,cACAM,QAAQrC,OAAOgM,cAAc7Q,IAAK0vB,CAAAA,QAAQA,IAAIzwB,IAAI,EAClD+X,SAAS/R,QAAQ/E,KAAK,IAG/B7B,OAAOgH,WAAYJ,CACbzC,YAAAA,OAAOsC,SAASG,OAAO,IAClB,KAGiBwB,YACvBG,YACAM,EAAAA,QAAQrC,OAAOgM,cAAc7Q,IAAK0vB,CAAAA,QAAQA,IAAIzwB,IAAI,EAEjC+X,SAAS/R,QAAQ/E,KAAK,KACxC,cAAc+E,WACdA,QAAQ/D,aAAa;AAKnB,UAAA;AAAA,MAACkZ;AAAAA,IAAAA,IAAiB/b;AACxBA,WAAAA,OAAO+b,gBAAiB4O,CAAU,UAAA;AAC1B,YAAA,CAAChmB,MAAME,IAAI,IAAI8lB;AAGrB,UAAIhmB,KAAK9C,UAAU8B,UAAakB,KAAKjB,WAAW,GAAG;AACjDlD,gBAAM,+CAA+C;AAC/CwW,cAAAA,OAAOvS,MACPiL,MACJsH,KAAK7V,QAAQ+G,YAAYG,YAAAA,EAAcM,QAAQkO,aAAa;AAC9D3O,oBAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAc,GACtC8I,WAAWiD,SACTpc,QACA;AAAA,UACE,GAAGkX;AAAAA,UACHrV,OAAOuG,YAAYG,YAAAA,EAAcM,QAAQrC,OAAO0Q,KAAKtW;AAAAA,UACrDS,MAAMuO;AAAAA,QAAAA,GAER;AAAA,UAACvL,IAAIQ;AAAAA,QAAAA,CACP,GACAuD,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAmB;AAC3C;AAAA,MAAA;AAIE1L,UAAAA,KAAKtD,SAASsC,WAAckB,KAAKjB,WAAW,KAAKiB,KAAKjB,WAAW,IAAI;AACvElD,gBAAM,iDAAiD;AACvD,cAAMkP,MAAMxH,YAAYG,YAAY,EAAEM,QAAQkO,aAAa;AAC3D3O,oBAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAc,GACtC8I,WAAWiD,SAASpc,QAAQ;AAAA,UAACqB,MAAMuO;AAAAA,QAAAA,GAAM;AAAA,UAACvL,IAAIQ;AAAAA,QAAAA,CAAK,GACnDuD,YAAY2I,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAmB;AAC3C;AAAA,MAAA;AAGF0L,oBAAc4O,KAAK;AAAA,IAAA,GAEd3qB;AAAAA,EACT;AACF;AC5GO,SAASsxB,gBAAgB;AAAA,EAAClpB;AAAoB,GAAG;AACtD,SAAO,SACLpI,QACyB;AAClB6sB,WAAAA,OAAAA,qBAAsBzW,CAKb7U,YAAAA,aACZ,CACE;AAAA,MACEM,OAAOuG,YAAYG,YAAAA,EAAcM,QAAQrC,OAAO5E,MAAMhB;AAAAA,MACtDS,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,MACrD7U,OACEkG,YAAYG,YAAY,EAAEM,QAAQrC,OAAOxD,OAAO,CAAC,EAAEpC,QACnD;AAAA,MACF,GAAIwV,QAAQhP,WAAW;AAAA,QAACA,UAAUgP,QAAQhP;AAAAA,MAAAA,IAAY,CAAC;AAAA,MACvD,GAAIgP,QAAQ7C,QAAQ;AAAA,QAACA,OAAO6C,QAAQ7C;AAAAA,MAAAA,IAAS,CAAC;AAAA,MAC9CnR,UAAU,CAAE;AAAA,MACZE,UAAU,CACR;AAAA,QACET,OAAO;AAAA,QACPR,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,QACrDpU,MAAM;AAAA,QACNC,OAAOwT,QAAQqC,WAAWnB,OAAQoB,CAChCtQ,cAAAA,YACGG,YAAY,EACZM,QAAQrC,OAAOiS,WAAW/L,KACzB,CAAC;AAAA,UAAC9L;AAAAA,QAAAA,MAAUA,SAAS8X,SACvB,CACJ;AAAA,MACD,CAAA;AAAA,IAAA,CAEJ,GAEH;AAAA,MAAClX,aAAa4G,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,IAAAA,CAClD,EAAE,CAAC,GAGExG;AAAAA,EACT;AACF;ACvCO,SAASuxB,aAAa;AAAA,EAC3B/qB;AAAAA,EACAxG;AAIF,GAA0B;AACxB,MAAI,CAACA,OAAO0E;AACV;AAGF,QAAM,CAAC9C,OAAOqC,SAAS,IAAIQ,cAAc;AAAA,IACvCzE;AAAAA,EACD,CAAA,GACK,CAACkX,MAAM0C,QAAQ,IAAI7U,aAAa;AAAA,IACpC/E;AAAAA,EAAAA,CACD;AAED,MAAI,CAAC4B,SAAS,CAAC5B,OAAOsH,YAAY1F,KAAK,KAAK,CAACsV;AAC3C;AAGF,MAAI9R,MAAM0Y,WAAW9d,OAAO0E,SAAS,GAAG;AACtC,UAAM8sB,gBAAgBvsB,iBAAiB;AAAA,MAACjF;AAAAA,IAAAA,CAAO;AAE3CqjB,QAAAA,QAAQ,GACRzgB,SAAuB,CAAE;AAElB,eAAA,CAACsU,KAAI,KAAKsa;AACfnO,gBAAU,IACZzgB,SAAQsU,MAAKtU,SAAS,CAAA,KAGpBsU,MAAKtU,OAAOgB,WAAW,MACtBsT,MAAKtU,SAAS,CAAA,IAAKmE,KAAMyR,CAAAA,SAAS,CAAC5V,OAAM+V,SAASH,IAAI,CAAC,OAExD5V,SAAQ,CAIZygB,IAAAA;AAGK,WAAA;AAAA,MACLhK,OAAO;AAAA,MACPzW,OAAAA;AAAAA,IACF;AAAA,EAAA;AAGI6V,QAAAA,aAAajS,OAAOiS,WAAW9W,IAAK+W,eAAcA,UAAU9X,IAAI,GAChEgC,QAAQsU,KAAKtU,SAAS,CAAE,GACxB6uB,0BAA0B7uB,MAAM0U,OAAQkB,UAC5CC,WAAWE,SAASH,IAAI,CAC1B,GAEMuF,qBAAqBnb,MAAMgB,SAAS6tB,wBAAwB7tB,QAE5D8tB,cAAcxa,KAAKvU,KAAKiB,WAAW,GAEnC+tB,uBAAuB3xB,OAAO0E,UAAUmD,OAAOE,WAAW,GAC1D6pB,iBAAiB5xB,OAAO0E,UAAUmD,OAAOE,WAAWmP,KAAKvU,KAAKiB,QAE9DiW,eAAeF,gBAAgB;AAAA,IAAC3Z;AAAAA,IAAQiE;AAAAA,IAAW2V;AAAAA,EAAAA,CAAS,GAC5DM,WAAWD,YAAY;AAAA,IAACja;AAAAA,IAAQiE;AAAAA,IAAW2V;AAAAA,EAAAA,CAAS,GACpD2D,sBACJrD,UAAUtX,OAAO0U,OAAQkB,CAAAA,SAAS,CAACC,WAAWE,SAASH,IAAI,CAAC,KAAK,IAC7DqZ,kBAAkBjvB,MAAM0U,OAAQkB,CAAAA,SAAS,CAACC,WAAWE,SAASH,IAAI,CAAC,GAEnEsZ,6BAA6BjY,eAC/BA,aAAajX,OAAOmE,KAAMyR,CAAAA,SAAS,CAACC,WAAWE,SAASH,IAAI,CAAC,IAC7D,IACEuZ,iCAAiClY,eACnCA,aAAajX,OACT0U,OAAQkB,CAAS,SAAA,CAACC,WAAWE,SAASH,IAAI,CAAC,EAC5CjR,MAAOiR,CAAS5V,SAAAA,MAAM+V,SAASH,IAAI,CAAC,IACvC,IACE0F,gCAAgCrE,eAClCA,aAAajX,OAAOmE,KACjByR,CAAS,SAAA,CAACC,WAAWE,SAASH,IAAI,KAAK5V,MAAM+V,SAASH,IAAI,CAC7D,IACA,IAEEwZ,2BAA2BnY,eAC7BA,aAAajX,OAAO2E,MAAOiR,UAAS5V,MAAM+V,SAASH,IAAI,CAAC,IACxD,IACEyZ,gCAAgCJ,gBAAgB9qB,KAAMyR,CAC1D+E,SAAAA,qBAAqB5E,SAASH,IAAI,CACpC;AAEIuF,MAAAA,sBAAsB,CAAC2T,aAAa;AACtC,QAAIC,sBAAsB;AACpBK,UAAAA;AACK,eAAA;AAAA,UACL3Y,OAAO;AAAA,UACPzW,OAAOiX,cAAcjX,SAAS,CAAA;AAAA,QAChC;AACSmvB,UAAAA;AACF,eAAA;AAAA,UACL1Y,OAAO;AAAA,UACPzW,OAAOiX,cAAcjX,SAAS,CAAA;AAAA,QAChC;AACSsb,UAAAA;AACF,eAAA;AAAA,UACL7E,OAAO;AAAA,UACPzW,OAAOsU,KAAKtU,SAAS,CAAA;AAAA,QACvB;AACK,UAAI,CAACiX;AACH,eAAA;AAAA,UACLR,OAAO;AAAA,UACPzW,OAAO,CAAA;AAAA,QACT;AAAA,IAAA;AAIJ,QAAIgvB,gBAAgB;AAClB,UACG1X,YACC+X,iCACA1U,oBAAoB3Z,SAASiuB,gBAAgBjuB,UAC/C,CAACquB;AAEM,eAAA;AAAA,UACL5Y,OAAO;AAAA,UACPzW,OAAOsX,UAAUtX,SAAS,CAAA;AAAA,QAC5B;AAGF,UAAI,CAACsX;AACI,eAAA;AAAA,UACLb,OAAO;AAAA,UACPzW,OAAO,CAAA;AAAA,QACT;AAAA,IAAA;AAAA,EAEJ;AAGF,SAAI+uB,wBAAwB,CAACD,eAAiB7X,eACxCiY,6BACK;AAAA,IACLzY,OAAO;AAAA,IACPzW,OAAO,CAAA;AAAA,EAAA,IAGF;AAAA,IACLyW,OAAO;AAAA,IACPzW,QAAQiX,cAAcjX,SAAS,CAAE,GAAE0U,OAAQkB,CACzCC,SAAAA,WAAWE,SAASH,IAAI,CAC1B;AAAA,EAAA,IAKC;AAAA,IACLa,OAAO;AAAA,IACPzW,OAAOsU,KAAKtU,SAAS,CAAA;AAAA,EACvB;AACF;ACvKgBsvB,SAAAA,sBACdrpB,SACA7I,QACA;AACM,QAAA;AAAA,IAAC8b,OAAAA;AAAAA,EAAAA,IAAS9b;AAEhBA,SAAAA,OAAO8b,QAAS7P,CAAc,cAAA;AAC5B6P,IAAAA,OAAM7P,SAAS,GAEfjM,OAAOuY,YAAYgZ,aAAa;AAAA,MAC9BvxB;AAAAA,MACAwG,QAAQqC,QAAQrC;AAAAA,IAAAA,CACjB;AAAA,EAAA,GAGIxG;AACT;ACFO,SAASmyB,aACdxtB,MACmC;AACnC,SAAI,OAAOA,QAAS,YAAYA,SAAS,OAErC,EAAE,WAAWA,SAAS,cAAcA,QAAQlD,MAAMC,QAAQiD,KAAKrC,QAAQ,IAIpE;AACT;AAWgB8vB,SAAAA,gBACdvpB,SACAlE,MACsC;AACtC,SAAO0tB,cAAc1tB,IAAI,KAAKA,KAAK9C,UAAUgH,QAAQrC,OAAO5E,MAAMhB;AACpE;AAWgB0xB,SAAAA,WACdzpB,SACAlE,MACiC;AAKjC,SAJI,OAAOA,QAAS,YAAYA,SAAS,QAIrC,cAAcA,OACT,KAGL,WAAWA,OACNA,KAAK9C,UAAUgH,QAAQrC,OAAO0Q,KAAKtW,OAGrC,UAAU+D;AACnB;AASO,SAAS4tB,kBAAkB5tB,MAAwC;AAEtE,SAAA,OAAOA,QAAS,YAChBA,SAAS,QACT,UAAUA,QACV,OAAOA,KAAKhC,QAAS;AAEzB;AAUgB6vB,SAAAA,aACd3pB,SACAlE,MACoB;AACpB,SACE,CAACwtB,aAAaxtB,IAAI,KAClB,CAACytB,gBAAgBvpB,SAASlE,IAAI,KAC9B,CAAC2tB,WAAWzpB,SAASlE,IAAI,KACzB,CAAC4tB,kBAAkB5tB,IAAI;AAE3B;AAKgB8tB,SAAAA,SACdC,MACA7tB,MACuD;AACjDwe,QAAAA,QAAQxe,KAAKR,GAAG,CAAC;AAEnBgf,MAAAA,EAAAA,UAAU1f,UAAakB,KAAKjB,WAAW;AAIpC8uB,WAAAA,KAAKpwB,SAAS+B,GAAGgf,KAAK;AAC/B;AASgBsP,SAAAA,QACd9pB,SACA6pB,MACA7tB,MAC6C;AAC7C,MAAIA,KAAKjB,WAAW;AACX8uB,WAAAA;AAGT,MAAI7tB,KAAKjB,WAAW;AACX6uB,WAAAA,SAASC,MAAM7tB,IAAI;AAGxBA,MAAAA,KAAKjB,WAAW,GAAG;AACrB,UAAMhC,QAAQ6wB,SAASC,MAAM7tB,KAAKC,MAAM,GAAG,CAAC,CAAC;AAE7C,WAAI,CAAClD,SAAS,CAACwwB,gBAAgBvpB,SAASjH,KAAK,IAC3C,SAGYA,MAAMU,SAAS+B,GAAGQ,KAAK,CAAC,CAAC,KAGrC;AAAA,EAAA;AAKN;AAEgB+tB,SAAAA,QACd/pB,SACA6pB,MACA7tB,MACA;AACA,QAAMF,OAAOguB,QAAQ9pB,SAAS6pB,MAAM7tB,IAAI;AAEpCF,MAAAA,QAAQ2tB,WAAWzpB,SAASlE,IAAI;AAC3BA,WAAAA;AAIX;AAKgBkuB,SAAAA,UACdhqB,SACA6pB,MACA7tB,MACA;AACA,MAAIA,KAAKjB,WAAW;AAClB;AAGF,QAAMkvB,aAAajuB,KAAKC,MAAM,GAAG,EAAE;AAEnC,MAAIguB,WAAWlvB,WAAW;AACjB8uB,WAAAA;AAGHluB,QAAAA,aAAasuB,WAAWzuB,GAAG,CAAC;AAE9BG,MAAAA,eAAeb,UAAamvB,WAAWlvB,WAAW;AACpD;AAGF,QAAMhC,QAAQ8wB,KAAKpwB,SAAS+B,GAAGG,UAAU;AAErC5C,MAAAA,SAASwwB,gBAAgBvpB,SAASjH,KAAK;AAClCA,WAAAA;AAIX;AC3LgBmxB,SAAAA,6BACdlqB,SACAzH,OACA6K,WACA;AACA,QAAM+mB,QAAQC,YAAY;AAAA,IAAC3wB,UAAUlB;AAAAA,EAAAA,CAAM;AAEvC,MAAA;AACgCyH,sCAAAA,SAASmqB,OAAO/mB,SAAS;AAAA,WACpDinB,GAAG;AACV7nB,YAAQyG,MAAMohB,CAAC;AAAA,EAAA;AAGVC,SAAAA,YAAYH,KAAK,EAAE1wB;AAC5B;AAEA,SAAS8wB,kCACPvqB,SACA6pB,MAGAzmB,WACA;AACA,UAAQA,UAAUoE,MAAI;AAAA,IACpB,KAAK,eAAe;AACZ,YAAA;AAAA,QAACxL;AAAAA,QAAMF,MAAM0uB;AAAAA,MAAgBpnB,IAAAA,WAC7BpF,SAASgsB,UAAUhqB,SAAS6pB,MAAM7tB,IAAI,GACtCwe,QAAQxe,KAAKA,KAAKjB,SAAS,CAAC;AAMlC,UAJI,CAACiD,UAIDwc,QAAQxc,OAAOvE,SAASsB;AAC1B;AAGEiB,UAAAA,KAAKjB,WAAW,GAAG;AAGjBwuB,YAAAA,gBAAgBvpB,SAASwqB,YAAY,GAAG;AAGnC/wB,iBAAAA,SAASme,OAAO4C,OAAO,GAAG;AAAA,YAC/B,GAAGgQ;AAAAA,YACH/wB,UAAU+wB,aAAa/wB,SAASX,IAAKY,CAAAA,UAC/B,cAAcA,QAGT;AAAA,cACLlB,MAAMkB,MAAMlB;AAAAA,cACZQ,OAAOU,MAAMV;AAAAA,cACb,GAAI,WAAWU,SAAS,OAAOA,MAAMnB,SAAU,WAC3CmB,MAAMnB,QACN,CAAA;AAAA,YAAC,IAIFmB,KACR;AAAA,UAAA,CACF;AAED;AAAA,QAAA;AAGF,YAAIO,UAAQC,UAAUswB,YAAY,KAAK,EAAE,cAAcA,eAAe;AAG7D/wB,iBAAAA,SAASme,OAAO4C,OAAO,GAAG;AAAA,YAC/BhiB,MAAMgyB,aAAahyB;AAAAA,YACnBQ,OAAOwxB,aAAaxxB;AAAAA,YACpB,GAAI,WAAWwxB,gBACf,OAAOA,aAAajyB,SAAU,WAC1BiyB,aAAajyB,QACb,CAAA;AAAA,UAAC,CACN;AACD;AAAA,QAAA;AAAA,MACF;AAGEyD,UAAAA,KAAKjB,WAAW,GAAG;AAGjB,YAAA,CAACwuB,gBAAgBvpB,SAAShC,MAAM;AAElC;AAGE0rB,YAAAA,kBAAkBc,YAAY,GAAG;AAGnCxsB,iBAAOvE,SAASme,OAAO4C,OAAO,GAAGgQ,YAAY;AAC7C;AAAA,QAAA;AAGF,YAAI,cAAcA,cAAc;AAGvB/wB,iBAAAA,SAASme,OAAO4C,OAAO,GAAG;AAAA,YAC/BhiB,MAAMgyB,aAAahyB;AAAAA,YACnBQ,OAAOwxB,aAAaxxB;AAAAA,YACpB,GAAI,WAAWwxB,gBACf,OAAOA,aAAajyB,SAAU,WAC1BiyB,aAAajyB,QACb,CAAA;AAAA,UAAC,CACN;AACD;AAAA,QAAA;AAAA,MACF;AAGF;AAAA,IAAA;AAAA,IAGF,KAAK,eAAe;AACZ,YAAA;AAAA,QAACyD;AAAAA,QAAMkD;AAAAA,QAAQpF;AAAAA,MAAAA,IAAQsJ;AACzBtJ,UAAAA,KAAKiB,WAAW,EAAG;AACvB,YAAMsT,OAAO0b,QAAQ/pB,SAAS6pB,MAAM7tB,IAAI;AAExC,UAAI,CAACqS;AACH;AAGIoc,YAAAA,SAASpc,KAAKvU,KAAKmC,MAAM,GAAGiD,MAAM,GAClCwrB,QAAQrc,KAAKvU,KAAKmC,MAAMiD,MAAM;AAC/BpF,WAAAA,OAAO2wB,SAAS3wB,OAAO4wB;AAE5B;AAAA,IAAA;AAAA,IAGF,KAAK,cAAc;AACX,YAAA;AAAA,QAAC1uB;AAAAA,MAAAA,IAAQoH,WACTtH,OAAOguB,QAAQ9pB,SAAS6pB,MAAM7tB,IAAI,GAClC2uB,WAAWzZ,KAAK0Z,SAAS5uB,IAAI,GAC7ByV,OAAOqY,QAAQ9pB,SAAS6pB,MAAMc,QAAQ,GACtC3sB,SAASgsB,UAAUhqB,SAAS6pB,MAAM7tB,IAAI;AAE5C,UAAI,CAACF,QAAQ,CAAC2V,QAAQ,CAACzT;AACrB;AAGF,YAAMwc,QAAQxe,KAAKA,KAAKjB,SAAS,CAAC;AAElC,UAAI2uB,kBAAkB5tB,IAAI,KAAK4tB,kBAAkBjY,IAAI;AACnDA,aAAK3X,QAAQgC,KAAKhC;AAAAA,eAElByvB,gBAAgBvpB,SAASlE,IAAI,KAC7BytB,gBAAgBvpB,SAASyR,IAAI;AAE7BA,aAAKhY,SAAS4F,KAAK,GAAGvD,KAAKrC,QAAQ;AAAA;AAEnC;AAGKA,aAAAA,SAASme,OAAO4C,OAAO,CAAC;AAE/B;AAAA,IAAA;AAAA,IAGF,KAAK,aAAa;AACV,YAAA;AAAA,QAACxe;AAAAA,QAAMyH;AAAAA,MAAAA,IAAWL;AAEpB8N,UAAAA,KAAK2Z,WAAW7uB,MAAMyH,OAAO;AAC/B;AAGF,YAAM3H,OAAOguB,QAAQ9pB,SAAS6pB,MAAM7tB,IAAI,GAClCgC,SAASgsB,UAAUhqB,SAAS6pB,MAAM7tB,IAAI,GACtCwe,QAAQxe,KAAKA,KAAKjB,SAAS,CAAC;AAE9B,UAAA,CAACe,QAAQ,CAACkC;AACZ;AASKvE,aAAAA,SAASme,OAAO4C,OAAO,CAAC;AAC/B,YAAMsQ,WAAW5Z,KAAK5N,UAAUtH,MAAMoH,SAAS,GACzC2nB,YAAYjB,QAAQ9pB,SAAS6pB,MAAM3Y,KAAKlT,OAAO8sB,QAAQ,CAAC,GACxDE,WAAWF,SAASA,SAAS/vB,SAAS,CAAC;AAEzC,UAAA,CAACgwB,aAID,EAAE,cAAcA,cAIhB,CAACnyB,MAAMC,QAAQkyB,UAAUtxB,QAAQ;AACnC;AAGFsxB,gBAAUtxB,SAASme,OAAOoT,UAAU,GAAGlvB,IAAI;AAE3C;AAAA,IAAA;AAAA,IAGF,KAAK,eAAe;AACZ,YAAA;AAAA,QAACE;AAAAA,MAAAA,IAAQoH,WACToX,QAAQxe,KAAKA,KAAKjB,SAAS,CAAC;AACnBivB,gBAAUhqB,SAAS6pB,MAAM7tB,IAAI,GACpCvC,SAASme,OAAO4C,OAAO,CAAC;AAEhC;AAAA,IAAA;AAAA,IAGF,KAAK,eAAe;AACZ,YAAA;AAAA,QAACxe;AAAAA,QAAMkD;AAAAA,QAAQpF;AAAAA,MAAAA,IAAQsJ;AAE7B,UAAItJ,KAAKiB,WAAW;AAClB;AAGF,YAAMsT,OAAO0b,QAAQ/pB,SAAS6pB,MAAM7tB,IAAI;AAExC,UAAI,CAACqS;AACH;AAGF,YAAMoc,SAASpc,KAAKvU,KAAKmC,MAAM,GAAGiD,MAAM,GAClCwrB,QAAQrc,KAAKvU,KAAKmC,MAAMiD,SAASpF,KAAKiB,MAAM;AAClDsT,WAAKvU,OAAO2wB,SAASC;AAErB;AAAA,IAAA;AAAA,IAGF,KAAK,YAAY;AACT,YAAA;AAAA,QAAC1uB;AAAAA,QAAMgY;AAAAA,QAAYC;AAAAA,MAAAA,IAAiB7Q,WAEpCtH,OAAOguB,QAAQ9pB,SAAS6pB,MAAM7tB,IAAI;AAEpC,UAAA,CAACF,QAIDwtB,aAAaxtB,IAAI;AACnB;AAGE6tB,UAAAA,aAAa3pB,SAASlE,IAAI,GAAG;AACzBmvB,cAAAA,cACJ,WAAWjX,cAAc,OAAOA,WAAWzb,SAAU,WACjDyb,WAAWzb,QACX,IAEA2yB,aACJ,WAAWjX,iBAAiB,OAAOA,cAAc1b,SAAU,WACvD0b,cAAc1b,QACd,CAAC;AAGP,mBAAWwO,OAAOkN,eAAe;AAC/B,cAAIlN,QAAQ;AACV;AAGIxO,gBAAAA,QAAQ0b,cAAclN,GAAG;AAE3BxO,mBAAS,OACX,OAAOuD,KAA2CiL,GAAG,IAErDjL,KAA2CiL,GAAG,IAAIxO;AAAAA,QAAAA;AAItD,mBAAWwO,OAAOiN;AACZjN,kBAAQ,YAIPkN,cAAckX,eAAepkB,GAAG,KACnC,OAAOjL,KAA2CiL,GAAG;AAIzD,mBAAWA,OAAOmkB,YAAY;AACtB3yB,gBAAAA,QAAQ2yB,WAAWnkB,GAAG;AAExBxO,mBAAS,OACX,OAAOuD,KAA2CiL,GAAG,IAErDjL,KAA2CiL,GAAG,IAAIxO;AAAAA,QAAAA;AAItD,mBAAWwO,OAAOkkB;AACXC,qBAAWC,eAAepkB,GAAG,KAChC,OAAOjL,KAA2CiL,GAAG;AAIzD;AAAA,MAAA;AAGEwiB,UAAAA,gBAAgBvpB,SAASlE,IAAI,GAAG;AAClC,mBAAWiL,OAAOkN,eAAe;AAC3BlN,cAAAA,QAAQ,cAAcA,QAAQ;AAChC;AAGIxO,gBAAAA,QAAQ0b,cAAclN,GAAG;AAE3BxO,mBAAS,OACX,OAAOuD,KAA0BiL,GAAG,IAEpCjL,KAA0BiL,GAAG,IAAIxO;AAAAA,QAAAA;AAKrC,mBAAWwO,OAAOiN;AACXC,wBAAckX,eAAepkB,GAAG,KACnC,OAAOjL,KAA0BiL,GAAG;AAIxC;AAAA,MAAA;AAGE2iB,UAAAA,kBAAkB5tB,IAAI,GAAG;AAC3B,mBAAWiL,OAAOkN,eAAe;AAC/B,cAAIlN,QAAQ;AACV;AAGIxO,gBAAAA,QAAQ0b,cAAclN,GAAG;AAE3BxO,mBAAS,OACX,OAAOuD,KAA2CiL,GAAG,IAErDjL,KAA2CiL,GAAG,IAAIxO;AAAAA,QAAAA;AAKtD,mBAAWwO,OAAOiN;AACXC,wBAAckX,eAAepkB,GAAG,KACnC,OAAOjL,KAA2CiL,GAAG;AAIzD;AAAA,MAAA;AAGF;AAAA,IAAA;AAAA,IAGF,KAAK,cAAc;AACX,YAAA;AAAA,QAAC/K;AAAAA,QAAMgG;AAAAA,QAAUgS;AAAAA,MAAAA,IAAc5Q;AAErC,UAAIpH,KAAKjB,WAAW;AAClB;AAGIiD,YAAAA,SAASgsB,UAAUhqB,SAAS6pB,MAAM7tB,IAAI,GACtCwe,QAAQxe,KAAKA,KAAKjB,SAAS,CAAC;AAElC,UAAI,CAACiD;AACH;AAGEsrB,UAAAA,aAAatrB,MAAM,GAAG;AAClBjF,cAAAA,QAAQ6wB,SAASC,MAAM7tB,IAAI;AAEjC,YAAI,CAACjD,SAAS,CAACwwB,gBAAgBvpB,SAASjH,KAAK;AAC3C;AAGI0xB,cAAAA,SAAS1xB,MAAMU,SAASwC,MAAM,GAAG+F,QAAQ,GACzC0oB,QAAQ3xB,MAAMU,SAASwC,MAAM+F,QAAQ;AAC3CjJ,cAAMU,WAAWgxB;AAGjB,cAAMW,mBAAmB;AAAA,UACvB,GAAGpX;AAAAA,UACHva,UAAUixB;AAAAA,UACV1xB,OAAOgH,QAAQrC,OAAO5E,MAAMhB;AAAAA,QAC9B;AAEAiG,eAAOvE,SAASme,OAAO4C,QAAQ,GAAG,GAAG4Q,gBAAgB;AAErD;AAAA,MAAA;AAGE7B,UAAAA,gBAAgBvpB,SAAShC,MAAM,GAAG;AACpC,cAAMlC,OAAOguB,QAAQ9pB,SAAS6pB,MAAM7tB,IAAI;AAExC,YAAI,CAACF,QAAQ,CAAC2tB,WAAWzpB,SAASlE,IAAI;AACpC;AAGI2uB,cAAAA,SAAS3uB,KAAKhC,KAAKmC,MAAM,GAAG+F,QAAQ,GACpC0oB,QAAQ5uB,KAAKhC,KAAKmC,MAAM+F,QAAQ;AACtClG,aAAKhC,OAAO2wB;AAGZ,cAAMY,cAAc;AAAA,UAClB,GAAGrX;AAAAA,UACHla,MAAM4wB;AAAAA,QACR;AAEA1sB,eAAOvE,SAASme,OAAO4C,QAAQ,GAAG,GAAG6Q,WAAW;AAAA,MAAA;AAGlD;AAAA,IAAA;AAAA,EACF;AAGKxB,SAAAA;AACT;AC9agByB,SAAAA,kBACdtrB,SACA7I,QACA;AACM,QAAA;AAAA,IAAC8b,OAAAA;AAAAA,EAAAA,IAAS9b;AAEhBA,SAAAA,OAAO8b,QAAS7P,CAAc,cAAA;AACxBA,QAAAA,UAAUoE,SAAS,iBAAiB;AACtCyL,MAAAA,OAAM7P,SAAS;AACf;AAAA,IAAA;AAGK7K,WAAAA,QAAQ2xB,6BACblqB,SACA7I,OAAOoB,OACP6K,SACF,GAEA6P,OAAM7P,SAAS;AAAA,EAAA,GAGVjM;AACT;ACIao0B,MAAAA,cAAcA,CACzBp0B,QACAoW,YAC4B;AAC5B,QAAM8c,IAAIlzB,QACJ;AAAA,IAACoI;AAAAA,IAAaynB;AAAAA,EAAAA,IAAczZ,SAC5Bie,iBAAiB7J,qBAAqBpiB,WAAW,GACjDksB,kBAAkBlD,sBAAsB;AAAA,IAC5ChpB;AAAAA,EAAAA,CACD,GACKmsB,cAAc3E,kBAAkB;AAAA,IACpCxnB;AAAAA,IACAynB;AAAAA,IACA5P,eAAe7J,QAAQ6J;AAAAA,EAAAA,CACxB,GACKuU,gBAAgBlK,oBAAoBliB,WAAW,GAC/CqsB,eAAe5U,mBAAmB;AAAA,IACtCzX;AAAAA,IACA6X,eAAe7J,QAAQ6J;AAAAA,EACxB,CAAA,GACKyU,4BAA4B7Y,gCAAgCzT,WAAW,GACvEusB,6BACJ/D,iCAAiCxoB,WAAW,GAExCwsB,uBAAuBlE,2BAA2BtoB,WAAW,GAE7DysB,YAAYvD,gBAAgB;AAAA,IAChClpB;AAAAA,EAAAA,CACD,GACK0sB,6BACJ/D,iCAAiC3oB,WAAW;AAI9C,SAH2BqhB,yBAAyBrhB,WAAW,EAI7DksB,gBACED,eACEK,0BACEC,2BACEC,qBACEC,UACEL,cACEC,aACEF,YACEO,2BACEX,kBACE/rB,YAAYG,YAAY,EAAEM,SAC1BqpB,sBACE9pB,YAAYG,YAAY,EAAEM,SAC1BqqB,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF;AACF,GC/EMxyB,UAAQC,cAAc,OAAO;AAa5B,SAASo0B,kBAAkBxlB,QAAwC;AACxE7O,UAAM,oCAAoC;AAE1C,QAAMib,WAAWyY,YAAYY,UAAUC,aAAc,CAAA,GAAG;AAAA,IACtD7sB,aAAamH,OAAOnH;AAAAA,IACpBynB,YAAYtgB,OAAOsgB;AAAAA,IACnB5P,eAAe1Q,OAAO0Q;AAAAA,EAAAA,CACvB;AAEoBzF,uBAAAA,IAAImB,UAAU,CAAA,CAAE,GACrCzO,qBAAqBsN,IAAImB,UAAU,CAAA,CAAE,GAErCA,SAAS9C,iBAAiB,CAAA,GAC1B8C,SAASpD,YAAY5U,QACrBgY,SAASva,QAAQ,CACfiX,uBAAuB9I,OAAOnH,YAAYG,YAAcM,EAAAA,OAAO,CAAC;AAG5DqsB,QAAAA,eAAe3zB,aAAaoa,SAASva,OAAO;AAAA,IAChDI,aAAa+N,OAAOnH,YAAYG,YAAAA,EAAcM,QAAQrC;AAAAA,EAAAA,CACvD;AAEgC,SAAA;AAAA,IAC/BmV;AAAAA,IACAuZ;AAAAA,EACF;AAGF;ACnDA,MAAMC,oCAAoCplB,eAAe;AAAA,EACvD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACjB,QAAA,CAACE,uBAA+BF,QAAQ;AACnC,aAAA;AAGHknB,UAAAA,qBAAqBhnB,sBAAgCF,QAAQ;AAEnE,WACE,CAACknB,sBACD,CAAChnB,oBAA8B;AAAA,MAE7BvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW0wB;AAAAA,MAAAA;AAAAA,IAEd,CAAA,IAEM,KAGF;AAAA,MAACA;AAAAA,IAAkB;AAAA,EAC5B;AAAA,EACAhlB,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAAC8sB;AAAAA,EAAkB,MAAM,CACjCC,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAUhM,IAAI+wB;AAAAA,EAAmB,CAAA,GAC9CC,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAkBoN,YAAYnV,MAAMmV;AAAAA,EAAAA,CAAW,CAAC,CAC9D;AAEL,CAAC,GAEY6X,0BAA0B;AAAA,EACrCH;AACF,GCpBMI,SACJ,OAAO/qB,SAAW,OAClB,uBAAuBgrB,KAAKhrB,OAAOirB,UAAUC,SAAS,GAIlDC,YAAkD;AAAA,EACtDC,KAAK;AAAA,EACLC,SAAS;AAAA,EACTC,MAAM;AAAA,EACNvU,OAAO;AACT,GAEMwU,UAA8C;AAAA,EAClDrZ,KAAK;AAAA,EACLsZ,OAAO;AAAA,EACPC,KAAK;AAAA,EACLC,SAAS;AAAA,EACTC,KAAK;AAAA,EACLC,MAAM;AAAA,EACNC,KAAK;AAAA,EACLC,MAAM;AAAA,EACNC,KAAK;AAAA,EACLC,KAAK;AAAA,EACLC,MAAM;AAAA,EACNC,KAAKnB,SAAS,SAAS;AAAA,EACvBoB,KAAK;AAAA,EACLC,QAAQ;AAAA,EACRC,QAAQ;AAAA,EACRC,OAAO;AAAA,EACPC,OAAO;AAAA,EACPC,UAAU;AAAA,EACVC,IAAI;AAAA,EACJC,KAAK;AAAA,EACLC,SAAS;AACX,GAEMC,WAA+C;AAAA,EACnD,WAAa;AAAA,EACb,KAAO;AAAA,EACP,OAAS;AAAA,EACT,OAAS;AAAA,EACT,SAAW;AAAA,EACX,KAAO;AAAA,EACP,OAAS;AAAA,EACT,UAAY;AAAA,EACZ,QAAU;AAAA,EACV,KAAK;AAAA,EACL,QAAU;AAAA,EACV,UAAY;AAAA,EACZ,KAAO;AAAA,EACP,MAAQ;AAAA,EACR,WAAa;AAAA,EACb,SAAW;AAAA,EACX,YAAc;AAAA,EACd,WAAa;AAAA,EACb,QAAU;AAAA,EACV,QAAU;AAAA,EACV,MAAQ;AAAA,EACR,SAAW;AAAA,EACX,YAAc;AAAA,EACd,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,IAAM;AAAA,EACN,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AAAA,EACP,KAAO;AACT;AAEgBC,SAAAA,SAASC,QAAgBhvB,OAAmC;AAC1E,SAAOivB,cAAcC,YAAYF,MAAM,GAAGhvB,KAAK;AACjD;AAEA,SAASkvB,YAAYF,QAAwB;AAE3C,QAAMG,eAAuB;AAAA,IAC3BC,QAAQ;AAAA,IACRC,SAAS;AAAA,IACTC,SAAS;AAAA,IACTC,UAAU;AAAA,EAAA,GAINC,iBAAiBR,OAAO3f,QAAQ,MAAM,MAAM,EAAEF,MAAM,GAAG;AAE7D,aAAWsgB,oBAAoBD,gBAAgB;AAC7C,UAAME,WACJD,iBAAiBE,SAAS,GAAG,KAAKF,iBAAiBn0B,SAAS,GACxDs0B,gBAAgBF,WAClBD,iBAAiBjzB,MAAM,GAAG,EAAE,IAC5BizB,kBACE5J,UAAUgK,UAAUD,aAAa,GACjCE,WAAWzC,UAAUxH,OAAO,GAC5BkK,QAAQtC,QAAQmC,aAAa,GAC7BI,OAAOlB,SAASjJ,OAAO;AAE7B,QACE+J,cAAct0B,SAAS,KACvBw0B,aAAaz0B,UACb00B,UAAU10B,UACV20B,SAAS30B;AAET,YAAM,IAAI40B,UAAU,sBAAsBL,aAAa,GAAG;AAG5D,KAAIJ,eAAel0B,WAAW,KAAKw0B,aAAaz0B,YAC9C8zB,aAAa7nB,MAAMue,SACnBsJ,aAAae,UAAUC,UAAUP,aAAa,IAG5CE,aAAaz0B,WACf8zB,aAAaW,QAAQ,IAAIJ,WAAW,OAAO;AAAA,EAAA;AAIxCP,SAAAA;AACT;AAEA,SAASF,cACPE,cACAnvB,OACS;AAENmvB,UAAAA,aAAaC,UAAU,QACpBD,aAAaC,WAAWpvB,MAAMovB,YAEjCD,aAAaE,WAAW,QACrBF,aAAaE,YAAYrvB,MAAMqvB,aAElCF,aAAaG,WAAW,QACrBH,aAAaG,YAAYtvB,MAAMsvB,aAElCH,aAAaI,YAAY,QACtBJ,aAAaI,aAAavvB,MAAMuvB,YAOlCJ,aAAae,YAAY70B,UAAa2E,MAAMkwB,YAAY70B,SACtD8zB,aAAae,YAAY,MAAMlwB,MAAMkwB,YAAY,KAC5C,KAGFf,aAAae,YAAYlwB,MAAMkwB,UAItCf,aAAae,YAAYlwB,MAAMkwB,WAC/Bf,aAAa7nB,QAAQtH,MAAMsH,IAAI8oB,YAbxB,IAAA;AAeX;AAEA,SAASD,UAAU73B,MAAsB;AACjCutB,QAAAA,UAAUgK,UAAUv3B,IAAI;AAG9B,SAFgBw2B,SAASjJ,OAAO,KAAKA,QAAQwK,YAAY,EAAEC,WAAW,CAAC;AAGzE;AAEA,SAAST,UAAUv3B,MAAsB;AACjCutB,QAAAA,UAAUvtB,KAAK83B,YAAY;AAE1B3C,SAAAA,QAAQ5H,OAAO,KAAKA;AAC7B;ACzMA,MAAM0K,+BAA+B9oB,eAAe;AAAA,EAClD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAGxB,QAAA,CAFgB+uB,SAAS,aAAa/uB,MAAMgN,WAAW,KAQvD,CAFuBlH,uBAA+BF,QAAQ;AAGzD,aAAA;AAGH4qB,UAAAA,mBAAmB1qB,oBAA8BF,QAAQ,GACzD6qB,YAAY3qB,aAAuBF,QAAQ;AAEjD,WAAO4qB,oBAAoB,CAACC;AAAAA,EAC9B;AAAA,EACA3oB,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,EAAQ,MAAM,CACdmnB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,IACvC;AAAA,IACA8mB,WAAW;AAAA,EAAA,CACZ,CAAC,CACH;AAEL,CAAC,GAEKsR,6BAA6BjpB,eAAe;AAAA,EAChD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAGxB,QAAA,CAFc+uB,SAAS,WAAW/uB,MAAMgN,WAAW,KAQnD,CAFuBlH,uBAA+BF,QAAQ;AAGzD,aAAA;AAGH4qB,UAAAA,mBAAmB1qB,oBAA8BF,QAAQ,GACzD+qB,gBAAgB7qB,iBAA2BF,QAAQ;AAEzD,WAAO4qB,oBAAoB,CAACG;AAAAA,EAC9B;AAAA,EACA7oB,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,EAAQ,MAAM,CACdmnB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,IACvC;AAAA,IACA8mB,WAAW;AAAA,EAAA,CACZ,CAAC,CACH;AAEL,CAAC,GAEKwR,sBAAsBnpB,eAAe;AAAA,EACzC7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACf4qB,UAAAA,mBAAmB1qB,oBAA8BF,QAAQ;AAG/D,WAF2BE,uBAA+BF,QAAQ,KAErC4qB,qBAAqBn1B;AAAAA,EACpD;AAAA,EACAyM,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,EAAQ,MAAM,CACdmnB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,IACvC;AAAA,IACA8mB,WAAW;AAAA,EAAA,CACZ,CAAC,CACH;AAEL,CAAC,GAEKyR,iCAAiCppB,eAAe;AAAA,EACpD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACxB4F,QAAAA,SAASrF,QAAQqJ,YAKnBhE,SAASrF,QAAQnE,aACjB,CAAC0J,uBAA+BF,QAAQ;AAEjC,aAAA;AAGH4qB,UAAAA,mBAAmB1qB,oBAA8B;AAAA,MAErDvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW4D,MAAMuC,SAASnG;AAAAA,MAAAA;AAAAA,IAC5B,CACD,GACKu0B,gBAAgB7qB,iBAA2B;AAAA,MAE/CvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW4D,MAAMuC,SAASnG;AAAAA,MAAAA;AAAAA,IAC5B,CACD;AAGC4D,WAAAA,MAAMuC,SAASpE,YACf6B,MAAMuC,SAASjJ,UAAU,WACzBk3B,oBACA,CAACG;AAAAA,EAEL;AAAA,EACA7oB,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,IAAU5F;AAAAA,EAAK,MAAM,CACrB+sB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIiE,MAAMuC,SAASnG;AAAAA,EACpB,CAAA,GACD2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,IACvC;AAAA,IACA8mB,WAAW;AAAA,IACXC,QAAQ;AAAA,EAAA,CACT,CAAC,CACH;AAEL,CAAC,GAEKyR,iCAAiCrpB,eAAe;AAAA,EACpD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACxB4F,QAAAA,SAASrF,QAAQqJ,YAKnBhE,SAASrF,QAAQnE,aACjB,CAAC0J,uBAA+BF,QAAQ;AAEjC,aAAA;AAGH4qB,UAAAA,mBAAmB1qB,oBAA8B;AAAA,MAErDvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW4D,MAAMuC,SAASnG;AAAAA,MAAAA;AAAAA,IAC5B,CACD,GACKq0B,YAAY3qB,aAAuB;AAAA,MAEvCvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW4D,MAAMuC,SAASnG;AAAAA,MAAAA;AAAAA,IAC5B,CACD;AAGC4D,WAAAA,MAAMuC,SAASpE,YACf6B,MAAMuC,SAASjJ,UAAU,SACzBk3B,oBACA,CAACC;AAAAA,EAEL;AAAA,EACA3oB,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,IAAU5F;AAAAA,EAAK,MAAM,CACrB+sB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIiE,MAAMuC,SAASnG;AAAAA,EACpB,CAAA,GACD2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,IACvC;AAAA,IACA8mB,WAAW;AAAA,IACXC,QAAQ;AAAA,EAAA,CACT,CAAC,CACH;AAEL,CAAC,GAEK0R,yCAAyCtpB,eAAe;AAAA,EAC5D7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACrB,UAAMoZ,iBAAiBlZ,kBAA4BF,QAAQ,GACrDorB,qBAAqBlrB,uBAA+BF,QAAQ,GAC5D+qB,gBAAgB7qB,iBAA2BF,QAAQ;AAEzD,WAAI,CAACoZ,kBAAkB,CAACgS,sBAAsB,CAACL,gBACtC,KAIPM,iBAAiBrrB,SAASrF,SAASye,eAAe3iB,IAAI,KACtD,CAAC2C,YAAY4G,SAASrF,SAASowB,cAAct0B,IAAI,IAE1C;AAAA,MAAC2iB;AAAAA,MAAgB2R;AAAAA,IAAAA,IAGnB;AAAA,EACT;AAAA,EACA7oB,SAAS,CACP,CAACwc,GAAG;AAAA,IAACtF;AAAAA,IAAgB2R;AAAAA,EAAa,MAAM,CACtC5D,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIijB,eAAeziB;AAAAA,EACpB,CAAA,GACDwwB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAI;AAAA,MACFwD,QAAQ;AAAA,QAAChD,MAAMo0B,cAAcp0B;AAAAA,QAAMkD,QAAQ;AAAA,MAAC;AAAA,MAC5CnD,OAAO;AAAA,QAACC,MAAMo0B,cAAcp0B;AAAAA,QAAMkD,QAAQ;AAAA,MAAA;AAAA,IAAC;AAAA,EAC7C,CACD,CAAC,CACH;AAEL,CAAC,GAEKyxB,0CAA0CzpB,eAAe;AAAA,EAC7D7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACrB,UAAMoZ,iBAAiBlZ,kBAA4BF,QAAQ,GACrDorB,qBAAqBlrB,uBAA+BF,QAAQ,GAC5D6qB,YAAY3qB,aAAuBF,QAAQ;AAEjD,WAAI,CAACoZ,kBAAkB,CAACgS,sBAAsB,CAACP,YACtC,KAIPQ,iBAAiBrrB,SAASrF,SAASye,eAAe3iB,IAAI,KACtD,CAAC2C,YAAY4G,SAASrF,SAASkwB,UAAUp0B,IAAI,IAEtC;AAAA,MAAC2iB;AAAAA,MAAgByR;AAAAA,IAAAA,IAGnB;AAAA,EACT;AAAA,EACA3oB,SAAS,CACP,CAACwc,GAAG;AAAA,IAACtF;AAAAA,IAAgByR;AAAAA,EAAS,MAAM,CAClC1D,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIijB,eAAeziB;AAAAA,EACpB,CAAA,GACDwwB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAI;AAAA,MACFwD,QAAQ;AAAA,QAAChD,MAAMk0B,UAAUl0B;AAAAA,QAAMkD,QAAQ;AAAA,MAAC;AAAA,MACxCnD,OAAO;AAAA,QAACC,MAAMk0B,UAAUl0B;AAAAA,QAAMkD,QAAQ;AAAA,MAAA;AAAA,IAAC;AAAA,EACzC,CACD,CAAC,CACH;AAEL,CAAC,GAEY0xB,2BAA2B;AAAA,EACtCZ;AAAAA,EACAG;AAAAA,EACAE;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAG;AACF,GCxRaE,yBAAyB;AAAA,EACpCC,gBAAgB5pB,eAAe;AAAA,IAC7B7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MACjB+uB,SAAS,SAAS/uB,MAAMgN,WAAW,KACnCpH,SAASrF,QAAQrC,OAAOiS,WAAW1R,KAChC2R,CAAcA,cAAAA,UAAU9X,SAAS,QACpC;AAAA,IACFwP,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,MAAChlB,MAAM;AAAA,MAAoBqI,WAAW;AAAA,IAAA,CAAS,CAAC,CAAC;AAAA,EAAA,CACzE;AAAA,EACDkhB,YAAY7pB,eAAe;AAAA,IACzB7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MACjB+uB,SAAS,SAAS/uB,MAAMgN,WAAW,KACnCpH,SAASrF,QAAQrC,OAAOiS,WAAW1R,KAChC2R,CAAcA,cAAAA,UAAU9X,SAAS,IACpC;AAAA,IACFwP,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,MAAChlB,MAAM;AAAA,MAAoBqI,WAAW;AAAA,IAAA,CAAK,CAAC,CAAC;AAAA,EAAA,CACrE;AAAA,EACDmhB,mBAAmB9pB,eAAe;AAAA,IAChC7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MACjB+uB,SAAS,SAAS/uB,MAAMgN,WAAW,KACnCpH,SAASrF,QAAQrC,OAAOiS,WAAW1R,KAChC2R,CAAcA,cAAAA,UAAU9X,SAAS,WACpC;AAAA,IACFwP,SAAS,CACP,MAAM,CAACilB,MAAM;AAAA,MAAChlB,MAAM;AAAA,MAAoBqI,WAAW;AAAA,IAAA,CAAY,CAAC,CAAC;AAAA,EAAA,CAEpE;AAAA,EACDohB,cAAc/pB,eAAe;AAAA,IAC3B7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MACjB+uB,SAAS,SAAS/uB,MAAMgN,WAAW,KACnCpH,SAASrF,QAAQrC,OAAOiS,WAAW1R,KAChC2R,CAAcA,cAAAA,UAAU9X,SAAS,MACpC;AAAA,IACFwP,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,MAAChlB,MAAM;AAAA,MAAoBqI,WAAW;AAAA,IAAA,CAAO,CAAC,CAAC;AAAA,EACvE,CAAA;AACH;AC3CO,SAASqhB,sBAAsB31B,OAA6B;AACjE,MAAIA,MAAMR,WAAW;AACnB,WAAO,IAAIo2B,QAAQ,GAAG,GAAG,GAAG,CAAC;AAG/B,QAAMC,WAAW71B,MAAMkT,OAAQ3S,CAAAA,SAASA,gBAAgB7B,OAAO,GAEzDo3B,YAAYD,SAAS51B,GAAG,CAAC,GAAGuF,sBAAsB;AAExD,MAAI,CAACswB;AACH,WAAO,IAAIF,QAAQ,GAAG,GAAG,GAAG,CAAC;AAG3BvD,MAAAA,OAAOyD,UAAUzD,MACjB3sB,MAAMowB,UAAUpwB,KAChBgtB,QAAQoD,UAAUpD,OAClB7sB,SAASiwB,UAAUjwB;AAEvB,WAAS6E,IAAI,GAAGA,IAAImrB,SAASr2B,QAAQkL,KAAK;AACxC,UAAMqrB,OAAOF,SAASnrB,CAAC,EAAElF,sBAAsB;AACxCQ,WAAAA,KAAKgwB,IAAI3D,MAAM0D,KAAK1D,IAAI,GAC/B3sB,MAAMM,KAAKgwB,IAAItwB,KAAKqwB,KAAKrwB,GAAG,GAC5BgtB,QAAQ1sB,KAAKiwB,IAAIvD,OAAOqD,KAAKrD,KAAK,GAClC7sB,SAASG,KAAKiwB,IAAIpwB,QAAQkwB,KAAKlwB,MAAM;AAAA,EAAA;AAGvC,SAAO,IAAI+vB,QAAQvD,MAAM3sB,KAAKgtB,QAAQL,MAAMxsB,SAASH,GAAG;AAC1D;ACrBO,MAAMwwB,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO9BvqB,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAUqsB;AAAAA,MAAKjyB;AAAAA,IAAAA,MAAW;AACjC,YAAM6F,gBAAgBF,iBAAiB;AAAA,QACrCC;AAAAA,QACAlF,gBAAgBV,MAAMuC,SAASnG;AAAAA,MAAAA,CAChC,GACK81B,wBAAwBpsB,wBAAkC;AAAA,QAE9DvF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWyJ;AAAAA,QAAAA;AAAAA,MAEd,CAAA,GACKssB,kBAAkB;AAAA,QACtBC,YAAYH,IAAII,cAAc;AAAA,UAC5B,GAAGzsB;AAAAA,UACHrF,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAWyJ;AAAAA,UAAAA;AAAAA,QACb,CACD;AAAA,QACDysB,YAAYL,IAAIM,cAAc;AAAA,UAC5B,GAAG3sB;AAAAA,UACHrF,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAWyJ;AAAAA,UAAAA;AAAAA,QAEd,CAAA;AAAA,MACH;AAEO,aAAA;AAAA,QACLA;AAAAA,QACAssB;AAAAA,QACAD;AAAAA,MACF;AAAA,IACF;AAAA,IACApqB,SAAS,CACP,CACE;AAAA,MAACmqB;AAAAA,MAAKjyB;AAAAA,IAAAA,GACN;AAAA,MAAC6F;AAAAA,MAAessB;AAAAA,MAAiBD;AAAAA,IAAAA,MAC9B;AACGM,YAAAA,YAAYnwB,SAASowB,cAAc,KAAK;AAE9C,UAAIP,uBAAuB;AAEnBQ,cAAAA,mBAAmBP,gBAAgBC,WAAW/4B,IAAKgD,UACvDA,KAAKs2B,UAAU,EAAI,CACrB;AAEA,mBAAWr5B,SAASo5B;AACdp5B,2BAAiBs5B,gBACnBt5B,MAAMM,MAAM2I,WAAW,aAEzBiwB,UAAUK,YAAYv5B,KAAK;AAIvBw5B,cAAAA,cAAcN,UAAUO,cAC5B,8BACF;AACID,YAAAA,eACFN,UAAUQ,gBAAgBF,WAAW,GAIvCN,UAAUS,aAAa,gBAAgB,EAAE,GAEzCT,UAAU54B,MAAM2I,WAAW,YAC3BiwB,UAAU54B,MAAMu0B,OAAO,YACvBqE,UAAU54B,MAAMs5B,YAAY,cAC5B7wB,SAAS8wB,KAAKN,YAAYL,SAAS,GAE/BM,aAAa;AACf,gBAAMM,kBAAkBN,YAAYxxB,sBAAsB,GACpD+xB,IAAIrzB,MAAMgN,YAAYxK,UAAU4wB,gBAAgBjF,MAChDmF,IAAItzB,MAAMgN,YAAYvK,UAAU2wB,gBAAgB5xB;AACtDgxB,iBAAAA,UAAU54B,MAAMwL,QAAQ,GAAGguB,gBAAgBhuB,KAAK,MAChDotB,UAAU54B,MAAMiI,SAAS,GAAGuxB,gBAAgBvxB,MAAM,MAE3C,CACLkrB,MAAM;AAAA,YACJhlB,MAAM;AAAA,YACNhM,IAAI8J;AAAAA,UAAAA,CACL,GACDmC,OAAO,MAAM;AACXiqB,gBAAIsB,aAAa;AAAA,cACfvzB;AAAAA,cACAwzB,OAAO;AAAA,gBACLl1B,SAASk0B;AAAAA,gBACTa;AAAAA,gBACAC;AAAAA,cAAAA;AAAAA,YACF,CACD;AAAA,UAAA,CACF,GACDnrB,QAAQnI,KAAK,CAAC;AAAA,QAAA,OAEX;AACL,gBAAMyzB,gBAAgBhC,sBACpBU,gBAAgBC,UAClB,GACMiB,IAAIrzB,MAAMgN,YAAYxK,UAAUixB,cAActF,MAC9CmF,IAAItzB,MAAMgN,YAAYvK,UAAUgxB,cAAcjyB;AACpDgxB,iBAAAA,UAAU54B,MAAMwL,QAAQ,GAAGquB,cAAcruB,KAAK,MAC9CotB,UAAU54B,MAAMiI,SAAS,GAAG4xB,cAAc5xB,MAAM,MAEzC,CACLkrB,MAAM;AAAA,YACJhlB,MAAM;AAAA,YACNhM,IAAI8J;AAAAA,UAAAA,CACL,GACDmC,OAAO,MAAM;AACXiqB,gBAAIsB,aAAa;AAAA,cACfvzB;AAAAA,cACAwzB,OAAO;AAAA,gBAACl1B,SAASk0B;AAAAA,gBAAWa;AAAAA,gBAAGC;AAAAA,cAAAA;AAAAA,YAAC,CACjC;AAAA,UAAA,CACF,GACDnrB,QAAQnI,KAAK,CAAC;AAAA,QAAA;AAAA,MAElB,OACK;AACC0zB,cAAAA,mBAAmBvB,gBAAgBG,WAAWj5B,IAAKgD,UACvDA,KAAKs2B,UAAU,EAAI,CACrB;AAEA,mBAAW14B,SAASy5B;AAClBlB,oBAAUK,YAAY54B,KAAK;AAG7Bu4B,kBAAU54B,MAAM2I,WAAW,YAC3BiwB,UAAU54B,MAAMu0B,OAAO,YACvBqE,UAAU54B,MAAMs5B,YAAY,cAC5B7wB,SAAS8wB,KAAKN,YAAYL,SAAS;AAEnC,cAAMmB,kBAAkBlC,sBACtBU,gBAAgBG,UAClB,GACMe,IAAIrzB,MAAMgN,YAAYxK,UAAUmxB,gBAAgBxF,MAChDmF,IAAItzB,MAAMgN,YAAYvK,UAAUkxB,gBAAgBnyB;AACtDgxB,eAAAA,UAAU54B,MAAMwL,QAAQ,GAAGuuB,gBAAgBvuB,KAAK,MAChDotB,UAAU54B,MAAMiI,SAAS,GAAG8xB,gBAAgB9xB,MAAM,MAE3C,CACLkrB,MAAM;AAAA,UACJhlB,MAAM;AAAA,UACNhM,IAAI8J;AAAAA,QAAAA,CACL,GACDmC,OAAO,MAAM;AACXiqB,cAAIsB,aAAa;AAAA,YACfvzB;AAAAA,YACAwzB,OAAO;AAAA,cAACl1B,SAASk0B;AAAAA,cAAWa;AAAAA,cAAGC;AAAAA,YAAAA;AAAAA,UAAC,CACjC;AAAA,QAAA,CACF,GACDnrB,QAAQnI,KAAK,CAAC;AAAA,MAAA;AAAA,IAGnB,CAAA;AAAA,EAAA,CAEJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAC5B,YAAM4H,aAAa5H,MAAM4H;AAWzB,aAV+BA,aAC3B9B,uBAAiC9F,MAAMuC,SAASnG,SAAS,EAAE;AAAA,QACzD,GAAGwJ;AAAAA,QACHrF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWwL,WAAWxL;AAAAA,QAAAA;AAAAA,MAEzB,CAAA,IACD;AAAA,IAGN;AAAA,IACA0L,SAAS,CAAA;AAAA,EAAA,CACV;AAAA;AAAA;AAAA;AAAA;AAAA,EAMDL,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAC5B,YAAM4H,aAAa5H,MAAM4H,YACnBgsB,eAAe5zB,MAAMuC,SAASnG;AAUpC,aAT6BwL,aACzB9B,uBAAiC8tB,YAAY,EAAE;AAAA,QAC7C,GAAGhuB;AAAAA,QACHrF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWwL,WAAWxL;AAAAA,QAAAA;AAAAA,MAEzB,CAAA,IACD;AAAA,IAEN;AAAA,IACA0L,SAAS,CAAA;AAAA,EAAA,CACV;AAAA;AAAA;AAAA;AAAA;AAAA,EAKDL,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC1H;AAAAA,IAAAA,MAAWA,MAAM4H,eAAevM;AAAAA,IACzCyM,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA;AAAA;AAAA;AAAA,EAIDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAIiE,MAAMuC,SAASnG;AAAAA,IACpB,CAAA,GACD2wB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AAC5B,UACEA,MAAMgN,YAAYjF,SAAS,eAC3B/H,MAAMgN,YAAYpF,eAAevM;AAE1B,eAAA;AAGT,YAAMuM,aAAa5H,MAAMgN,YAAYpF,YAC/B/B,gBAAgBF,iBAAiB;AAAA,QACrCjF,gBAAgBkH,WAAWxL;AAAAA,QAC3BwJ;AAAAA,MACD,CAAA,GACKguB,eAAe5zB,MAAMgN,YAAYzK,SAASnG,WAC1Cy3B,uBAAuBjsB,aACzB9B,uBAAiC8tB,YAAY,EAAE;AAAA,QAC7C,GAAGhuB;AAAAA,QACHrF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWyJ;AAAAA,QAAAA;AAAAA,MACb,CACD,IACD,IAEEiuB,uBAAuBhuB,wBAAkC;AAAA,QAE7DvF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWyJ;AAAAA,QAAAA;AAAAA,MACb,CACD,GAEKkuB,gBAAgBjuB,kBAA4B;AAAA,QAEhDvF,SAAS;AAAA,UACP,GAAGqF,SAASrF;AAAAA,UACZnE,WAAWyJ;AAAAA,QAAAA;AAAAA,MACb,CACD;AAED,aAAKguB,uBAUE,KATE;AAAA,QACLD;AAAAA,QACAE;AAAAA,QACAC;AAAAA,QACAnsB;AAAAA,QACAoF,aAAahN,MAAMgN;AAAAA,MACrB;AAAA,IAIJ;AAAA,IACAlF,SAAS,CACP,CACE;AAAA,MAAC9H;AAAAA,IAAAA,GACD;AAAA,MACE8zB;AAAAA,MACAC;AAAAA,MACAnsB;AAAAA,MACAgsB;AAAAA,MACA5mB;AAAAA,IAAAA,MAEC,CACH,GAAI8mB,uBACAC,cAAc16B,IAAKC,WACjByzB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAIzC,MAAMiD;AAAAA,IAAAA,CACX,CACH,IACA,CACEwwB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAI6L,WAAWxL;AAAAA,IAAAA,CAChB,CAAC,GAER2wB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAI63B;AAAAA,IACL,CAAA,GACD7G,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNqF,QAAQpN,MAAMsN;AAAAA,MACd8R,WAAW0U,uBACP9mB,YAAYzK,SAASjJ,UAAU,UAC7B,WACA0T,YAAYzK,SAASjJ,UAAU,QAC7B,UACA,SACJ;AAAA,IAAA,CACL,CAAC,CACH;AAAA,EAEJ,CAAA;AAAC,GC3VE06B,8BAA8BvsB,eAAe;AAAA,EACjD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACfoZ,UAAAA,iBAAiBlZ,kBAA4BF,QAAQ,GACrDorB,qBAAqBlrB,uBAA+BF,QAAQ;AAElE,QAAI,CAACA,SAASrF,QAAQnE,aAAa,CAAC4iB,kBAAkB,CAACgS;AAC9C,aAAA;AAGT,UAAMiD,kBACJnuB,kBAA4BkZ,cAAc,EAAEpZ,QAAQ,GAEhDsuB,gBAAgBlV,eAAe3iB,KAAKyC,UACpCq1B,aAAanV,eAAe3iB,KAAK4O;AAEvC,WAAIgpB,kBACK;AAAA,MAACC;AAAAA,MAAeC;AAAAA,IAAAA,IAGlB;AAAA,EACT;AAAA,EACArsB,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,EAAAA,GAAW;AAAA,IAACsuB;AAAAA,IAAeC;AAAAA,EAAU,MAAM,CAC3CpH,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,MACrC0B,UAAU,CACR;AAAA,QACET,OAAOqM,SAASrF,QAAQrC,OAAO0Q,KAAKtW;AAAAA,QACpC+B,MAAM;AAAA,QACNC,OAAO,CAAA;AAAA,MAAA,CACR;AAAA,MAEHR,UAAU,CAAE;AAAA,MACZgF,UAAUo1B;AAAAA,MACVjpB,OAAOkpB;AAAAA,MACPv6B,OAAOgM,SAASrF,QAAQrC,OAAOxD,OAAO,CAAC,GAAGpC;AAAAA,IAC5C;AAAA,IACA8mB,WAAW;AAAA,EAAA,CACZ,CAAC,CACH;AAEL,CAAC,GAEKgV,gCAAgC3sB,eAAe;AAAA,EACnD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACfoZ,UAAAA,iBAAiBlZ,kBAA4BF,QAAQ,GACrDorB,qBAAqBlrB,uBAA+BF,QAAQ;AAElE,QAAI,CAACA,SAASrF,QAAQnE,aAAa,CAAC4iB,kBAAkB,CAACgS;AAC9C,aAAA;AAGHpgB,UAAAA,YAAY9K,eAAuBF,QAAQ,GAE3CyuB,kBAAkBzjB,WAAWvU,KAAK/B,OAAO0U,OAC5CkB,CAAAA,SACCtK,SAASrF,QAAQrC,OAAOiS,WAAW1R,KAChC2R,CAAcA,cAAAA,UAAU9X,SAAS4X,IACpC,KAAK,CACT,CAAA,GACMokB,mBACJ1jB,WAAWvU,KAAK/B,OAAO0U,OACpBkB,CACC,SAAA,CAACtK,SAASrF,QAAQrC,OAAOiS,WAAW1R,KACjC2R,CAAcA,cAAAA,UAAU9X,SAAS4X,IACpC,CACJ,KAAK,CACDgkB,GAAAA,gBAAgBlV,eAAe3iB,KAAKyC,UACpCq1B,aAAanV,eAAe3iB,KAAK4O;AAKvC,WAFEnF,oBAA8BkZ,cAAc,EAAEpZ,QAAQ,IAG/C;AAAA,MAAC0uB;AAAAA,MAAkBD;AAAAA,MAAiBH;AAAAA,MAAeC;AAAAA,IAAAA,IAGrD;AAAA,EACT;AAAA,EACArsB,SAAS,CACP,CACE;AAAA,IAAClC;AAAAA,EAAAA,GACD;AAAA,IAAC0uB;AAAAA,IAAkBD;AAAAA,IAAiBH;AAAAA,IAAeC;AAAAA,EAAU,MAC1D,CACHpH,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,MACrC0B,UAAU,CACR;AAAA,QACET,OAAOqM,SAASrF,QAAQrC,OAAO0Q,KAAKtW;AAAAA,QACpCgC,OAAOg6B,iBAAiBh5B,WAAW,IAAI+4B,kBAAkB,CAAE;AAAA,QAC3Dh6B,MAAM;AAAA,MAAA,CACP;AAAA,MAEHyE,UAAUo1B;AAAAA,MACVjpB,OAAOkpB;AAAAA,MACPv6B,OAAOgM,SAASrF,QAAQrC,OAAOxD,OAAO,CAAC,GAAGpC;AAAAA,IAC5C;AAAA,IACA8mB,WAAW;AAAA,IACXC,QAAQ;AAAA,EAAA,CACT,CAAC,CACH;AAEL,CAAC,GAEKkV,yBAAyB9sB,eAAe;AAAA,EAC5C7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AAKrB,QAJI,CAACA,SAASrF,QAAQnE,aAIlB,CAAC0J,oBAA8BF,QAAQ;AAClC,aAAA;AAGHzE,UAAAA,aAAa2E,gBAAwBF,QAAQ,GAC7CnE,YAAYqE,eAAuBF,QAAQ;AAE7C,QAAA,CAACzE,cAAc,CAACM;AACX,aAAA;AAGH+yB,UAAAA,uBAAuB5zB,mBAAyB;AAAA,MACpDL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO6H;AAAAA,IAAAA,CACR,GACKtE,sBAAsB+D,uBAC1BgF,SAASrF,QAAQnE,SACnB,GACMq4B,oBAAoB7zB,iBAAuB;AAAA,MAC/CL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAOmI;AAAAA,IACR,CAAA,GACKtE,oBAAoByD,qBACxBgF,SAASrF,QAAQnE,SACnB;AAGEwE,WAAAA,uBAA6B4zB,sBAAsB33B,mBAAmB,KACtE+D,uBAA6B6zB,mBAAmBt3B,iBAAiB,IAE1D;AAAA,MAACf,WAAWwJ,SAASrF,QAAQnE;AAAAA,IAAAA,IAG/B;AAAA,EACT;AAAA,EACA0L,SAAS,CACP,CAACwc,GAAG;AAAA,IAACloB;AAAAA,EAAS,MAAM,CAClB2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIK;AAAAA,EAAAA,CACL,CAAC,CACH;AAEL,CAAC,GAEKs4B,uBAAuBjtB,eAAe;AAAA,EAC1C7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AAKrB,QAJI,CAACA,SAASrF,QAAQnE,aAIlB,CAAC0J,oBAA8BF,QAAQ;AAClC,aAAA;AAGT,UAAM7G,iBAAiB+G,kBAA4BF,QAAQ,GACrDM,sBAAsBJ,yBAAiCF,QAAQ,GAC/DO,oBAAoBL,uBAA+BF,QAAQ;AAE7D,QAAA,CAACM,uBAAuB,CAACC;AACpB,aAAA;AAGHwuB,UAAAA,uBAAuB/zB,mBAAyB;AAAA,MACpDL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO4M;AAAAA,IAAAA,CACR,GACKrJ,sBAAsB+D,uBAC1BgF,SAASrF,QAAQnE,SACnB,GACM2jB,mBAAmBnf,iBAAuB;AAAA,MAC9CL,SAASqF,SAASrF;AAAAA,MAClBjH,OAAO6M;AAAAA,IACR,CAAA,GACKhJ,oBAAoByD,qBACxBgF,SAASrF,QAAQnE,SACnB;AAGEwE,WAAAA,uBAA6B/D,qBAAqB83B,oBAAoB,KACtE/zB,uBAA6BzD,mBAAmB4iB,gBAAgB,IAEzD;AAAA,MAAChhB;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACA+I,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,EAAAA,GAAW;AAAA,IAAC7G;AAAAA,EAAc,MAAM,CAChCguB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO;AAAA,MACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,MACrC0B,UAAU,CACR;AAAA,QACET,OAAOqM,SAASrF,QAAQrC,OAAO0Q,KAAKtW;AAAAA,QACpC+B,MAAM;AAAA,QACNC,OAAO,CAAA;AAAA,MACR,CAAA;AAAA,IAEL;AAAA,IACA8kB,WAAW;AAAA,IACXC,QAAQ;AAAA,EACT,CAAA,GACD,GAAGtgB,eAAe1F,IAAKC,WACrByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIzC,MAAMiD;AAAAA,EACX,CAAA,CACH,CAAC,CACF;AAEL,CAAC,GAEYq4B,2BAA2B;AAAA,EACtCZ;AAAAA,EACAI;AAAAA,EACAG;AAAAA,EACAG;AACF,GC3OMG,iBAAiB,IAEjBC,uBAAuBrtB,eAAe;AAAA,EAC1C7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACrB,UAAMorB,qBAAqBlrB,uBAA+BF,QAAQ,GAC5DoZ,iBAAiBlZ,kBAA4BF,QAAQ,GACrDgL,YAAY9K,eAAuBF,QAAQ;AAE7C,WAAA,CAACorB,sBAAsB,CAAChS,kBAAkB,CAACpO,YACtC,KAIPoO,eAAe3iB,KAAKrC,SAAS,CAAC,EAAEjB,SAAS6X,UAAUvU,KAAKtD,QACxD6M,SAASrF,QAAQnE,WAAWE,MAAMmD,WAAW,KAElBuf,eAAe3iB,KAAK4O,UAAU,IAClD;AAAA,MAAC+T;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACAlX,SAAS,CACP,CAACwc,GAAG;AAAA,IAACtF;AAAAA,EAAc,MAAM,CACvB+N,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNxQ,OAAO,CAAC,YAAY,OAAO;AAAA,IAC3BwE,IAAIijB,eAAeziB;AAAAA,EAAAA,CACpB,CAAC,CACH;AAEL,CAAC,GAEKw4B,0BAA0BttB,eAAe;AAAA,EAC7C7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACrB,UAAMorB,qBAAqBlrB,uBAA+BF,QAAQ,GAC5DoZ,iBAAiBlZ,kBAA4BF,QAAQ,GACrDgL,YAAY9K,eAAuBF,QAAQ;AAEjD,WAAI,CAACorB,sBAAsB,CAAChS,kBAAkB,CAACpO,YACtC,KAIPoO,eAAe3iB,KAAKrC,SAAS,CAAC,EAAEjB,SAAS6X,UAAUvU,KAAKtD,QACxD6M,SAASrF,QAAQnE,WAAWE,MAAMmD,WAAW,KAI7Cuf,eAAe3iB,KAAK4O,UAAU5P,UAC9B2jB,eAAe3iB,KAAK4O,QAAQ,IAErB;AAAA,MAAC+T;AAAAA,MAAgB/T,OAAO+T,eAAe3iB,KAAK4O,QAAQ;AAAA,IAAA,IAGtD;AAAA,EACT;AAAA,EACAnD,SAAS,CACP,CAACwc,GAAG;AAAA,IAACtF;AAAAA,IAAgB/T;AAAAA,EAAK,MAAM,CAC9B8hB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNxQ,OAAO;AAAA,MAAC0T;AAAAA,IAAK;AAAA,IACblP,IAAIijB,eAAeziB;AAAAA,EAAAA,CACpB,CAAC,CACH;AAEL,CAAC,GAEKy4B,mBAAmBvtB,eAAe;AAAA,EACtC7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACforB,UAAAA,qBAAqBlrB,uBAA+BF,QAAQ,GAC5DqvB,iBAAiBnvB,kBAA4BF,QAAQ;AAGzD,WAAA,CAACorB,sBACD,CAACiE,kBACD,CAAChE,iBAAiBrrB,SAASrF,SAAS00B,eAAe54B,IAAI,IAEhD,KAGF;AAAA,MAAC44B;AAAAA,IAAc;AAAA,EACxB;AAAA,EACAntB,SAAS,CACP,CAACwc,GAAG;AAAA,IAAC2Q;AAAAA,EAAc,MAAM,CACvBlI,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNxQ,OAAO,CAAC,YAAY,OAAO;AAAA,IAC3BwE,IAAIk5B,eAAe14B;AAAAA,EAAAA,CACpB,CAAC,CACH;AAEL,CAAC,GAEK24B,kBAAkBztB,eAAe;AAAA,EACrC7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAG5B,QAAI,CAFU+uB,SAAS,OAAO/uB,MAAMgN,WAAW;AAGtC,aAAA;AAGT,UAAMjO,iBAAiB+G,kBAA4BF,QAAQ,GACrDuvB,qBAAqBp2B,eAAe4O,QAASrU,CAAAA,UACjD4F,YAAY0G,SAASrF,SAASjH,MAAM+C,IAAI,IACpC,CACE;AAAA,MACEA,MAAM/C,MAAM+C;AAAAA,MACZE,MAAMjD,MAAMiD;AAAAA,IACb,CAAA,IAEH,CAAA,CACN;AAEI44B,WAAAA,mBAAmB75B,WAAWyD,eAAezD,SACxC;AAAA,MAAC65B;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACArtB,SAAS,CACP,CAACwc,GAAG;AAAA,IAAC6Q;AAAAA,EACHA,MAAAA,mBAAmB97B,IAAK+7B,CAAAA,sBACtBrI,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNxQ,OAAO;AAAA,MACL0T,OAAOnJ,KAAKgwB,IACV+C,gBACA/yB,KAAKiwB,IAAI,GAAGqD,kBAAkB/4B,KAAK4O,QAAQ,CAAC,CAC9C;AAAA,IACF;AAAA,IACAlP,IAAIq5B,kBAAkB74B;AAAAA,EAAAA,CACvB,CACH,CAAC;AAEP,CAAC,GAEK84B,yBAAyB5tB,eAAe;AAAA,EAC5C7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAG5B,QAAI,CAFe+uB,SAAS,aAAa/uB,MAAMgN,WAAW;AAGjD,aAAA;AAGT,UAAMjO,iBAAiB+G,kBAA4BF,QAAQ,GACrDuvB,qBAAqBp2B,eAAe4O,QAASrU,CAAAA,UACjD4F,YAAY0G,SAASrF,SAASjH,MAAM+C,IAAI,IACpC,CACE;AAAA,MACEA,MAAM/C,MAAM+C;AAAAA,MACZE,MAAMjD,MAAMiD;AAAAA,IACb,CAAA,IAEH,CAAA,CACN;AAEI44B,WAAAA,mBAAmB75B,WAAWyD,eAAezD,SACxC;AAAA,MAAC65B;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACArtB,SAAS,CACP,CAACwc,GAAG;AAAA,IAAC6Q;AAAAA,EACHA,MAAAA,mBAAmB97B,IAAK+7B,CAAAA,sBACtBrI,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNxQ,OAAO;AAAA,MACL0T,OAAOnJ,KAAKgwB,IACV+C,gBACA/yB,KAAKiwB,IAAI,GAAGqD,kBAAkB/4B,KAAK4O,QAAQ,CAAC,CAC9C;AAAA,IACF;AAAA,IACAlP,IAAIq5B,kBAAkB74B;AAAAA,EAAAA,CACvB,CACH,CAAC;AAEP,CAAC,GAEY+4B,oBAAoB;AAAA,EAC/BR;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAE;AAAAA,EACAG;AACF,GC9LaE,sBAAsB,CACjCvI,wBAAwBH,mCACxBuE,uBAAuBC,gBACvBD,uBAAuBE,YACvBF,uBAAuBG,mBACvBH,uBAAuBI,cACvB,GAAGQ,kBACHb,yBAAyBN,gCACzBM,yBAAyBL,gCACzBK,yBAAyBZ,8BACzBY,yBAAyBT,4BACzBS,yBAAyBP,qBACzBO,yBAAyBJ,wCACzBI,yBAAyBD,yCACzBoE,kBAAkBR,sBAClBQ,kBAAkBP,yBAClBO,kBAAkBN,kBAClBM,kBAAkBJ,iBAClBI,kBAAkBD,wBAClBT,yBAAyBZ,6BACzBY,yBAAyBR,+BACzBQ,yBAAyBL,wBACzBK,yBAAyBF,oBAAoB,EAC7Cr7B,IAAKmO,CAAc,cAAA;AAAA,EACnBA;AAAAA,EACAS,UAAUb;AACZ,EAAE;ACNcouB,SAAAA,gBACdC,UACA11B,aACW;AACJ,SAAA;AAAA,IACLsyB,eAAgBzsB,CAAAA,aAAaysB,cAActyB,aAAa6F,QAAQ;AAAA,IAChE2sB,eAAgB3sB,CAAAA,aAAa2sB,cAAcxyB,aAAa6F,QAAQ;AAAA,IAChE2tB,cAAcA,CAAC;AAAA,MAACvzB;AAAAA,MAAOwzB;AAAAA,UAAWD,aAAa;AAAA,MAACkC;AAAAA,MAAUz1B;AAAAA,MAAOwzB;AAAAA,IAAM,CAAA;AAAA,EACzE;AACF;AAEA,SAASnB,cACPtyB,aACA6F,UACA;AACI,MAAA,CAACA,SAASrF,QAAQnE;AACpB,WAAO,CAAE;AAGX,QAAMiD,QAAQ4D,aAAa2C,SAASrF,QAAQnE,WAAW2D,WAAW;AAElE,SAAKV,QAIgBlG,MAAMyC,KACzBC,OAAOC,MAAMiE,aAAa;AAAA,IACxBhE,IAAIsD;AAAAA,IACJb,MAAM;AAAA,IACNxC,OAAQC,CAAAA,MAAM,CAACJ,OAAOsC,SAASlC,CAAC;AAAA,EACjC,CAAA,CACH,EAEoB5C,IAAI,CAAC,CAAC8qB,SAAS,MACjCpjB,UAAUM,UAAUtB,aAAaokB,SAAS,CAC5C,IAbS,CAAE;AAcb;AAEA,SAASoO,cACPxyB,aACA6F,UACA;AACI,MAAA,CAACA,SAASrF,QAAQnE;AACpB,WAAO,CAAE;AAGX,QAAMiD,QAAQ4D,aAAa2C,SAASrF,QAAQnE,WAAW2D,WAAW;AAElE,SAAKV,QAIgBlG,MAAMyC,KACzBC,OAAOC,MAAMiE,aAAa;AAAA,IACxBhE,IAAIsD;AAAAA,IACJb,MAAM;AAAA,IACNxC,OAAQC,CAAAA,MAAM,CAACJ,OAAOsC,SAASlC,CAAC;AAAA,EACjC,CAAA,CACH,EAEoB5C,IAAI,CAAC,CAACq8B,SAAS,MACjC30B,UAAUM,UAAUtB,aAAa21B,SAAS,CAC5C,IAbS,CAAE;AAcb;AA0DA,SAASnC,aAAa;AAAA,EACpBkC;AAAAA,EACAz1B;AAAAA,EACAwzB;AASF,GAAG;AACKxmB,QAAAA,YAAY2U,aAAagU,aAAanC,MAAMl1B,SAASk1B,MAAMH,GAAGG,MAAMF,CAAC,GAE3EmC,SAAS;AAAA,IACP1tB,MAAM;AAAA,IACNyrB,OAAOA,MAAMl1B;AAAAA,EAAAA,CACd;AACH;ACpKas3B,MAAAA,8BAA8B,CACzCnuB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,QACjB61B,mBAAmB71B,MAAMmV,WAAW7c,IAAI,EAAEsN,QAAQ;AAAA,EACpDkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAqBoN,YAAYnV,MAAMmV;AAAAA,EAAAA,CAAW,CAAC,CACjE;AAEL,CAAC,GACD1N,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MACjB,CAAC61B,mBAAmB71B,MAAMmV,WAAW7c,IAAI,EAAEsN,QAAQ;AAAA,EACrDkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAkBoN,YAAYnV,MAAMmV;AAAAA,EAAAA,CAAW,CAAC,CAC9D;AAEL,CAAC,CAAC,GCnBS2gB,6BAA6B,CACxCruB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAW+1B,MAAAA,kBAAkB/1B,MAAMoQ,SAAS,EAAExK,QAAQ;AAAA,EACzEkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAoBqI,WAAWpQ,MAAMoQ;AAAAA,EAAAA,CAAU,CAAC,CAC9D;AAEL,CAAC,GACD3I,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACtByd,UAAAA,kBAAkBzd,MAAMjE,KAC1Bi6B,wBAAwB;AAAA,MACtBz1B,SAASqF,SAASrF;AAAAA,MAClByd,SAAShe,MAAMjE;AAAAA,IAChB,CAAA,IACD;AAEJ,WAAI0hB,kBACK,CAACsY,kBAAkB/1B,MAAMoQ,SAAS,EAAE;AAAA,MACzC,GAAGxK;AAAAA,MACHrF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAWqhB;AAAAA,MAAAA;AAAAA,IAEd,CAAA,IAGI,CAACsY,kBAAkB/1B,MAAMoQ,SAAS,EAAExK,QAAQ;AAAA,EACrD;AAAA,EACAkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IACJ,GAAG/sB;AAAAA,IACH+H,MAAM;AAAA,EAAA,CACP,CAAC,CACH;AAEL,CAAC,CAAC,GCxCSkuB,0BAA0B,CACrCxuB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MACFA,SAASrF,QAAQnE,YAIf;AAAA,IAACA,WAAWwJ,SAASrF,QAAQnE;AAAAA,EAAAA,IAH3B;AAAA,EAKX0L,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAAC5D;AAAAA,EAAS,MAAM,CACxB2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNwV,WAAW;AAAA,IACXqB,MAAM5e,MAAM4e;AAAAA,IACZ7iB,IAAIK;AAAAA,EAAAA,CACL,CAAC,CACH;AAEL,CAAC,GACDqL,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MACFA,SAASrF,QAAQnE,YAIf;AAAA,IAACA,WAAWwJ,SAASrF,QAAQnE;AAAAA,EAAAA,IAH3B;AAAA,EAKX0L,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAAC5D;AAAAA,EAAS,MAAM,CACxB2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNwV,WAAW;AAAA,IACXqB,MAAM5e,MAAM4e;AAAAA,IACZ7iB,IAAIK;AAAAA,EAAAA,CACL,CAAC,CACH;AAEL,CAAC,GACDqL,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJkQ,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAI;AAAA,MACFwD,QAAQ;AAAA,QACNhD,MAAMyD,MAAMjE;AAAAA,QACZ0D,QAAQ;AAAA,MACV;AAAA,MACAnD,OAAO;AAAA,QACLC,MAAMyD,MAAMjE;AAAAA,QACZ0D,QAAQ;AAAA,MAAA;AAAA,IACV;AAAA,EACF,CACD,CAAC,CACH;AAEL,CAAC,GACDgI,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACtB5D,UAAAA,YAAYwE,wBAA8B;AAAA,MAC9CL,SAASqF,SAASrF;AAAAA,MAClByd,SAAShe,MAAMjE;AAAAA,IAAAA,CAChB;AAED,QAAI,CAACK;AACI,aAAA;AAGH6hB,UAAAA,mBAAmBnY,oBAA8B;AAAA,MAKrDvF,SAAS;AAAA,QACPuM,YAAY,CAAE;AAAA,QACd5O,QAAQ0H,SAASrF,QAAQrC;AAAAA,QACzBuQ,cAAc7I,SAASrF,QAAQkO;AAAAA,QAC/B7E,UAAU;AAAA,QACV9Q,OAAO8M,SAASrF,QAAQzH;AAAAA,QACxBsD;AAAAA,MAAAA;AAAAA,IACF,CACD;AAED,WAAK6hB,mBAIE;AAAA,MACL7hB,WAAW6hB;AAAAA,IAAAA,IAJJ;AAAA,EAMX;AAAA,EACAnW,SAAS,CAAC,CAACwc,GAAG;AAAA,IAACloB;AAAAA,EAAS,MAAM,CAAC2wB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAUhM,IAAIK;AAAAA,EAAAA,CAAU,CAAC,CAAC;AACxE,CAAC,CAAC,GCjGS85B,0BAA0B,CACrCzuB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC1H;AAAAA,EAAAA,MAAWA,MAAMof,cAAc;AAAA,EACxCtX,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,MACAA,MAAMoN,OAAO/T,IAAI,CAACC,OAAOyhB,UACvBgS,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAWrE,UAAU,IAAI,WAAW;AAAA,IACpCsE,QAAQrf,MAAMqf,UAAU;AAAA,EAAA,CACzB,CACH,CAAC;AAEP,CAAC,GACD5X,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC1H;AAAAA,EAAAA,MAAWA,MAAMof,cAAc;AAAA,EACxCtX,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EACAA,MAAAA,MAAMoN,OAAO/T,IAAKC,WAChByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAW;AAAA,IACXC,QAAQrf,MAAMqf,UAAU;AAAA,EAAA,CACzB,CACH,CAAC;AAEP,CAAC,GACD5X,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC5B,QAAIA,MAAMof,cAAc;AACf,aAAA;AAGHJ,UAAAA,iBAAiBmX,kBAAkBvwB,QAAQ;AAEjD,WAAKoZ,iBAIE;AAAA,MAACA;AAAAA,IAAAA,IAHC;AAAA,EAIX;AAAA,EACAlX,SAAS,CACP,CAAC;AAAA,IAAClC;AAAAA,IAAU5F;AAAAA,EAAAA,GAAQ;AAAA,IAACgf;AAAAA,QACnBhf,MAAMoN,OAAO9R,WAAW,IACpB,CACEyxB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAO0G,MAAMoN,OAAO,CAAC;AAAA,IACrBgS,WAAW;AAAA,IACXC,QAAQrf,MAAMqf,UAAU;AAAA,EACzB,CAAA,CAAC,IAEJ4R,iBAAiBrrB,SAASrF,SAASye,eAAe3iB,IAAI,IACpD2D,MAAMoN,OAAO/T,IAAI,CAACC,OAAOyhB,UACvBgS,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAWrE,UAAU,IAAI,SAAS;AAAA,IAClCsE,QAAQrf,MAAMqf,UAAU;AAAA,EACzB,CAAA,CACH,IACArf,MAAMoN,OAAOO,QAAQ,CAACrU,OAAOyhB,UAC3BA,UAAU,IACN,CACEgS,MAAM;AAAA,IACJhlB,MAAM;AAAA,EACP,CAAA,GACDglB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNsX,QAAQ;AAAA,EACT,CAAA,GACD0N,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAW;AAAA,IACXC,QAAQrf,MAAMqf,UAAU;AAAA,EAAA,CACzB,CAAC,IAEJtE,UAAU/a,MAAMoN,OAAO9R,SAAS,IAC9B,CACEyxB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNsX,QAAQ;AAAA,EACT,CAAA,GACD0N,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAW;AAAA,IACXC,QAAQrf,MAAMqf,UAAU;AAAA,EAAA,CACzB,CAAC,IAEJ,CACE0N,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAW;AAAA,IACXC,QAAQrf,MAAMqf,UAAU;AAAA,EACzB,CAAA,CAAC,CAEZ,CAAC;AAEb,CAAC,GACD5X,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC1H;AAAAA,EAAAA,MAAWA,MAAMof,cAAc;AAAA,EACxCtX,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,MACAA,MAAMoN,OAAO/T,IAAI,CAACC,OAAOyhB,UACvBgS,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO;AAAAA,IACA8lB,WAAWrE,UAAU,IAAI,SAAS;AAAA,IAClCsE,QAAQrf,MAAMqf,UAAU;AAAA,EAAA,CACzB,CACH,CAAC;AAEP,CAAC,GACD5X,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJkQ,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,IAAChlB,MAAM;AAAA,EAAA,CAAQ,CAAC,CAAC;AAC1C,CAAC,GACDN,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJkQ,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAe1N,MAAM;AAAA;AAAA,EAAA,CAAK,CAAC,CAAC;AAC5D,CAAC,CAAC,GCtIS+7B,QAAQ;AAAA,EACnBC,WAAYr2B,CAAAA,UAAUA,MAAMsH,QAAQ,WAAWtH,MAAMuvB;AACvD,GCEa+G,4BAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvC7uB,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC1H;AAAAA,IAAWo2B,MAAAA,MAAMC,UAAUr2B,MAAMgN,WAAW;AAAA,IACrDlF,SAAS,CAAC,MAAM,CAACilB,MAAM;AAAA,MAAChlB,MAAM;AAAA,IAAA,CAAoB,CAAC,CAAC;AAAA,EACrD,CAAA;AAAC,GCVSwuB,4BAA4B,CACvC9uB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,OAGA;AAAA,IAAC4wB,oBAFmBC,sBAAsB7wB,QAAQ;AAAA,EAAA;AAAA,EAI3DkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAACw2B;AAAAA,EACTA,MAAAA,mBAAmBn9B,IAAKC,CAAAA,UACtByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIzC,MAAMiD;AAAAA,IACVhF,OAAO;AAAA,MACL0T,OAAO;AAAA,MACPnM,UAAUkB,MAAMlB;AAAAA,IAAAA;AAAAA,EAClB,CACD,CACH,CAAC;AAEP,CAAC,GACD2I,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,OAGA;AAAA,IAAC4wB,oBAFmBC,sBAAsB7wB,QAAQ;AAAA,EAAA;AAAA,EAI3DkC,SAAS,CACP,CAACwc,GAAG;AAAA,IAACkS;AAAAA,EACHA,MAAAA,mBAAmBn9B,IAAKC,CAAAA,UACtByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIzC,MAAMiD;AAAAA,IACVhF,OAAO,CAAC,SAAS,UAAU;AAAA,EAAA,CAC5B,CACH,CAAC;AAEP,CAAC,GACDkQ,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAW02B,MAAAA,iBAAiB12B,MAAMlB,QAAQ,EAAE8G,QAAQ;AAAA,EACvEkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CACX+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAoBjJ,UAAUkB,MAAMlB;AAAAA,EAAAA,CAAS,CAAC,CAC5D;AAEL,CAAC,GACD2I,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,QAAW,CAAC02B,iBAAiB12B,MAAMlB,QAAQ,EAAE8G,QAAQ;AAAA,EACxEkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CAAC+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAiBjJ,UAAUkB,MAAMlB;AAAAA,EAAAA,CAAS,CAAC,CAAC;AAE3E,CAAC,CAAC,GCvDS63B,wBAAwB,CACnClvB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC5B,UAAM2wB,gBAAgBiG,iBAAiB;AAAA,MAErCr2B,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW;AAAA,UACTmD,QAAQ;AAAA,YACNhD,MAAMyD,MAAMjE;AAAAA,YACZ0D,QAAQ;AAAA,UACV;AAAA,UACAnD,OAAO;AAAA,YACLC,MAAMyD,MAAMjE;AAAAA,YACZ0D,QAAQ;AAAA,UAAA;AAAA,QACV;AAAA,MACF;AAAA,IACF,CACD;AAED,WAAIkxB,gBACK;AAAA,MAACA;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACA7oB,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAAC2wB;AAAAA,EAAa,MAAM,CAC5B5D,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIiE,MAAMjE;AAAAA,IACVykB,IAAImQ,cAAcp0B;AAAAA,EAAAA,CACnB,CAAC,CACH;AAEL,CAAC,GACDkL,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AAC5B,UAAMywB,YAAYoG,aAAa;AAAA,MAE7Bt2B,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW;AAAA,UACTmD,QAAQ;AAAA,YACNhD,MAAMyD,MAAMjE;AAAAA,YACZ0D,QAAQ;AAAA,UACV;AAAA,UACAnD,OAAO;AAAA,YACLC,MAAMyD,MAAMjE;AAAAA,YACZ0D,QAAQ;AAAA,UAAA;AAAA,QACV;AAAA,MACF;AAAA,IACF,CACD;AAED,WAAIgxB,YACK;AAAA,MAACA;AAAAA,IAAAA,IAGH;AAAA,EACT;AAAA,EACA3oB,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAACywB;AAAAA,EAAS,MAAM,CACxB1D,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIiE,MAAMjE;AAAAA,IACVykB,IAAIiQ,UAAUl0B;AAAAA,EAAAA,CACf,CAAC,CACH;AAEL,CAAC,CAAC,GCvESu6B,0BAA0B,CACrCrvB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACtB2wB,UAAAA,gBAAgBiG,iBAAiBhxB,QAAQ;AAE/C,QAAI,CAAC+qB;AACI,aAAA;AAGT,UAAM1zB,QACJ+C,MAAMqf,WAAW,QACb0X,iBAAiB;AAAA,MACfx2B,SAASqF,SAASrF;AAAAA,MAClBjH,OAAOq3B;AAAAA,IACR,CAAA,IACDqG,mBAAmB;AAAA,MACjBz2B,SAASqF,SAASrF;AAAAA,MAClBjH,OAAOq3B;AAAAA,IAAAA,CACR;AAEA,WAAA;AAAA,MACLv0B,WAAW;AAAA,QACTmD,QAAQtC;AAAAA,QACRX,OAAOW;AAAAA,MAAAA;AAAAA,IAEX;AAAA,EACF;AAAA,EACA6K,SAAS,CACP,CAACwc,GAAG;AAAA,IAACloB;AAAAA,EAAS,MAAM,CAClB2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIK;AAAAA,EAAAA,CACL,CAAC,CACH;AAEL,CAAC,GACDqL,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACtBywB,UAAAA,YAAYoG,aAAajxB,QAAQ;AAEvC,QAAI,CAAC6qB;AACI,aAAA;AAGT,UAAMxzB,QACJ+C,MAAMqf,WAAW,QACb0X,iBAAiB;AAAA,MACfx2B,SAASqF,SAASrF;AAAAA,MAClBjH,OAAOm3B;AAAAA,IACR,CAAA,IACDuG,mBAAmB;AAAA,MACjBz2B,SAASqF,SAASrF;AAAAA,MAClBjH,OAAOm3B;AAAAA,IAAAA,CACR;AAEA,WAAA;AAAA,MAACr0B,WAAW;AAAA,QAACmD,QAAQtC;AAAAA,QAAOX,OAAOW;AAAAA,MAAAA;AAAAA,IAAM;AAAA,EAClD;AAAA,EACA6K,SAAS,CACP,CAACwc,GAAG;AAAA,IAACloB;AAAAA,EAAS,MAAM,CAClB2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIK;AAAAA,EAAAA,CACL,CAAC,CACH;AAEL,CAAC,CAAC,GC/DS66B,yBAAyB,CACpCxvB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,MAAc;AACjB,QAAA,CAACA,SAASrF,QAAQnE;AACb,aAAA;AAGT,UAAMS,sBAAsBq6B,uBAC1BtxB,SAASrF,QAAQnE,SACnB,GACMe,oBAAoBg6B,qBAAqBvxB,SAASrF,QAAQnE,SAAS,GAEnE4iB,iBAAiBlZ,kBAA4B;AAAA,MAEjDvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW;AAAA,UACTmD,QAAQ1C;AAAAA,UACRP,OAAOa;AAAAA,QAAAA;AAAAA,MACT;AAAA,IACF,CACD;AAED,QAAI6hB,gBAAgB;AAClB,YAAMoY,gBAAgBL,iBAAiB;AAAA,QACrCx2B,SAASqF,SAASrF;AAAAA,QAClBjH,OAAO0lB;AAAAA,MACR,CAAA,GACKqY,wBAAwB;AAAA,QAC5B93B,QAAQpC;AAAAA,QACRb,OAAO86B;AAAAA,MAAAA,GAEHE,eAAezpB,WAAW;AAAA,QAC9BvU,OAAO+T,YAAY;AAAA,UACjB9M,SAAS;AAAA,YACP,GAAGqF,SAASrF;AAAAA,YACZnE,WAAWi7B;AAAAA,UACb;AAAA,UACAjqB,QAAQ,CAAC4R,eAAe3iB,IAAI;AAAA,QAAA,CAC7B,EAAEN,GAAG,CAAC;AAAA,QACPwE,SAASqF,SAASrF;AAAAA,QAClBuN,SAAS;AAAA,UAACC,aAAa;AAAA,UAAMC,gBAAgB;AAAA,QAAA;AAAA,MAAI,CAClD;AAEG,aAAA,CAACspB,gBAAgB,CAACt4B,YAAY4G,SAASrF,SAAS+2B,YAAY,IACvD,KAGF;AAAA,QACLA;AAAAA,QACAD;AAAAA,QACAj7B,WAAW;AAAA,UACTmD,QAAQ1C;AAAAA,UACRP,OAAO86B;AAAAA,QAAAA;AAAAA,MAEX;AAAA,IAAA;AAcF,QAXyBtxB,oBAA8B;AAAA,MAErDvF,SAAS;AAAA,QACP,GAAGqF,SAASrF;AAAAA,QACZnE,WAAW;AAAA,UACTmD,QAAQ1C;AAAAA,UACRP,OAAOa;AAAAA,QAAAA;AAAAA,MACT;AAAA,IACF,CACD,GAEqB;AACpB,YAAMm6B,eAAezpB,WAAW;AAAA,QAC9BvU,OAAO;AAAA,UACLC,OAAOqM,SAASrF,QAAQrC,OAAO5E,MAAMhB;AAAAA,UACrC0B,UAAU,CAAA;AAAA,QACZ;AAAA,QACAuG,SAASqF,SAASrF;AAAAA,QAClBuN,SAAS;AAAA,UAACC,aAAa;AAAA,UAAMC,gBAAgB;AAAA,QAAA;AAAA,MAAI,CAClD;AAED,aAAKspB,eAIE;AAAA,QACLA;AAAAA,QACAD,uBAAuB;AAAA,UACrB93B,QAAQpC;AAAAA,UACRb,OAAOa;AAAAA,QACT;AAAA,QACAf,WAAWwJ,SAASrF,QAAQnE;AAAAA,MAAAA,IATrB;AAAA,IAAA;AAaJ,WAAA;AAAA,EACT;AAAA,EACA0L,SAAS,CACP,CAACwc,GAAG;AAAA,IAACgT;AAAAA,IAAcl7B;AAAAA,EACjBm7B,MAAAA,qBAAqBn7B,SAAS,IAC1B,CACE2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAOg+B;AAAAA,IACPlY,WAAW;AAAA,IACXC,QAAQ;AAAA,EAAA,CACT,CAAC,IAEJ,CACE0N,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIK;AAAAA,EACL,CAAA,GACD2wB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNzO,OAAOg+B;AAAAA,IACPlY,WAAW;AAAA,IACXC,QAAQ;AAAA,EAAA,CACT,CAAC,CACH;AAEX,CAAC,CAAC,GC7HSmY,yBAAyB,CACpC/vB,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,OAGA;AAAA,IAAC4wB,oBAFmBC,sBAAsB7wB,QAAQ;AAAA,EAAA;AAAA,EAI3DkC,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ;AAAA,IAACw2B;AAAAA,EACTA,MAAAA,mBAAmBn9B,IAAKC,CAAAA,UACtByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIzC,MAAMiD;AAAAA,IACVhF,OAAO;AAAA,MACLqC,OAAOoG,MAAMpG;AAAAA,IAAAA;AAAAA,EACf,CACD,CACH,CAAC;AAEP,CAAC,GACD6N,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,EAAAA,OAGA;AAAA,IAAC4wB,oBAFmBC,sBAAsB7wB,QAAQ;AAAA,EAAA;AAAA,EAI3DkC,SAAS,CACP,CAACwc,GAAG;AAAA,IAACkS;AAAAA,EACHA,MAAAA,mBAAmBn9B,IAAKC,CAAAA,UACtByzB,MAAM;AAAA,IACJhlB,MAAM;AAAA,IACNhM,IAAIzC,MAAMiD;AAAAA,IACVhF,OAAO,CAAC,OAAO;AAAA,EAAA,CAChB,CACH,CAAC;AAEP,CAAC,GACDkQ,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAWy3B,MAAAA,cAAcz3B,MAAMpG,KAAK,EAAEgM,QAAQ;AAAA,EACjEkC,SAAS,CAAC,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CAAC+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAgBnO,OAAOoG,MAAMpG;AAAAA,EAAAA,CAAM,CAAC,CAAC;AAC5E,CAAC,GACD6N,eAAe;AAAA,EACb7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,QAAW,CAACy3B,cAAcz3B,MAAMpG,KAAK,EAAEgM,QAAQ;AAAA,EAClEkC,SAAS,CAAC,CAAC;AAAA,IAAC9H;AAAAA,EAAK,MAAM,CAAC+sB,MAAM;AAAA,IAAChlB,MAAM;AAAA,IAAanO,OAAOoG,MAAMpG;AAAAA,EAAAA,CAAM,CAAC,CAAC;AACzE,CAAC,CAAC,GClCE89B,uCAAuCjwB,eAAe;AAAA,EAC1D7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACxB23B,QAAAA;AAGJ,UAAMC,WAEF,CAAE;AAEK7qB,eAAAA,aAAanH,SAASrF,QAAQuM,YAAY;AACnD,YAAMQ,OAAOtN,MAAMgN,YAAYA,YAAY2U,aAAakW,QACtD9qB,UAAUJ,QACZ;AAEA,UAAI,CAACW;AACH;AAGIwqB,YAAAA,mBAAmB/qB,UAAUG,YAAY;AAAA,QAC7CtH;AAAAA,QACA5F,OAAO;AAAA,UAAC+H,MAAM;AAAA,UAAeuF;AAAAA,QAAAA;AAAAA,MAAI,CAClC;AAEGwqB,UAAAA,iBAAiB/vB,SAAS,2BAA2B;AAC7C+vB,kBAAAA;AACV;AAAA,MACF;AACEF,iBAASh4B,KAAKk4B,gBAAgB;AAAA,IAAA;AAIlC,WAAKH,WACI;AAAA,MACL5vB,MAAM;AAAA,MACN4E,UAAU;AAAA,MACVM,QAAQ2qB,SAASv+B,IAAK0+B,CAAAA,YAAYA,QAAQ9qB,MAAM,EAAExR,KAAK,IAAI;AAAA,IAC7D;AAAA,EAIJ;AAAA,EACAqM,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAAA,GAAQ83B,qBAAqB,CAC7B/K,MAAM;AAAA,IACJ,GAAG+K;AAAAA,IACH9qB,aAAahN,MAAMgN;AAAAA,EAAAA,CACpB,CAAC,CACH;AAEL,CAAC,GAEKgrB,qCAAqCvwB,eAAe;AAAA,EACxD7P,IAAI;AAAA,EACJ8P,OAAOA,CAAC;AAAA,IAAC9B;AAAAA,IAAU5F;AAAAA,EAAAA,MAAW;AACxB4F,QAAAA,SAASrF,QAAQuM,WAAWxR,WAAW;AAClC,aAAA;AAGT,UAAM28B,kBAAkBryB,SAASrF,QAAQuM,WAAWzT,IAAK0T,CAAAA,cACvDA,UAAUH,UAAU;AAAA,MAClBhH;AAAAA,MACA5F,OAAO;AAAA,QACL,GAAGA;AAAAA,QACHgN,aAAahN,MAAMgN,YAAYjF;AAAAA,MAAAA;AAAAA,IACjC,CACD,CACH;AAEIkwB,WAAAA,gBAAgB38B,WAAW,IACtB,KAGF28B;AAAAA,EACT;AAAA,EACAnwB,SAAS,CACP,CAAC;AAAA,IAAC9H;AAAAA,EAAQi4B,GAAAA,oBACRA,gBAAgB5+B,IAAK6+B,oBACZnL,MAAM;AAAA,IACX,GAAGmL;AAAAA,IACHlrB,aAAahN,MAAMgN;AAAAA,EAAAA,CACpB,CACF,CAAC;AAER,CAAC,GAEYmrB,oBAAoB;AAAA,EAC/B1wB,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,IAAAA,MAAc;AACfgL,YAAAA,YAAY9K,eAAuBF,QAAQ,GAC3CorB,qBAAqBlrB,uBAA+BF,QAAQ;AAElE,aAAOgL,aAAaogB;AAAAA,IACtB;AAAA,IACAlpB,SAAS,CAAA;AAAA,EAAA,CACV;AAAA,EACDL,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,IAAAA,MAAc;AACfgL,YAAAA,YAAY9K,eAAuBF,QAAQ,GAC3CorB,qBAAqBlrB,uBAA+BF,QAAQ;AAElE,aAAOgL,aAAaogB;AAAAA,IACtB;AAAA,IACAlpB,SAAS,CAAA;AAAA,EAAA,CACV;AAAA,EACDL,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,IAAAA,MACAA,SAASrF,QAAQnE,YACpB;AAAA,MACEA,WAAWwJ,SAASrF,QAAQnE;AAAAA,IAAAA,IAE9B;AAAA,IAEN0L,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAAA,GAAQ;AAAA,MAAC5D;AAAAA,IAAS,MAAM,CACxB2wB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IACd,CAAA,GACD+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAIK;AAAAA,IAAAA,CACL,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACDqL,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAAA,MAAW,CACX;AAAA,MACE+H,MAAM;AAAA,MACNC,QAAQA,MAAM;AACZhI,cAAMgN,YAAYA,YAAY2U,aAAayW,QACzCp4B,MAAM2M,UACN3M,MAAMsN,IACR;AAAA,MAAA;AAAA,IACF,CACD,CACF;AAAA,EAAA,CAEJ;AAAA,EACD7F,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAAA,MAAW,CACX;AAAA,MACE+H,MAAM;AAAA,MACNC,QAAQA,MAAM;AACZjF,gBAAQC,KACN,oBAAoBhD,MAAM2M,QAAQ,wBAAwB3M,MAAMiN,MAAM,GACxE;AAAA,MAAA;AAAA,IACF,CACD,CACF;AAAA,EAAA,CAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAODxF,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,MAAU5F;AAAAA,IAAAA,MAAW;AACL8F,UAAAA,kBAA4BF,QAAQ,KAIzD5F,MAAM2M,aAAa,gBACnB3M,MAAMgN,YAAYjF,SAAS,mBAC3B;AACMyI,cAAAA,mBAAmB5K,SAAS0N,KAAK9C;AAGhC,eAAA;AAAA,UACLG,mBAHwB7K,uBAA+BF,QAAQ;AAAA,UAI/D4K;AAAAA,UACA6nB,UAAUr4B,MAAMsN,KAAKK,QAASrU,CAAAA,UAC5B0F,YAAY4G,SAASrF,SAASjH,KAAK,IAC/B,CAACg/B,iBAAiBh/B,KAAK,CAAC,IACxB,CACN,CAAA;AAAA,QACF;AAAA,MAAA;AAGK,aAAA;AAAA,IACT;AAAA,IACAwO,SAAS,CACP,CAACwc,GAAG;AAAA,MAAC3T;AAAAA,MAAmBH;AAAAA,MAAkB6nB;AAAAA,IAAQ,MAChDA,SAAS1qB,QAAQ,CAAC4qB,SAASxd,UACzBA,UAAUsd,SAAS/8B,SAAS,IACxB,CACEyxB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACN1N,MAAMk+B;AAAAA,MACNpoB,YAAYK;AAAAA,MACZlG,aAAaqG,kBAAkBtX,IAC7B,CAAC;AAAA,QAACN;AAAAA,QAAMQ;AAAAA,QAAO,GAAGT;AAAAA,MAAAA,OAAY;AAAA,QAC5BR,MAAMiB;AAAAA,QACNT;AAAAA,MAAAA,EAEJ;AAAA,IACD,CAAA,GACDi0B,MAAM;AAAA,MAAChlB,MAAM;AAAA,IAAA,CAAe,CAAC,IAE/B,CACEglB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACN1N,MAAMk+B;AAAAA,MACNpoB,YAAYK;AAAAA,MACZlG,aAAaqG,kBAAkBtX,IAC7B,CAAC;AAAA,QAACN;AAAAA,QAAMQ;AAAAA,QAAO,GAAGT;AAAAA,MAAAA,OAAY;AAAA,QAC5BR,MAAMiB;AAAAA,QACNT;AAAAA,MAAAA,EAEJ;AAAA,IACD,CAAA,CAAC,CAEV,CAAC;AAAA,EAAA,CAEN;AAAA,EACD2O,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNqF,QAAQpN,MAAMsN;AAAAA,MACd8R,WAAW;AAAA,IAAA,CACZ,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACD3X,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAAA,MAAW,CACX;AAAA,MACE+H,MAAM;AAAA,MACNC,QAAQA,MAAM;AACZjF,gBAAQC,KACN,sBAAsBhD,MAAM2M,QAAQ,wBAAwB3M,MAAMiN,MAAM,GAC1E;AAAA,MAAA;AAAA,IACF,CACD,CACF;AAAA,EAAA,CAEJ;AAAA,EACDxF,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJ8P,OAAOA,CAAC;AAAA,MAAC9B;AAAAA,UACAA,SAASrF,QAAQnE,aACtB0J,oBAA8BF,QAAQ,IACpC;AAAA,MAACxJ,WAAWwJ,SAASrF,QAAQnE;AAAAA,IAAAA,IAC7B;AAAA,IAEN0L,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAAA,GAAQ;AAAA,MAAC5D;AAAAA,IAAS,MAAM,CACxB2wB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNhM,IAAIK;AAAAA,IACL,CAAA,GACD2wB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACDyH,eAAe;AAAA,IACb7P,IAAI;AAAA,IACJkQ,SAAS,CACP,CAAC;AAAA,MAAC9H;AAAAA,IAAK,MAAM,CACX+sB,MAAM;AAAA,MACJhlB,MAAM;AAAA,MACNiF,aAAahN;AAAAA,IAAAA,CACd,CAAC,CACH;AAAA,EAAA,CAEJ;AAAA,EACD,GAAG41B;AAAAA,EACH,GAAGE;AAAAA,EACH,GAAGG;AAAAA,EACH,GAAGC;AAAAA,EACH,GAAGI;AAAAA,EACH,GAAGC;AAAAA,EACH,GAAGI;AAAAA,EACH,GAAGa;AAAAA,EACH,GAAGV;AAAAA,EACH,GAAGG;AAAAA,EACHS;AAAAA,EACAM;AAAkC;AC5J7B,SAASQ,yBACdx4B,OAKA;AAEE,SAAA,CAACy4B,sBAAsBz4B,KAAK,KAC5B,CAAC04B,sBAAsB14B,KAAK,KAC5B,CAAC24B,wBAAwB34B,KAAK;AAElC;AAMA,MAAM44B,6BAA6B,CACjC,qBACA,oBACA,mBACA,gBACA,kBACA,eACA,eACA,2BACA,2BACA,iBACA,gBACA,qBACA,iBACA,oBACA,oBACA,mBACA,iBACA,yBACA,qBACA,aACA,yBACA,yBACA,SACA,aACA,gBACA,cAAc;AA4JT,SAASD,wBACd34B,OACgC;AACxB44B,SAAAA,2BAAiDvoB,SAASrQ,MAAM+H,IAAI;AAC9E;AAMA,MAAM8wB,2BAA2B,CAC/B,kBACA,iBACA,mBACA,kBACA,aACA,gBACA,kBACA,iBACA,kBACA,aACA,WACA,oBACA,kBACA,aAAa;AAOR,SAASH,sBACd14B,OAC8B;AACtB64B,SAAAA,yBAA+CxoB,SAASrQ,MAAM+H,IAAI;AAC5E;AAuJO,SAAS0wB,sBACdz4B,OAC8B;AACvBA,SAAAA,MAAM+H,KAAK+wB,WAAW,SAAS;AACxC;ACljBA,MAAM1gC,UAAQC,cAAc,iBAAiB;AAE7C,SAAS0gC,cAAc/4B,OAAsB;AACpC04B,SAAAA,sBAAsB14B,KAAK,IAC9B,WACA24B,wBAAwB34B,KAAK,IAC3B,cACAy4B,sBAAsBz4B,KAAK,IACzB,WACA;AACV;AAEO,SAASg5B,aAAa;AAAA,EAC3Bx6B;AAAAA,EACAy6B;AAAAA,EACAC;AAAAA,EACAl5B;AAAAA,EACAtI;AAAAA,EACA+W;AAAAA,EACAvQ;AAAAA,EACA+B;AAAAA,EACAk5B;AAAAA,EACA1D;AAgBF,GAAG;AACDr9B,UAAM,IAAIoG,IAAI,IAAIu6B,cAAc/4B,KAAK,CAAC,KAAKuN,KAAKC,UAAUxN,OAAO,MAAM,CAAC,CAAC;AAEnEo5B,QAAAA,iBAAiB,CACrB,GAAGF,yBACH,GAAGf,iBAAiB,EACpBnpB,OAAQxH,CAAa,aAAA;AAErB,QAAIA,SAAS5P,OAAO;AACX,aAAA;AAGT,UAAM,CAACyhC,iBAAiB,IACtB7xB,SAAS5P,GAAGyY,SAAS,GAAG,KAAK7I,SAAS5P,GAAGyY,SAAS,GAAG,IACjD7I,SAAS5P,GAAGuX,MAAM,GAAG,IACrB,CAAC9T,MAAS,GACV,CAACi+B,cAAc,IAAIt5B,MAAM+H,KAAKsI,SAAS,GAAG,IAC5CrQ,MAAM+H,KAAKoH,MAAM,GAAG,IACpB,CAAC9T,MAAS;AAcd,WATEg+B,sBAAsBh+B,UACtBi+B,mBAAmBj+B,UACnBg+B,sBAAsBC,kBAQtBD,sBAAsBh+B,UACtBi+B,mBAAmBj+B,UACnBg+B,sBAAsBr5B,MAAM+H,OAErB,KAGFP,SAAS5P,OAAOoI,MAAM+H;AAAAA,EAAAA,CAC9B;AAED,MAAIqxB,eAAe99B,WAAW,KAAKk9B,yBAAyBx4B,KAAK,GAAG;AAClEm5B,iBAAaI,eAAe,GAE5BvY,+BAA+BtpB,QAAQ,MAAM;AAC3CU,cAAM,YAAY2gC,cAAc/4B,KAAK,CAAC,KAAKuN,KAAKC,UAAUxN,OAAO,MAAM,CAAC,CAAC,GAEzE6gB,iBAAiB;AAAA,QACftgB,SAAS;AAAA,UACPkO;AAAAA,UACAvQ;AAAAA,QACF;AAAA,QACAyF,WAAW;AAAA,UACT,GAAG3D;AAAAA,UACHtI;AAAAA,QAAAA;AAAAA,MACF,CACD;AAAA,IAAA,CACF,GAEDA,OAAOqe,SAAS;AAEhB;AAAA,EAAA;AAGF,QAAMyjB,gBAAgBv5B,YAAY;AAElC,MAAIw5B,uBAAuB,IACvBC,6BAA6B,IAC7BC,qBAAqB;AAEzB,aAAWC,iBAAiBR,gBAAgB;AAC1CO;AAEA,QAAIE,YAAY;AAEZ,QAAA;AACFA,kBACED,cAAclyB,UAAUrM,UACxBu+B,cAAclyB,MAAM;AAAA,QAClB9B,UAAU4zB;AAAAA,QACVx5B;AAAAA,QACAiyB,KAAKuD,gBAAgBC,UAAU/9B,MAAM;AAAA,MAAA,CACtC;AAAA,aACI8R,OAAO;AACNA,cAAAA,MACN,IAAI3O,MACF,yBAAyBmF,MAAM+H,IAAI,oBAAoByB,MAAMsX,OAAO,EACtE,CACF;AAAA,IAAA;AAGF,QAAK+Y,WAMLH;AAA6B,mCAAA;AAElBI,iBAAAA,aAAaF,cAAc9xB,SAAS;AAC7C,cAAMiyB,kBAAkB95B,YAAY;AAEpC,YAAI6H,UAAiC,CAAE;AAEnC,YAAA;AACFA,oBAAUgyB,UACR;AAAA,YACEl0B,UAAUm0B;AAAAA,YACV/5B;AAAAA,YACAiyB,KAAKuD,gBAAgBC,UAAU/9B,MAAM;AAAA,aAEvCmiC,SACF;AAAA,iBACOrwB,OAAO;AACNA,kBAAAA,MACN,IAAI3O,MACF,2BAA2BmF,MAAM+H,IAAI,oBAAoByB,MAAMsX,OAAO,EACxE,CACF;AAAA,QAAA;AAGEhZ,YAAAA,QAAQxM,WAAW,GAIvB;AAAA,cAAIwM,QAAQrJ,KAAMu7B,CAAAA,WAAWA,OAAOjyB,SAAS,SAAS,GAAG;AAKvD+O,yBAAapf,QAAQ,MAAM;AACzB,yBAAWsiC,UAAUlyB,SAAS;AACxBkyB,oBAAAA,OAAOjyB,SAAS,UAAU;AACL,yCAAA;AAEnB,sBAAA;AACFiyB,2BAAOhyB,OAAO;AAAA,2BACPwB,OAAO;AACNA,4BAAAA,MACN,IAAI3O,MACF,oCAAoCmF,MAAM+H,IAAI,oBAAoByB,MAAMsX,OAAO,EACjF,CACF;AAAA,kBAAA;AAGF;AAAA,gBAAA;AAGEkZ,oBAAAA,OAAOjyB,SAAS,WAAW;AAC7B,wBAAMmxB,2BAA0BE,eAAe58B,MAC7Cm9B,qBAAqB,CACvB;AAEa,+BAAA;AAAA,oBACXn7B,MAAM;AAAA,oBACNy6B;AAAAA,oBACAC,yBAAyBA;AAAAA,oBACzBl5B,OAAOg6B,OAAOh6B;AAAAA,oBACdtI;AAAAA,oBACA+W;AAAAA,oBACAvQ;AAAAA,oBACA+B;AAAAA,oBACAk5B;AAAAA,oBACA1D;AAAAA,kBAAAA,CACD;AAED;AAAA,gBAAA;AAGEuE,oBAAAA,OAAOjyB,SAAS,SAAS;AAC3B0xB,yCAAuB,IAEvBT,aAAa;AAAA,oBACXx6B,MAAM;AAAA,oBACNy6B;AAAAA,oBACAC,yBAAyBD;AAAAA,oBACzBj5B,OAAOg6B,OAAOh6B;AAAAA,oBACdtI;AAAAA,oBACA+W;AAAAA,oBACAvQ;AAAAA,oBACA+B;AAAAA,oBACAk5B;AAAAA,oBACA1D;AAAAA,kBAAAA,CACD;AAED;AAAA,gBAAA;AAGFgE,uCAAuB,IAEvBT,aAAa;AAAA,kBACXx6B,MAAM;AAAA,kBACNy6B;AAAAA,kBACAC,yBAAyBP,wBAAwBqB,OAAOh6B,KAAK,IACzDi5B,YACA,CAAE;AAAA,kBACNj5B,OAAOg6B,OAAOh6B;AAAAA,kBACdtI;AAAAA,kBACA+W;AAAAA,kBACAvQ;AAAAA,kBACA+B;AAAAA,kBACAk5B,aAAa99B;AAAAA,kBACbo6B;AAAAA,gBAAAA,CACD;AAAA,cAAA;AAAA,YACH,CACD;AAED;AAAA,UAAA;AAGF,qBAAWuE,UAAUlyB,SAAS;AACxBkyB,gBAAAA,OAAOjyB,SAAS,UAAU;AACL,qCAAA;AAEnB,kBAAA;AACFiyB,uBAAOhyB,OAAO;AAAA,uBACPwB,OAAO;AACNA,wBAAAA,MACN,IAAI3O,MACF,oCAAoCmF,MAAM+H,IAAI,oBAAoByB,MAAMsX,OAAO,EACjF,CACF;AAAA,cAAA;AAGF;AAAA,YAAA;AAGEkZ,gBAAAA,OAAOjyB,SAAS,WAAW;AAC7B,oBAAMmxB,2BAA0BE,eAAe58B,MAC7Cm9B,qBAAqB,CACvB;AAEa,2BAAA;AAAA,gBACXn7B,MAAM;AAAA,gBACNy6B;AAAAA,gBACAC,yBAAyBA;AAAAA,gBACzBl5B,OAAOg6B,OAAOh6B;AAAAA,gBACdtI;AAAAA,gBACA+W;AAAAA,gBACAvQ;AAAAA,gBACA+B;AAAAA,gBACAk5B;AAAAA,gBACA1D;AAAAA,cAAAA,CACD;AAED;AAAA,YAAA;AAGEuE,gBAAAA,OAAOjyB,SAAS,SAAS;AAC3B0xB,qCAAuB,IAEvBT,aAAa;AAAA,gBACXx6B,MAAM;AAAA,gBACNy6B;AAAAA,gBACAC,yBAAyBD;AAAAA,gBACzBj5B,OAAOg6B,OAAOh6B;AAAAA,gBACdtI;AAAAA,gBACA+W;AAAAA,gBACAvQ;AAAAA,gBACA+B;AAAAA,gBACAk5B;AAAAA,gBACA1D;AAAAA,cAAAA,CACD;AAED;AAAA,YAAA;AAGEuE,mBAAOjyB,SAAS,aAClBhF,QAAQyG,MAAM,mCAAmC;AAAA,UAAA;AAAA,QAErD;AAAA,MAAA;AAGF;AAAA,IAAA;AAAA,EAAA;AAGE,GAACkwB,8BAA8BlB,yBAAyBx4B,KAAK,KAC/Dm5B,aAAaI,eAAe,GAE5BvY,+BAA+BtpB,QAAQ,MAAM;AAC3CU,YAAM,YAAY2gC,cAAc/4B,KAAK,CAAC,KAAKuN,KAAKC,UAAUxN,OAAO,MAAM,CAAC,CAAC,GAEzE6gB,iBAAiB;AAAA,MACftgB,SAAS;AAAA,QAACkO;AAAAA,QAAcvQ;AAAAA,MAAM;AAAA,MAC9ByF,WAAW;AAAA,QACT,GAAG3D;AAAAA,QACHtI;AAAAA,MAAAA;AAAAA,IACF,CACD;AAAA,EAAA,CACF,GAEDA,OAAOqe,cACE0jB,wBACTN,aAAaI,eAAe;AAEhC;AChWO,SAASU,eAId9f,OAA2B;AAC3B,MAAIA,MAAM7e,WAAW;AACnB,WAAO,CAAE;AAIX,QAAM4+B,oBAAoB/f,MAAMnL,OAC7BqK,CAAAA,SACCA,KAAKpR,aAAa5M,MACtB,GACM8+B,uBAAuBhgB,MAAMnL,OAChCqK,CAASA,SAAAA,KAAKpR,aAAa5M,MAC9B;AAEA,MAAI6+B,kBAAkB5+B,WAAW;AACxB6e,WAAAA;AAIHigB,QAAAA,oBAAoB,IAAIC,IAC5BH,kBAAkB7gC,IAAKggB,CAAS,SAAA,CAACA,KAAKpR,SAASf,IAAImS,IAAI,CAAC,CAC1D,GAGMihB,QAAQ,oBAAID,OACZE,+BAAeF,IAAoB;AAGzC,WAASG,WAAWtzB,IAAY;AACzBozB,UAAMnmB,IAAIjN,EAAE,MACfozB,MAAMpoB,IAAIhL,IAAQkF,oBAAAA,IAAAA,CAAK,GACvBmuB,SAASroB,IAAIhL,IAAI,CAAC;AAAA,EAAA;AAKtB,aAAWmS,QAAQ6gB,mBAAmB;AAC9BhzB,UAAAA,KAAKmS,KAAKpR,SAASf;AACzBszB,eAAWtzB,EAAE;AAAA,EAAA;AAINuzB,WAAAA,QAAQC,QAAgBC,MAAc;AACzC,KAACL,MAAMnmB,IAAIumB,MAAM,KAAK,CAACJ,MAAMnmB,IAAIwmB,IAAI,MACzCL,MAAMxqB,IAAI4qB,MAAM,GAAGtmB,IAAIumB,IAAI,GAC3BJ,SAASroB,IAAIyoB,OAAOJ,SAASzqB,IAAI6qB,IAAI,KAAK,KAAK,CAAC;AAAA,EAAA;AAIlD,aAAWthB,QAAQ6gB,mBAAmB;AACpC,UAAMhzB,KAAKmS,KAAKpR,SAASf,IACnB0zB,8BAAcxuB,IAAY;AAC5BF,QAAAA,MAAMmN,KAAKpR,SAASd;AAExB,WAAO+E,OAAK;AACJ2uB,YAAAA,QAAQ3uB,IAAIjE,SAASf;AAI3B,UAHAszB,WAAWK,KAAK,GAGZD,QAAQzmB,IAAI0mB,KAAK;AACb,cAAA,IAAIhgC,MAAM,4CAA4C;AAE9D+/B,cAAQxmB,IAAIymB,KAAK,GAEb3uB,IAAIhE,eAAe,WAErBuyB,QAAQvzB,IAAI2zB,KAAK,IAGjBJ,QAAQI,OAAO3zB,EAAE,GAGnBgF,MAAMA,IAAIjE,SAASd;AAAAA,IAAAA;AAAAA,EACrB;AAGF,QAAM2zB,QAAkB,CAAE;AAGf,aAAA,CAAC5zB,IAAI6zB,MAAM,KAAKR;AACrBQ,eAAW,KACbD,MAAMl7B,KAAKsH,EAAE;AAIjB,QAAM8zB,SAAc,CAAE;AAGfF,SAAAA,MAAMx/B,SAAS,KAAG;AACvB,UAAM2/B,YAAYH,MAAM7hB,MAAAA,GAClBiiB,cAAcd,kBAAkBtqB,IAAImrB,SAAS;AAC/CC,mBACFF,OAAOp7B,KAAKs7B,WAAW;AAIzB,eAAWC,cAAcb,MAAMxqB,IAAImrB,SAAS,KAAK,CAAA,GAAI;AACnD,YAAMG,aAAab,SAASzqB,IAAIqrB,UAAU,KAAK,KAAK;AAC3CjpB,eAAAA,IAAIipB,YAAYC,SAAS,GAC9BA,cAAc,KAChBN,MAAMl7B,KAAKu7B,UAAU;AAAA,IAAA;AAAA,EAEzB;AAIF,aAAW9hB,QAAQ6gB;AACZc,WAAO3qB,SAASgJ,IAAI,KACvB2hB,OAAOp7B,KAAKyZ,IAAI;AAKpB,SAAO,CAAC,GAAG2hB,QAAQ,GAAGb,oBAAoB;AAC5C;ACrFO,SAASkB,qBAAqB;AAAA,EACnCvuB;AAAAA,EACApV;AAAAA,EACA+W;AAAAA,EACA7E;AAAAA,EACA1L;AAOF,GAAG;AACK9B,QAAAA,YAAY1E,OAAO0E,YACrBgD,sBAAsB;AAAA,IACpBlB;AAAAA,IACAxG;AAAAA,IACA2H,OAAO3H,OAAO0E;AAAAA,EACf,CAAA,IACD;AAWG,SAAA;AAAA,IACLmE,SAVc;AAAA,MACduM;AAAAA,MACA2B;AAAAA,MACA7E;AAAAA,MACA1L;AAAAA,MACA9B;AAAAA,MACAtD,OAAOpB,OAAOoB;AAAAA,IAChB;AAAA,IAIEwa,MAAM;AAAA,MACJ3C,mBAAmBX,qBAAqB;AAAA,QACtCC,WAAWvY,OAAOuY;AAAAA,QAClB/R;AAAAA,MAAAA,CACD;AAAA,MACDsS,kBAAkBF,oBAAoB;AAAA,QACpCC,gBAAgB7Y,OAAO6Y;AAAAA,QACvBN,WAAWvY,OAAOuY;AAAAA,QAClB/R;AAAAA,MACD,CAAA;AAAA,IAAA;AAAA,EAEL;AACF;AC3CA,MAAM9F,UAAQC,cAAc,gBAAgB,GAuG/BijC,gBAAgBn7B,MAAM;AAAA,EACjC0P,OAAO;AAAA,IACLtP,SAAS,CAAC;AAAA,IAkBVg7B,QAAQ,CAAC;AAAA,IACTC,SAAS,CAAC;AAAA,IACVC,OAAO,CAAC;AAAA,IASRC,MAAM,CAAA;AAAA,EACR;AAAA,EACA5zB,SAAS;AAAA,IACP,2BAA2B6zB,OAAO;AAAA,MAChC1C,WAAWA,CAAC;AAAA,QAAC14B;AAAAA,QAASP;AAAAA,MACpB47B,OAAAA,YAAY57B,OAAO,cAAc,GAE1B,oBAAIoM,IAAI,CAAC,GAAG7L,QAAQ04B,WAAWj5B,MAAMwI,cAAc,CAAC;AAAA,IAAA,CAE9D;AAAA,IACD,gCAAgCmzB,OAAO;AAAA,MACrC1C,WAAWA,CAAC;AAAA,QAAC14B;AAAAA,QAASP;AAAAA,MAAAA,OACpB47B,YAAY57B,OAAO,iBAAiB,GAEpCO,QAAQ04B,UAAUta,OAAO3e,MAAMwI,cAAc,GAElC4D,oBAAAA,IAAI,CAAC,GAAG7L,QAAQ04B,SAAS,CAAC;AAAA,IAAA,CAExC;AAAA,IACD,oBAAoB4C,eAAe,CAAC;AAAA,MAAC77B;AAAAA,MAAO87B;AAAAA,IAAAA,MAAa;AACvDF,kBAAY57B,OAAO,gBAAgB,GAEnC87B,QAAQC,KAAK/7B,KAAK;AAAA,IAAA,CACnB;AAAA,IACD,uBAAuB+7B,KAAK,CAAC;AAAA,MAAC/7B;AAAAA,IAC5B47B,OAAAA,YAAY57B,OAAO,UAAU,GACtBA,MACR;AAAA,IACD,kBAAkB+7B,KAAK;AAAA,MAACh0B,MAAM;AAAA,IAAA,CAAY;AAAA,IAC1C,iBAAiBg0B,KAAK;AAAA,MAACh0B,MAAM;AAAA,IAAA,CAAW;AAAA,IACxC,eAAe4zB,OAAO;AAAA,MACpBK,eAAeA,CAAC;AAAA,QAACz7B;AAAAA,QAASP;AAAAA,MAAAA,OACxB47B,YAAY57B,OAAO,CAAC,kBAAkB,UAAU,CAAC,GAC1C,CAAC,GAAGO,QAAQy7B,eAAeh8B,KAAK;AAAA,IAAA,CAE1C;AAAA,IACD,uBAAuB67B,eAAe,CAAC;AAAA,MAACt7B;AAAAA,MAASu7B;AAAAA,IAAAA,MAAa;AAC5D,iBAAW97B,SAASO,QAAQy7B;AAC1BF,gBAAQC,KAAK/7B,KAAK;AAAA,IAAA,CAErB;AAAA,IACD,cAAc+7B,KAAK;AAAA,MAACh0B,MAAM;AAAA,IAAA,CAAQ;AAAA,IAClC,wBAAwB4zB,OAAO;AAAA,MAC7BK,eAAe,CAAA;AAAA,IAAA,CAChB;AAAA,IACD,0BAA0BL,OAAO;AAAA,MAC/BM,8BAA8BA,CAAC;AAAA,QAAC17B;AAAAA,QAASP;AAAAA,MAAAA,MAChCA,MAAM+H,SAAS,YAClB,CAAC,GAAGxH,QAAQ07B,8BAA8Bj8B,KAAK,IAC/CO,QAAQ07B;AAAAA,IAAAA,CAEf;AAAA,IACD,iCAAiCJ,eAAe,CAAC;AAAA,MAACt7B;AAAAA,MAASu7B;AAAAA,IAAAA,MAAa;AACtE,iBAAW97B,SAASO,QAAQ07B;AAC1BH,gBAAQC,KAAK/7B,KAAK;AAAA,IAAA,CAErB;AAAA,IACD,kCAAkC27B,OAAO;AAAA,MACvCM,8BAA8B,CAAA;AAAA,IAAA,CAC/B;AAAA,IACD,eAAeC,CAAC;AAAA,MAACl8B;AAAAA,IAAAA,MAAW;AAC1B47B,kBAAY57B,OAAO,MAAM;AAErB,UAAA;AACUm8B,oBAAAA,KAAKn8B,MAAMtI,MAAM;AAAA,eACtB8R,OAAO;AACdzG,gBAAQyG,MAAM,IAAI3O,MAAM,0BAA0B2O,MAAMsX,OAAO,EAAE,CAAC;AAAA,MAAA;AAAA,IAEtE;AAAA,IACA,gBAAgBsb,CAAC;AAAA,MAAC77B;AAAAA,IAAAA,MAAa;AACzB,UAAA,CAACA,QAAQR,aAAa;AACxBgD,gBAAQyG,MAAM,gCAAgC;AAC9C;AAAA,MAAA;AAGE,UAAA;AACIsW,cAAAA,mBAAmBvf,QAAQR,YAAY3D;AACjCE,oBAAAA,MAAMiE,QAAQR,WAAW,GACjC+f,oBACFjP,WAAWwO,OAAO9e,QAAQR,aAAa+f,gBAAgB;AAAA,eAElDtW,OAAO;AACdzG,gBAAQyG,MAAM,IAAI3O,MAAM,2BAA2B2O,MAAMsX,OAAO,EAAE,CAAC;AAAA,MAAA;AAAA,IAEvE;AAAA,IACA,yBAAyBub,CAAC;AAAA,MAAC97B;AAAAA,MAASP;AAAAA,MAAOs8B;AAAAA,IAAAA,MAAU;AACvCt8B,kBAAAA,OAAO,CAAC,gBAAgB,CAAC;AAEjC,UAAA;AACF,cAAMi5B,YAAYgB,eAAe,CAC/B,GAAG15B,QAAQ04B,UAAUntB,OAAAA,GACrB,GAAGypB,mBAAmB,CACvB,EAAEl8B,IAAK4N,CAAAA,WAAWA,OAAOO,QAAQ;AAErB,qBAAA;AAAA,UACXhJ,MAAM;AAAA,UACNy6B;AAAAA,UACAC,yBAAyBD;AAAAA,UACzBj5B,OAAOA,MAAMshB;AAAAA,UACb5pB,QAAQsI,MAAMtI;AAAAA,UACd+W,cAAclO,QAAQkO;AAAAA,UACtBvQ,QAAQqC,QAAQrC;AAAAA,UAChB+B,aAAaA,MACXo7B,qBAAqB;AAAA,YACnBvuB,YAAY,CAAC,GAAGvM,QAAQuM,UAAU;AAAA,YAClCpV,QAAQsI,MAAMtI;AAAAA,YACd+W,cAAclO,QAAQkO;AAAAA,YACtB7E,UAAU0yB,KAAKr8B,YAAY,EAAEC,QAAQ;AAAA,cAAC,aAAa;AAAA,YAAA,CAAY;AAAA,YAC/DhC,QAAQqC,QAAQrC;AAAAA,UAAAA,CACjB;AAAA,UACHi7B,aAAan5B,MAAMm5B;AAAAA,UACnB1D,UAAWz1B,CAAAA,WAAUs8B,KAAK7zB,KAAKzI,MAAK;AAAA,QAAA,CACrC;AAAA,eACMwJ,OAAO;AACNA,gBAAAA,MACN,IAAI3O,MACF,YAAYmF,MAAMshB,cAAcvZ,IAAI,oBAAoByB,MAAMsX,OAAO,EACvE,CACF;AAAA,MAAA;AAAA,IACF;AAAA,EAEJ;AAAA,EACAyb,QAAQ;AAAA,IACN,iBAAiBC,CAAC;AAAA,MAACj8B;AAAAA,IAAAA,MACZA,QAAQR,cAINQ,QAAQR,YAAYsU,WAAW/Y,SAAS,IAHtC;AAAA,EAAA;AAMf,CAAC,EAAEmhC,cAAc;AAAA,EACfv1B,IAAI;AAAA,EACJ3G,SAASA,CAAC;AAAA,IAACk7B;AAAAA,EAAAA,OAAY;AAAA,IACrBxC,WAAW,oBAAI7sB,IAAI,EAAE;AAAA,IACrBU,YAAY,IAAIV,IAAIqvB,MAAM3uB,cAAc,CAAA,CAAE;AAAA,IAC1CvD,iBAAiBkyB,MAAMlyB;AAAAA,IACvBkF,cAAcgtB,MAAMhtB;AAAAA,IACpButB,eAAe,CAAE;AAAA,IACjBC,8BAA8B,CAAE;AAAA,IAChC/9B,QAAQu9B,MAAMv9B;AAAAA,IACd9B,WAAW;AAAA,IACXsgC,iBAAiBjB,MAAM7xB,YAAY;AAAA,IACnCwX,WAAWqa,MAAMra;AAAAA,IACjBwL,cAAc6O,MAAM7O;AAAAA,EAAAA;AAAAA,EAEtBh1B,IAAI;AAAA,IACF,gBAAgB;AAAA,MAACkQ,SAAS;AAAA,IAAyB;AAAA,IACnD,mBAAmB;AAAA,MAACA,SAAS;AAAA,IAA8B;AAAA,IAC3D,oBAAoB;AAAA,MAClBA,SAAS6zB,OAAO;AAAA,QAACva,WAAWA,CAAC;AAAA,UAACphB;AAAAA,cAAWA,MAAMohB;AAAAA,MAAU,CAAA;AAAA,IAC3D;AAAA,IACA,oBAAoB;AAAA,MAClBtZ,SAAS,CACP6zB,OAAO;AAAA,QAACv/B,WAAWA,CAAC;AAAA,UAAC4D;AAAAA,cAAWA,MAAM5D;AAAAA,MAAAA,CAAU,GAChD2/B,KAAK,CAAC;AAAA,QAAC/7B;AAAAA,MAAAA,OAAY;AAAA,QAAC,GAAGA;AAAAA,QAAO+H,MAAM;AAAA,MAAA,EAAa,CAAC;AAAA,IAEtD;AAAA,IACA,kBAAkB;AAAA,MAChBD,SAAS6zB,OAAO;AAAA,QAACnJ,WAAWA,CAAC;AAAA,UAACxyB;AAAAA,cAAWA,MAAMwzB;AAAAA,MAAM,CAAA;AAAA,IAAA;AAAA,EAEzD;AAAA,EACAzrB,MAAM;AAAA,EACN40B,QAAQ;AAAA,IACN,aAAa;AAAA,MACXC,SAAS;AAAA,MACTD,QAAQ;AAAA,QACN,aAAa;AAAA,UACXC,SAAS;AAAA,UACThlC,IAAI;AAAA,YACF,kBAAkB;AAAA,cAChBkQ,SAAS;AAAA,cACTJ,OAAOA,CAAC;AAAA,gBAAC1H;AAAAA,cAAK,MACZA,MAAMshB,cAAcvZ,SAAS,oBAC7B/H,MAAMshB,cAAcvZ,SAAS,iBAC7B/H,MAAMshB,cAAcvZ,SAAS,eAC7B/H,MAAMshB,cAAcvZ,SAAS,2BAC7B/H,MAAMshB,cAAcvZ,SAAS,2BAC7B/H,MAAMshB,cAAcvZ,SAAS;AAAA,YAAA;AAAA,UAEnC;AAAA,UACA40B,QAAQ;AAAA,YACN,+BAA+B;AAAA,cAC7Bta,OAAO,CACL,MAAM;AACJjqB,wBACE,0DACF;AAAA,cAAA,CACD;AAAA,cAEHykC,MAAM,CACJ,MAAM;AACJzkC,wBACE,yDACF;AAAA,cAAA,CACD;AAAA,cAEHR,IAAI;AAAA,gBACF,sBAAsB,CACpB;AAAA,kBACEqJ,QAAQ;AAAA,kBACRyG,OAAOA,CAAC;AAAA,oBAACnH;AAAAA,wBAAaA,QAAQm8B;AAAAA,gBAAAA,GAEhC;AAAA,kBACEz7B,QAAQ;AAAA,gBACT,CAAA;AAAA,cAAA;AAAA,YAGP;AAAA,YACA,aAAa;AAAA,cACXohB,OAAO,CACL,MAAM;AACJjqB,wBAAM,wCAAwC;AAAA,cAAA,CAC/C;AAAA,cAEHykC,MAAM,CACJ,MAAM;AACJzkC,wBAAM,uCAAuC;AAAA,cAAA,CAC9C;AAAA,cAEHR,IAAI;AAAA,gBACF,mBAAmB;AAAA,kBACjB8P,OAAOA,CAAC;AAAA,oBAAC1H;AAAAA,kBAAAA,MAAW,CAACA,MAAM4J;AAAAA,kBAC3B3I,QAAQ;AAAA,kBACR6G,SAAS,CAAC,eAAe;AAAA,gBAAA;AAAA,cAC3B;AAAA,YACF;AAAA,UACF;AAAA,QAEJ;AAAA,QACA,UAAY;AAAA,UACVlQ,IAAI;AAAA,YACF,mBAAmB;AAAA,cACjB8P,OAAOA,CAAC;AAAA,gBAAC1H;AAAAA,oBAAWA,MAAM4J;AAAAA,cAC1B3I,QAAQ;AAAA,cACR6G,SAAS,CAAC,gBAAgB;AAAA,YAC5B;AAAA,YACA,kBAAkB;AAAA,cAChBA,SAAS;AAAA,YACX;AAAA,YACA,MAAQ;AAAA,cACNA,SAAS;AAAA,YACX;AAAA,YACA,OAAS;AAAA,cACP7G,QAAQ;AAAA,cACR6G,SAAS,CAAC6zB,OAAO;AAAA,gBAAC57B,aAAaA,CAAC;AAAA,kBAACC;AAAAA,sBAAWA,MAAMtI;AAAAA,cAAAA,CAAO,CAAC;AAAA,YAAA;AAAA,UAE9D;AAAA,UACAklC,SAAS;AAAA,UACTD,QAAQ;AAAA,YACN,MAAQ;AAAA,cACNta,OAAO,CACL,MAAM;AACJjqB,wBAAM,kCAAkC;AAAA,cAAA,CACzC;AAAA,cAEHykC,MAAM,CACJ,MAAM;AACJzkC,wBAAM,gCAAgC;AAAA,cAAA,CACvC;AAAA,cAEHR,IAAI;AAAA,gBACFklC,WAAW;AAAA,kBACTh1B,SAAS,CACP6zB,OAAO;AAAA,oBACLoB,cAAcA,CAAC;AAAA,sBAAC/8B;AAAAA,oBAAAA,OAAY;AAAA,sBAC1B+X,QAAQ/X,MAAM+X;AAAAA,oBAChB;AAAA,kBAAA,CACD,CAAC;AAAA,kBAEJ9W,QAAQ;AAAA,gBAAA;AAAA,cACV;AAAA,YAEJ;AAAA,YACA,UAAY;AAAA,cACV27B,SAAS;AAAA,cACTD,QAAQ;AAAA,gBACN,oBAAoB;AAAA,kBAClBta,OAAO,CACL,MAAM;AACJjqB,4BACE,wDACF;AAAA,kBAAA,CACD;AAAA,kBAEHykC,MAAM,CACJ,MAAM;AACJzkC,4BACE,uDACF;AAAA,kBAAA,CACD;AAAA,kBAEH4kC,QAAQ,CACN;AAAA,oBACEt1B,OAAO;AAAA,oBACPzG,QAAQ;AAAA,kBAAA,GAEV;AAAA,oBACEA,QAAQ;AAAA,oBACR6G,SAAS,CAAC,cAAc;AAAA,kBACzB,CAAA;AAAA,gBAEL;AAAA,gBACA,MAAQ;AAAA,kBACNua,OAAO,CACL,MAAM;AACJjqB,4BAAM,2CAA2C;AAAA,kBAAA,CAClD;AAAA,kBAEHykC,MAAM,CACJ,MAAM;AACJzkC,4BAAM,2CAA2C;AAAA,kBAAA,CAClD;AAAA,kBAEH6yB,OAAO;AAAA,oBACL,IAAI;AAAA,sBACFhqB,QAAQ;AAAA,oBAAA;AAAA,kBACV;AAAA,gBACF;AAAA,cACF;AAAA,YAEJ;AAAA,YACA,uBAAuB;AAAA,cACrBohB,OAAO,CACL,MAAM;AACJjqB,wBAAM,iDAAiD;AAAA,cAAA,CACxD;AAAA,cAEHykC,MAAM,CACJ,MAAM;AACJzkC,wBAAM,gDAAgD;AAAA,cAAA,GAExD,CAAC;AAAA,gBAACmI;AAAAA,cAAAA,MAAa;AACb,oBAAIA,QAAQiyB;AACN,sBAAA;AACFjyB,4BAAQiyB,UAAUyK,YAAYC,YAC5B38B,QAAQiyB,SACV;AAAA,2BACOhpB,OAAO;AACdzG,4BAAQyG,MACN,IAAI3O,MACF,0CAA0C2O,MAAMsX,OAAO,EACzD,CACF;AAAA,kBAAA;AAAA,iBAIN6a,OAAO;AAAA,gBAACnJ,WAAWn3B;AAAAA,cAAU,CAAA,GAC7BsgC,OAAO;AAAA,gBAACoB,cAAc1hC;AAAAA,cAAAA,CAAU,CAAC;AAAA,cAEnCqgC,MAAM,CAAC,qBAAqB;AAAA,cAC5B9jC,IAAI;AAAA,gBACFulC,SAAS;AAAA,kBAACl8B,QAAQ;AAAA,gBAAM;AAAA,gBACxBm8B,MAAM;AAAA,kBAACn8B,QAAQ;AAAA,gBAAA;AAAA,cAAM;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IAEJ;AAAA,IACA,OAAS;AAAA,MACP27B,SAAS;AAAA,MACTD,QAAQ;AAAA,QACN,cAAc;AAAA,UACZta,OAAO,CACL,MAAM;AACJjqB,oBAAM,0BAA0B;AAAA,UAAA,CACjC;AAAA,UAEHykC,MAAM,CACJ,MAAM;AACJzkC,oBAAM,yBAAyB;AAAA,UAAA,GAEjC,cACA,iCACA,gCAAgC;AAAA,UAElCR,IAAI;AAAA,YACF,kBAAkB;AAAA,cAChBkQ,SAAS;AAAA,YACX;AAAA,YACA,UAAY;AAAA,cACVA,SAAS;AAAA,YACX;AAAA,YACA,sBAAsB;AAAA,cACpB7G,QAAQ;AAAA,YACV;AAAA,YACA,SAAW;AAAA,cACT6G,SAAS,CAAC,wBAAwB;AAAA,YAAA;AAAA,UACpC;AAAA,QAEJ;AAAA,QACA,UAAU;AAAA,UACRC,MAAM;AAAA,UACN40B,QAAQ;AAAA,YACN,cAAc;AAAA,cACZC,SAAS;AAAA,cACTD,QAAQ;AAAA,gBACN,MAAQ;AAAA,kBACNta,OAAO,CACL,MAAM;AACJjqB,4BAAM,wCAAwC;AAAA,kBAAA,CAC/C;AAAA,kBAEHykC,MAAM,CACJ,MAAM;AACJzkC,4BAAM,uCAAuC;AAAA,kBAAA,CAC9C;AAAA,kBAEHR,IAAI;AAAA,oBACF,SAAW;AAAA,sBACTkQ,SAAS,CAACi0B,KAAK,CAAC;AAAA,wBAAC/7B;AAAAA,sBAAK,MAAMA,KAAK,CAAC;AAAA,oBACpC;AAAA,oBACA,iBAAiB;AAAA,sBACfiB,QAAQ;AAAA,oBAAA;AAAA,kBACV;AAAA,gBAEJ;AAAA,gBACA,iBAAiB;AAAA,kBACfohB,OAAO,CACL,MAAM;AACJjqB,4BAAM,iDAAiD;AAAA,kBAAA,CACxD;AAAA,kBAEHykC,MAAM,CACJ,MAAM;AACJzkC,4BAAM,gDAAgD;AAAA,kBAAA,GAExD,iCACA,gCAAgC;AAAA,kBAElCR,IAAI;AAAA,oBACF,SAAW;AAAA,sBACTkQ,SAAS,CAAC,wBAAwB;AAAA,oBACpC;AAAA,oBACA,sBAAsB;AAAA,sBACpB7G,QAAQ;AAAA,oBAAA;AAAA,kBACV;AAAA,gBACF;AAAA,cACF;AAAA,YAEJ;AAAA,YACA,SAAW;AAAA,cACT27B,SAAS;AAAA,cACTD,QAAQ;AAAA,gBACNU,UAAU;AAAA,kBACRT,SAAS;AAAA,kBACTD,QAAQ;AAAA,oBACNW,MAAM;AAAA,sBACJjb,OAAO,CACL,MAAM;AACJjqB,gCAAM,+CAA+C;AAAA,sBAAA,CACtD;AAAA,sBAEHykC,MAAM,CACJ,MAAM;AACJzkC,gCAAM,8CAA8C;AAAA,sBAAA,CACrD;AAAA,sBAEHR,IAAI;AAAA,wBACF,aAAe;AAAA,0BACbqJ,QAAQ;AAAA,wBACV;AAAA,wBACA,kBAAkB;AAAA,0BAChB6G,SAAS;AAAA,0BACT7G,QAAQ;AAAA,wBACV;AAAA,wBACA,UAAY;AAAA,0BACV6G,SAAS;AAAA,0BACT7G,QAAQ;AAAA,wBAAA;AAAA,sBACV;AAAA,oBAEJ;AAAA,oBACAs8B,aAAa;AAAA,sBACXlb,OAAO,CACL,MAAM;AACJjqB,gCACE,sDACF;AAAA,sBAAA,CACD;AAAA,sBAEHykC,MAAM,CACJ,MAAM;AACJzkC,gCACE,qDACF;AAAA,sBAAA,CACD;AAAA,sBAEHR,IAAI;AAAA,wBACF,oBAAoB;AAAA,0BAClBqJ,QAAQ;AAAA,wBACV;AAAA,wBACA,kBAAkB;AAAA,0BAChB6G,SAAS;AAAA,wBACX;AAAA,wBACA,UAAY;AAAA,0BACVA,SAAS;AAAA,wBAAA;AAAA,sBACX;AAAA,oBACF;AAAA,kBACF;AAAA,gBAEJ;AAAA,gBACA01B,OAAO;AAAA,kBACLnb,OAAO,CACL,MAAM;AACJjqB,4BAAM,sCAAsC;AAAA,kBAAA,GAE9C,uBACA,sBAAsB;AAAA,kBAExBykC,MAAM,CACJ,MAAM;AACJzkC,4BAAM,qCAAqC;AAAA,kBAAA,CAC5C;AAAA,kBAEHR,IAAI;AAAA,oBACF,kBAAkB;AAAA,sBAChBkQ,SAAS;AAAA,oBACX;AAAA,oBACA,UAAY;AAAA,sBACVA,SAAS;AAAA,oBAAA;AAAA,kBACX;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEJ,CAAC;ACnrBM,SAAS21B,mBACdC,kBAC+B;AAC/B,MAAI,CAACA;AACG,UAAA,IAAI7iC,MAAM,iDAAiD;AAEnE,QAAM8iC,YAAYD,iBAAiBE,IAAIx5B,KAAKy5B,aAAa;AAGzD,MAAI,CAACF;AACG,UAAA,IAAI9iC,MAAM,qDAAqD;AAEvE,QAAMijC,gBAAgBH,UAAUI,QAAQ35B,KACrC45B,CAAUA,UAAAA,MAAM1lC,SAAS,UAC5B;AACA,MAAI,CAACwlC;AACG,UAAA,IAAIjjC,MAAM,0DAA0D;AAEtEojC,QAAAA,SAASH,cAAc/1B,KAAK61B;AAClC,MAAI,CAACK;AACG,UAAA,IAAIpjC,MACR,+DACF;AAEF,QAAMqjC,WAAWD,OAAO75B,KAAM+5B,CAAeA,eAAAA,WAAW7lC,SAAS,MAAM;AAGvE,MAAI,CAAC4lC;AACG,UAAA,IAAIrjC,MAAM,0CAA0C;AAEtDujC,QAAAA,oBAAqBH,OAAOjvB,OAC/BmvB,CAAAA,eAAeA,WAAW7lC,SAAS,MACtC,KAAK,CAAyB,GACxB+lC,mBAAoBX,iBAAiBE,IAAI5uB,OAC5CgvB,CAAUA,UAAAA,MAAM1lC,SAASqlC,UAAUrlC,IACtC,KAAK,CAAyB;AACvB,SAAA;AAAA,IACLoC,QAAQ4jC,qBAAqBX,SAAS;AAAA,IACtCxtB,YAAYouB,yBAAyBL,QAAQ;AAAA,IAC7CnzB,OAAOyzB,wBAAwBb,SAAS;AAAA,IACxCrkC,OAAOqkC;AAAAA,IACP/uB,MAAMsvB;AAAAA,IACN1vB,cAAckvB;AAAAA,IACdxzB,eAAek0B;AAAAA,IACfz/B,cAAc0/B;AAAAA,IACd/zB,aAAc4zB,SAA4B5zB;AAAAA,EAC5C;AACF;AAEA,SAASg0B,qBAAqBX,WAA6B;AACzD,QAAMc,aAAad,UAAUI,QAAQ35B,KAClCs6B,CAAYA,YAAAA,QAAQpmC,SAAS,OAChC;AACA,MAAI,CAACmmC;AACG,UAAA,IAAI5jC,MACR,wEACF;AAEF,QAAM8jC,aACJF,WAAW12B,KAAK+F,SAAS9C,QACzByzB,WAAW12B,KAAK+F,QAAQ9C,MAAMgE,OAC3BpV,CAA2BA,UAAAA,MAAMd,KACpC;AACE,MAAA,CAAC6lC,cAAcA,WAAWrjC,WAAW;AACjC,UAAA,IAAIT,MACR,4FAEF;AAEK8jC,SAAAA;AACT;AAEA,SAASJ,yBAAyBL,UAA4B;AAC5D,SAAQA,SAAiB/tB;AAC3B;AAEA,SAASquB,wBAAwBb,WAA6B;AAC5D,QAAMiB,YAAYjB,UAAUI,QAAQ35B,KACjCs6B,CAAYA,YAAAA,QAAQpmC,SAAS,UAChC;AACA,MAAI,CAACsmC;AACG,UAAA,IAAI/jC,MACR,2EACF;AAEF,QAAMgkC,YACJD,UAAU72B,KAAK+F,SAAS9C,QACxB4zB,UAAU72B,KAAK+F,QAAQ9C,KAAKgE,OAAQhE,CAA0BA,SAAAA,KAAKlS,KAAK;AAC1E,MAAI,CAAC+lC;AACG,UAAA,IAAIhkC,MAAM,mDAAmD;AAE9DgkC,SAAAA;AACT;AAEA,SAAShB,cAAc91B,MAA0C;AAC3DA,SAAAA,KAAKA,OACA81B,cAAc91B,KAAKA,IAAI,IAG5BA,KAAKzP,SAAS,UACTyP,OAGF;AACT;ACnDO,SAAS+2B,aACdC,YACmB;AACZA,SAAAA;AACT;AAEA,MAAMC,qBAAqB,OAAO54B,oBAAAA,CAAqB,UACjD64B,mBAAmB,OAAO74B,oBAAAA,CAAqB,QAE/C84B,uBAA+C;AAAA,EACnDC,OAAOH;AAAAA,EACPI,KAAKH;AACP,GAEMI,cAAsC;AAAA,EAC1C,CAACL,kBAAkB,GAAG;AAAA,EACtB,CAACC,gBAAgB,GAAG;AACtB,GAEMK,sBAA8C;AAAA,EAClDH,OAAO;AAAA,EACPC,KAAK;AACP;AAwDO,SAASG,2BACdrhC,QACc;AACP,SAAA;AAAA,IACLoM,aAAapM,OAAOoM,YAAYjR,IAAK8b,CAAgB,gBAAA;AAAA,MACnD7c,MAAM6c,WAAW7c;AAAAA,MACjBylC,QAAQ5oB,WAAW4oB,OAAO1kC,IAAK2kC,CAAW,WAAA;AAAA,QACxC1lC,MAAM0lC,MAAM1lC;AAAAA,QACZyP,MAAMi2B,MAAMj2B,KAAKy3B;AAAAA,MAAAA,EACjB;AAAA,MACF1wB,OAAOqG,WAAWrG;AAAAA,IAAAA,EAClB;AAAA,IACFxV,OAAO;AAAA,MACLhB,MAAM4F,OAAO5E,MAAMhB;AAAAA,IACrB;AAAA,IACAqG,cAAcT,OAAOS,aAAatF,IAAKuF,CAAiB,iBAAA;AAAA,MACtDtG,MAAMsG,YAAYtG;AAAAA,MAClBylC,QAAQn/B,YAAYm/B,OAAO1kC,IAAK2kC,CAAW,WAAA;AAAA,QACzC1lC,MAAM0lC,MAAM1lC;AAAAA,QACZyP,MAAMi2B,MAAMj2B,KAAKy3B;AAAAA,MAAAA,EACjB;AAAA,MACF1wB,OAAOlQ,YAAYkQ;AAAAA,IAAAA,EACnB;AAAA,IACFqB,YAAYjS,OAAOiS,WAAW9W,IAAK+W,CAAe,eAAA;AAAA,MAChD9X,MAAM8X,UAAUtX;AAAAA,MAChBgW,OAAOsB,UAAUtB;AAAAA,MACjBhW,OAAOsX,UAAUtX;AAAAA,IAAAA,EACjB;AAAA,IACFoR,eAAehM,OAAOgM,cAAc7Q,IAAKqM,CAAkB,kBAAA;AAAA,MACzDpN,MAAMoN,aAAapN;AAAAA,MACnBylC,QAAQr4B,aAAaq4B,OAAO1kC,IAAK2kC,CAAW,WAAA;AAAA,QAC1C1lC,MAAM0lC,MAAM1lC;AAAAA,QACZyP,MAAMi2B,MAAMj2B,KAAKy3B;AAAAA,MAAAA,EACjB;AAAA,MACF1wB,OAAOpJ,aAAaoJ;AAAAA,IAAAA,EACpB;AAAA,IACFF,MAAM;AAAA,MACJtW,MAAM4F,OAAO0Q,KAAKtW;AAAAA,IACpB;AAAA,IACAoC,QAAQwD,OAAOxD,OAAOrB,IAAKO,CAAW,WAAA;AAAA,MACpCtB,MAAMsB,MAAMd;AAAAA,MACZgW,OAAOlV,MAAMkV;AAAAA,MACbhW,OAAOc,MAAMd;AAAAA,IAAAA,EACb;AAAA,IACFiS,OAAO7M,OAAO6M,MAAM1R,IAAK2R,CAAU,UAAA;AAAA,MACjC1S,MAAM0S,KAAKlS;AAAAA,MACXgW,OAAO9D,KAAK8D;AAAAA,MACZhW,OAAOkS,KAAKlS;AAAAA,IAAAA,EACZ;AAAA,EACJ;AACF;AAUO,SAAS2mC,sCAEdV,YAA+D;AAC/D,QAAMpgC,eACJogC,YAAYpgC,cAActF,IAAKuF,iBAC7B8gC,WAAW;AAAA,IACT33B,MAAM;AAAA;AAAA;AAAA,IAGNzP,MAAM4mC,qBAAqBtgC,YAAYtG,IAAI,KAAKsG,YAAYtG;AAAAA,IAC5DwW,OACElQ,YAAYkQ,UAAUzT;AAAAA;AAAAA,MAElBikC,oBAAoB1gC,YAAYtG,IAAI;AAAA,QACpCsG,YAAYkQ;AAAAA,IAClBivB,QACEn/B,YAAYm/B,QAAQ1kC,IAAK2kC,CAAW,WAAA;AAAA,MAClC1lC,MAAM0lC,MAAM1lC;AAAAA,MACZyP,MAAMi2B,MAAMj2B;AAAAA,IACd,EAAE,KAAK,CAAA;AAAA,EAAA,CACV,CACH,KAAK,CAAE,GAEHmC,gBACJ60B,YAAY70B,eAAe7Q,IAAKqM,CAAAA,iBAC9Bg6B,WAAW;AAAA,IACT33B,MAAM;AAAA;AAAA;AAAA,IAGNzP,MAAM4mC,qBAAqBx5B,aAAapN,IAAI,KAAKoN,aAAapN;AAAAA,IAE9DwW,OACEpJ,aAAaoJ,UAAUzT;AAAAA;AAAAA,MAEnBikC,oBAAoB55B,aAAapN,IAAI;AAAA,QACrCoN,aAAaoJ;AAAAA,IACnBivB,QACEr4B,aAAaq4B,QAAQ1kC,IAAK2kC,CAAW,WAAA;AAAA,MACnC1lC,MAAM0lC,MAAM1lC;AAAAA,MACZyP,MAAMi2B,MAAMj2B;AAAAA,IACd,EAAE,KAAK,CAAA;AAAA,EACV,CAAA,CACH,KAAK,CAAA,GAED43B,qBAAqBC,YAAY;AAAA,IACrC73B,MAAM;AAAA,IACNzP,MAAM;AAAA,IACNslC,IAAI,CACF,GAAGj/B,aAAatF,IAAKuF,CAAiB,iBAAA;AAAA,MAACmJ,MAAMnJ,YAAYtG;AAAAA,MAAM,GAC/D;AAAA,MACEyP,MAAM;AAAA,MACNzP,MAAM;AAAA,MACNslC,IAAI1zB,cAAc7Q,IAAKqM,CAAkB,kBAAA;AAAA,QAACqC,MAAMrC,aAAapN;AAAAA,MAAAA,EAAM;AAAA,MACnEgC,OAAO;AAAA,QACL6V,YACE4uB,YAAY5uB,YAAY9W,IAAK+W,CAAe,eAAA;AAAA,UAC1CtB,OAAOsB,UAAUtB,SAAS+wB,UAAUzvB,UAAU9X,IAAI;AAAA,UAClDQ,OAAOsX,UAAU9X;AAAAA,QACnB,EAAE,KAAK,CAAE;AAAA,QACXgS,aACEy0B,YAAYz0B,aAAajR,IAAK8b,CAAgB,gBAAA;AAAA,UAC5C7c,MAAM6c,WAAW7c;AAAAA,UACjByP,MAAM;AAAA,UACN+G,OAAOqG,WAAWrG;AAAAA,UAClBivB,QACE5oB,WAAW4oB,QAAQ1kC,IAAK2kC,CAAW,WAAA;AAAA,YACjC1lC,MAAM0lC,MAAM1lC;AAAAA,YACZyP,MAAMi2B,MAAMj2B;AAAAA,UACd,EAAE,KAAK,CAAA;AAAA,QACX,EAAE,KAAK,CAAA;AAAA,MACX;AAAA,MACAgD,OACEg0B,YAAYh0B,OAAO1R,IAAK2R,CAAU,UAAA;AAAA,QAChClS,OAAOkS,KAAK1S;AAAAA,QACZwW,OAAO9D,KAAK8D,SAAS+wB,UAAU70B,KAAK1S,IAAI;AAAA,MAC1C,EAAE,KAAK,CAAE;AAAA,MACXoC,QACEqkC,YAAYrkC,QAAQrB,IAAKO,CAAW,WAAA;AAAA,QAClCd,OAAOc,MAAMtB;AAAAA,QACbwW,OAAOlV,MAAMkV,SAAS+wB,UAAUjmC,MAAMtB,IAAI;AAAA,MAC5C,EAAE,KAAK,CAAA;AAAA,IACV,CAAA;AAAA,EAAA,CAEJ,GAEK4F,SAAS4hC,OAAalwB,QAAQ;AAAA,IAClCC,OAAO,CAAC8vB,oBAAoB,GAAGhhC,cAAc,GAAGuL,aAAa;AAAA,EAAA,CAC9D,EAAE4F,IAAI,eAAe,GAEhBiwB,YAAYtC,mBAAmBv/B,MAAM;AAEpC,SAAA;AAAA,IACL,GAAG6hC;AAAAA,IACHphC,cAAcohC,UAAUphC,aAAatF,IAAKuF,iBACxCygC,YAAYzgC,YAAYtG,IAAI,MAAM+C,SAC7B;AAAA,MACC,GAAGuD;AAAAA,MACHtG,MAAM+mC,YAAYzgC,YAAYtG,IAAI;AAAA,MAClCyP,MAAM;AAAA,QACJ,GAAGnJ,YAAYmJ;AAAAA,QACfzP,MAAM+mC,YAAYzgC,YAAYtG,IAAI;AAAA,MAAA;AAAA,QAGtCsG,WACN;AAAA,IACAsL,eAAe61B,UAAU71B,cAAc7Q,IAAKqM,kBAC1C25B,YAAY35B,aAAapN,IAAI,MAAM+C,SAC9B;AAAA,MACC,GAAGqK;AAAAA,MACHpN,MAAM+mC,YAAY35B,aAAapN,IAAI;AAAA,IAAA,IAErCoN,YACN;AAAA,EACF;AACF;ACtSA,MAAMtN,UAAQC,cAAc,kBAAkB,GAOjC2nC,kBAAkB7/B,MAAM;AAAA,EACnC0P,OAAO;AAAA,IACLtP,SAAS,CAAC;AAAA,IAWVg7B,QAAQ,CAAC;AAAA,IAoBTE,OAAO,CAAC;AAAA,IAKRD,SAAS,CAAA;AAAA,EAUX;AAAA,EACA1zB,SAAS;AAAA,IACP,mBAAmB6zB,OAAO;AAAA,MACxB/xB,UAAUA,CAAC;AAAA,QAACrJ;AAAAA,QAASP;AAAAA,MAAAA,MACnBA,MAAM+H,SAAS,oBAAoB/H,MAAM4J,WAAWrJ,QAAQqJ;AAAAA,IAAAA,CAC/D;AAAA,IACD,cAAciyB,eAAe,CAAC;AAAA,MAAC77B;AAAAA,MAAO87B;AAAAA,IAAAA,MAAa;AAC7C97B,YAAM+H,SAAS,WACjB+zB,QAAQC,KAAK;AAAA,QAACh0B,MAAM;AAAA,QAAS6O,OAAO5W,MAAM4W;AAAAA,MAAAA,CAAM;AAAA,IAAA,CAEnD;AAAA,IACD,8BAA8BmlB,KAAK;AAAA,MAACh0B,MAAM;AAAA,IAAA,CAAwB;AAAA,IAClE,kBAAkB8zB,eAAe,CAAC;AAAA,MAACt7B;AAAAA,MAASu7B;AAAAA,IAAAA,MAAa;AACvD,iBAAWmE,QAAQ1/B,QAAQ2/B;AACzBpE,gBAAQC,KAAK;AAAA,UACXh0B,MAAM;AAAA,UACN8P,SAASooB,KAAKpoB;AAAAA,UACdjS,UAAUq6B,KAAKnnC;AAAAA,QAAAA,CAChB;AAAA,IAAA,CAEJ;AAAA,IACD,2BAA2B6iC,OAAO;AAAA,MAChCuE,kBAAkB,CAAA;AAAA,IAAA,CACnB;AAAA,IACD,kBAAkBvE,OAAO;AAAA,MACvBuE,kBAAkBA,CAAC;AAAA,QAAC3/B;AAAAA,QAASP;AAAAA,MAAAA,MAAW;AAGtC,YAFA47B,YAAY57B,OAAO,OAAO,GAEtBO,QAAQ2/B,iBAAiB5kC,WAAW;AACtC,iBAAO,CACL;AAAA,YACE6sB,aAAanoB,MAAMmoB;AAAAA,YACnBrvB,OAAOkH,MAAMlH;AAAAA,YACb+e,SAAS,CAAC7X,MAAM4W,KAAK;AAAA,UAAA,CACtB;AAIL,cAAMupB,WAAW5/B,QAAQ2/B,iBAAiBnkC,GAAG,EAAE;AAE3CokC,eAAAA,YAAYA,SAAShY,gBAAgBnoB,MAAMmoB,cACtC5nB,QAAQ2/B,iBAAiB1jC,MAAM,GAAG,EAAE,EAAEiH,OAAO;AAAA,UAClD3K,OAAOkH,MAAMlH;AAAAA,UACbqvB,aAAagY,SAAShY;AAAAA,UACtBtQ,SAAS,CAAC,GAAGsoB,SAAStoB,SAAS7X,MAAM4W,KAAK;AAAA,QAAA,CAC3C,IAGIrW,QAAQ2/B,iBAAiBz8B,OAAO;AAAA,UACrC3K,OAAOkH,MAAMlH;AAAAA,UACbqvB,aAAanoB,MAAMmoB;AAAAA,UACnBtQ,SAAS,CAAC7X,MAAM4W,KAAK;AAAA,QAAA,CACtB;AAAA,MAAA;AAAA,IACH,CACD;AAAA,IACD,8BAA8B+kB,OAAO;AAAA,MACnCyE,oBAAoB,CAAA;AAAA,IAAA,CACrB;AAAA,IACD,eAAezE,OAAO;AAAA,MACpByE,oBAAoBA,CAAC;AAAA,QAAC7/B;AAAAA,QAASP;AAAAA,MAAAA,MAC7BA,MAAM+H,SAAS,UACX,CAAC,GAAGxH,QAAQ6/B,oBAAoBpgC,KAAK,IACrCO,QAAQ6/B;AAAAA,IAAAA,CACf;AAAA,IACD,6BAA6BvE,eAAe,CAAC;AAAA,MAACt7B;AAAAA,MAASu7B;AAAAA,IAAAA,MAAa;AAClE,iBAAW97B,SAASO,QAAQ6/B;AAC1BtE,gBAAQC,KAAK/7B,KAAK;AAAA,IAErB,CAAA;AAAA,EACH;AAAA,EACAqgC,QAAQ;AAAA,IACN,iBAAiBC,aAIf,CAAC;AAAA,MAAC7E;AAAAA,MAAOhG;AAAAA,IAAAA,MAAc;AACjB8K,YAAAA,gBAAgB9E,MAAM17B,YAAYyT;AAElCzT,aAAAA,MAAAA,YAAYyT,QAASc,CAAO,OAAA;AAC5BA,WAAGvM,SAAS,iBAAiBuM,GAAGvM,SAAS,gBAC3C0tB,SAAS;AAAA,UAAC1tB,MAAM;AAAA,QAAS,CAAA,IAEzB0tB,SAAS;AAAA,UAAC1tB,MAAM;AAAA,QAAA,CAAa,GAE/Bw4B,cAAcjsB,EAAE;AAAA,MAAA,GAGX,MAAM;AACXmnB,cAAM17B,YAAYyT,QAAQ+sB;AAAAA,MAC5B;AAAA,IAAA,CACD;AAAA,IACD,sBAAsBD,aAAa,CAAC;AAAA,MAAC7K;AAAAA,IAAAA,MAAc;AAC3C+K,YAAAA,WAAWC,YACf,MAAM;AACK,iBAAA;AAAA,UAAC14B,MAAM;AAAA,QAAA,CAAwB;AAAA,MAAA,GAE1C24B,QAAQC,IAAIC,aAAa,SAAS,MAAM,CAC1C;AAEA,aAAO,MAAM;AACXC,sBAAcL,QAAQ;AAAA,MACxB;AAAA,IACD,CAAA;AAAA,EACH;AAAA,EACAjE,QAAQ;AAAA,IACN,gBAAgBuE,CAAC;AAAA,MAACvgC;AAAAA,UAAaA,QAAQqJ;AAAAA,IACvC,aAAam3B,QAAQ;AAAA,MAACC,QAAQ;AAAA,IAAA,CAAS;AAAA,IACvC,wBAAwBC,CAAC;AAAA,MAAC1gC;AAAAA,IAAAA,MACxB1E,OAAOqlC,cAAc3gC,QAAQR,WAAW;AAAA,EAC5C;AAAA,EACAohC,QAAQ;AAAA,IACN,iBAAiBT,QAAQC,IAAIC,aAAa,SAAS,IAAI;AAAA,EAAA;AAE3D,CAAC,EAAEnE,cAAc;AAAA,EACfv1B,IAAI;AAAA,EACJ3G,SAASA,CAAC;AAAA,IAACk7B;AAAAA,EAAAA,OAAY;AAAA,IACrByE,kBAAkB,CAAE;AAAA,IACpBE,oBAAoB,CAAE;AAAA,IACtBx2B,UAAU6xB,MAAM7xB;AAAAA,IAChB1L,QAAQu9B,MAAMv9B;AAAAA,IACd6B,aAAa07B,MAAM17B;AAAAA,EAAAA;AAAAA,EAErBnI,IAAI;AAAA,IACF,mBAAmB;AAAA,MACjBkQ,SAAS,CAAC,iBAAiB;AAAA,IAAA;AAAA,EAE/B;AAAA,EACAC,MAAM;AAAA,EACN40B,QAAQ;AAAA,IACNqE,QAAQ;AAAA,MACNpE,SAAS;AAAA,MACTwE,QAAQ;AAAA,QACNC,KAAK;AAAA,QACL5F,OAAOA,CAAC;AAAA,UAACl7B;AAAAA,QAAAA,OAAc;AAAA,UAACR,aAAaQ,QAAQR;AAAAA,QAAW;AAAA,MAC1D;AAAA,MACA48B,QAAQ;AAAA,QACNW,MAAM;AAAA,UACJjb,OAAO,CACL,MAAM;AACJjqB,oBAAM,qBAAqB;AAAA,UAAA,CAC5B;AAAA,UAEHykC,MAAM,CACJ,MAAM;AACEzkC,oBAAA,oBAAoB,GAC1BA,QAAM,uBAAuB;AAAA,UAAA,CAC9B;AAAA,UAEHR,IAAI;AAAA,YACFopC,QAAQ;AAAA,cACN//B,QAAQ;AAAA,YAAA;AAAA,UACV;AAAA,QAEJ;AAAA,QACA+/B,QAAQ;AAAA,UACN/V,OAAO;AAAA,YACL,iBAAiB;AAAA,cACfhqB,QAAQ;AAAA,cACR6G,SAAS,CACP,MAAM;AACJ1P,wBAAM,sBAAsB;AAAA,cAC7B,CAAA;AAAA,YAAA;AAAA,UAGP;AAAA,UACAR,IAAI;AAAA,YACF,cAAc;AAAA,cACZqJ,QAAQ;AAAA,YACV;AAAA,YACA,QAAU;AAAA,cACRA,QAAQ;AAAA,cACRqgC,SAAS;AAAA,YAAA;AAAA,UACX;AAAA,QACF;AAAA,MACF;AAAA,IAEJ;AAAA,IACAC,WAAW;AAAA,MACT3E,SAAS;AAAA,MACTD,QAAQ;AAAA,QACN,MAAQ;AAAA,UACNta,OAAO,CACL,MAAM;AACJjqB,oBAAM,wBAAwB;AAAA,UAAA,CAC/B;AAAA,UAEHykC,MAAM,CACJ,MAAM;AACJzkC,oBAAM,uBAAuB;AAAA,UAAA,CAC9B;AAAA,UAEHR,IAAI;AAAA,YACFgf,OAAO,CACL;AAAA,cACElP,OAAO;AAAA,cACPI,SAAS,CAAC,eAAe,gBAAgB;AAAA,cACzC7G,QAAQ;AAAA,YAAA,GAEV;AAAA,cACE6G,SAAS,CAAC,cAAc,gBAAgB;AAAA,cACxC7G,QAAQ;AAAA,YACT,CAAA;AAAA,UAAA;AAAA,QAGP;AAAA,QACA,yBAAyB;AAAA,UACvBohB,OAAO,CACL,MAAM;AACJjqB,oBAAM,yCAAyC;AAAA,aAEjD,4BAA4B;AAAA,UAE9BykC,MAAM,CACJ,MAAM;AACJzkC,oBAAM,wCAAwC;AAAA,UAAA,CAC/C;AAAA,UAEHgpC,QAAQ;AAAA,YACNC,KAAK;AAAA,UACP;AAAA,UACAzpC,IAAI;AAAA,YACF,yBAAyB;AAAA,cACvB8P,OAAO85B,IAAI,CACTC,IAAI,cAAc,GAClBA,IAAI,WAAW,GACf,sBAAsB,CACvB;AAAA,cACDxgC,QAAQ;AAAA,cACR6G,SAAS,CACP,6BACA,8BACA,kBACA,yBAAyB;AAAA,YAE7B;AAAA,YACA,OAAS,CACP;AAAA,cACEJ,OAAO;AAAA,cACPI,SAAS,CAAC,eAAe,gBAAgB;AAAA,YAAA,GAE3C;AAAA,cACEA,SAAS,CAAC,cAAc,gBAAgB;AAAA,YACzC,CAAA;AAAA,UAAA;AAAA,QAEL;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEJ,CAAC,GC7RK1P,UAAQC,cAAc,cAAc;AAE1BqpC,SAAAA,kBACdhqC,QACAoI,aACA;AACA,QAAM+P,QAAQ/P,YAAYG,YAAY,EAAEM,QAAQrC;AAEf,SAAA;AAAA,IAC/B5B,OAAOA,MAAY;AACjBwD,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNrQ;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAykC,MAAMA,MAAY;AAChBr8B,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNrQ;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAiqC,YAAazxB,CAAuB,SAAA;AAClCpQ,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNqI,WAAWF;AAAAA,QACb;AAAA,QACAxY;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAkqC,YAAa9iC,CAA2B,aAAA;AACtCgB,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNjJ;AAAAA,QACF;AAAA,QACApH;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAmqC,kBAAmBjoC,CAAwB,UAAA;AACzCkG,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNnO;AAAAA,QACF;AAAA,QACAlC;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAoqC,cAAe5xB,UACIgD,kBAAkB;AAAA,MACjCD,qBAAqBnT,YAAYG,YAAY;AAAA,MAC7CkT,qBAAqBzb;AAAAA,IACtB,CAAA,EAEe4b,KAAK9C,iBAAiBH,SAASH,IAAI;AAAA,IAErD5V,OAAOA,MAAgB;AACrB,YAAMsL,WAAWsN,kBAAkB;AAAA,QACjCD,qBAAqBnT,YAAYG,YAAY;AAAA,QAC7CkT,qBAAqBzb;AAAAA,MAAAA,CACtB;AAEM,aAAA,CACL,GAAGkO,SAAS0N,KAAK3C,mBACjB,GAAG/K,SAAS0N,KAAK9C,gBAAgB;AAAA,IAErC;AAAA,IACAuR,MAAMA,MAAY;AAChBjiB,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAmqB,MAAMA,MAAY;AAChB/hB,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,QACR;AAAA,QACArQ;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACA2nB,QAASjjB,CAAqC,cAAA;AACtC2lC,YAAAA,iBAAiB9+B,aAAa7G,WAAW1E,MAAM;AACjDqqC,uBACFlxB,WAAWwO,OAAO3nB,QAAQqqC,cAAc,IAExClxB,WAAWiJ,SAASpiB,MAAM,GAE5BA,OAAOqe,SAAS;AAAA,IAClB;AAAA,IACAzY,YAAYA,MAAqC;AAC/C,UAAI5F,OAAO0E,WAAW;AACd9C,cAAAA,QAAQoE,KAAKskC,WACjBtqC,QACAA,OAAO0E,UAAUE,MAAMC,KAAKC,MAAM,GAAG,CAAC,CACxC;AACIlD,YAAAA;AACF,iBAAOqB,eACL,CAACrB,KAAK,GACNuW,MAAMvW,MAAMhB,MACZuM,qBAAqBiL,IAAIpY,MAAM,CACjC,EAAE,CAAC;AAAA,MAAA;AAAA,IAIT;AAAA,IACA+F,YAAYA,MAAqC;AAC/C,UAAI/F,OAAO0E,WAAW;AACd9C,cAAAA,QAAQoE,KAAKskC,WACjBtqC,QACAA,OAAO0E,UAAUE,MAAMC,KAAKC,MAAM,GAAG,CAAC,CACxC;AACIlD,YAAAA,SAAS5B,OAAOsH,YAAY1F,KAAK;AACnBqB,iBAAAA,eACd,CAACrB,KAAK,GACNuW,MAAMvW,MAAMhB,MACZuM,qBAAqBiL,IAAIpY,MAAM,CACjC,EAAE,CAAC,EACYsC,SAAStC,OAAO0E,UAAUE,MAAMC,KAAK,CAAC,CAAC;AAAA,MAAA;AAAA,IAI5D;AAAA,IACA0lC,aAAaA,CACXl6B,MACAjP,UACS;AACLiP,UAAAA,KAAKzP,SAASuX,MAAMjB,KAAKtW;AAC3BwH,eAAAA,YAAY2I,KAAK;AAAA,UACfV,MAAM;AAAA,UACNuZ,eAAe;AAAA,YACbvZ,MAAM;AAAA,YACNrC,cAAc;AAAA,cACZpN,MAAMyP,KAAKzP;AAAAA,cACXQ;AAAAA,YAAAA;AAAAA,UAEJ;AAAA,UACApB;AAAAA,QAAAA,CACD,GAEMA,OAAO0E,YACTgD,sBAAsB;AAAA,UACrBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC1CxG;AAAAA,UACA2H,OAAO3H,OAAO0E;AAAAA,QACf,CAAA,GAAGE,MAAMC,QAAQ,CAAA,IAClB,CAAE;AAGR,UAAI,CAAC7E,OAAO0E;AACJ,cAAA,IAAIvB,MAAM,6BAA6B;AAE/C,YAAM,CAACyC,UAAU,IAAInE,MAAMyC,KACzBC,OAAOC,MAAMpE,QAAQ;AAAA,QACnBqE,IAAIrE,OAAO0E,UAAUE,MAAMC,KAAKC,MAAM,GAAG,CAAC;AAAA,QAC1CR,OAAQC,CAAAA,MAAMA,EAAE1C,UAAUsW,MAAMvW,MAAMhB;AAAAA,MACvC,CAAA,CACH,EAAE,CAAC,KAAK,CAAC+C,MAAS;AAClB,UAAI,CAACiC;AACG,cAAA,IAAIzC,MAAM,uBAAuB;AAEzC,UACEkN,KAAKzP,SAASuX,MAAMjB,KAAKtW,QACzB,CAACuX,MAAM3F,cAAczL,KAAMxD,CAAAA,MAAMA,EAAE3C,SAASyP,KAAKzP,IAAI;AAE/C,cAAA,IAAIuC,MACR,yDACF;AAkBIZ,YAAAA,QAhBQhB,aACZ,CACE;AAAA,QACEF,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,QACrDlV,OAAOsW,MAAMvW,MAAMhB;AAAAA,QACnB0B,UAAU,CACR;AAAA,UACEjB,MAAM+G,YAAYG,cAAcM,QAAQkO,aAAa;AAAA,UACrDlV,OAAOwO,KAAKzP;AAAAA,UACZ,GAAIQ,SAAgB,CAAA;AAAA,QACrB,CAAA;AAAA,MAAA,CAEJ,GAEH;AAAA,QAACI,aAAa4G,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,MAClD,CAAA,EAAE,CAAC,EACiBlE,SAAS,CAAC,GACxBkoC,iBAAiBxqC,OAAO0E,UAAUE,MAAMC,KAAKC,MAAM,GAAG,CAAC,GACvDwtB,cAAa/vB,MAAMV,UAAUsW,MAAMjB,KAAKtW,MACxC6pC,YAAYzkC,KAAKoS,IAAIpY,QAAQwqC,cAAc;AAI7ClY,aAAAA,eAAcmY,UAAU5oC,UAAUsW,MAAMjB,KAAKtW,SAC/CF,QACE,wEACF,GACAV,OAAO2oB,KAAK;AAAA,QAACC,UAAU;AAAA,QAAG1B,MAAM;AAAA,MAAY,CAAA,IAG9C/N,WAAWI,YAAYvZ,QAAQuC,OAAO;AAAA,QACpColB,QAAQ;AAAA,QACRtjB,IAAIrE,OAAO0E;AAAAA,MAAAA,CACZ,GACD1E,OAAOqe,YAEAre,OAAO0E,YACTgD,sBAAsB;AAAA,QACrBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,QAC1CxG;AAAAA,QACA2H,OAAO3H,OAAO0E;AAAAA,MACf,CAAA,GAAGE,MAAMC,QAAQ,CAAA,IAClB,CAAE;AAAA,IACR;AAAA,IACA+iB,aAAaA,CACXvX,MACAjP,WAEAgH,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNzO,OAAO;AAAA,UACLC,OAAOwO,KAAKzP;AAAAA,UACZ,GAAIQ,SAAgB,CAAA;AAAA,QACtB;AAAA,QACAsmB,WAAW;AAAA,MACb;AAAA,MACA1nB;AAAAA,IAAAA,CACD,GAEMA,OAAO0E,YACTgD,sBAAsB;AAAA,MACrBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,MAC1CxG;AAAAA,MACA2H,OAAO3H,OAAO0E;AAAAA,IACf,CAAA,GAAGE,MAAMC,QAAQ,CAAA,IAClB,CAAA;AAAA,IAEN6lC,eAAgBxoC,CAA2B,UAAA;AACrC,UAAA;AACF,eAAOuF,cAAc;AAAA,UAACzH;AAAAA,UAAQkC;AAAAA,QAAAA,CAAM;AAAA,MAAA,QAC9B;AAEC,eAAA;AAAA,MAAA;AAAA,IAEX;AAAA,IACAyoC,cAAevjC,CAA8B,aAAA;AACvC,UAAA;AACF,eAAOD,iBAAiB;AAAA,UAACnH;AAAAA,UAAQoH;AAAAA,QAAAA,CAAS;AAAA,MAAA,QACpC;AAEC,eAAA;AAAA,MAAA;AAAA,IAEX;AAAA,IACAwE,QAAShF,CAAAA,YACA,CAAC,CAACuR,MAAMvW,MAAMhB,MAAMuX,MAAMjB,KAAKtW,IAAI,EAAE+X,SAAS/R,QAAQ/E,KAAK;AAAA,IAEpE+oC,YACE/lC,CAIG,SAAA;AACH,YAAMgmC,YAAYt/B,aAChB;AAAA,QAAC3G,OAAO;AAAA,UAACC;AAAAA,UAAMkD,QAAQ;AAAA,QAAC;AAAA,QAAGF,QAAQ;AAAA,UAAChD;AAAAA,UAAMkD,QAAQ;AAAA,QAAA;AAAA,SAClD/H,MACF;AACA,UAAI6qC,WAAW;AACb,cAAM,CAACjpC,OAAOqC,SAAS,IAAIE,OAAOQ,KAChC3E,QACA6qC,UAAUjmC,MAAMC,KAAKC,MAAM,GAAG,CAAC,CACjC;AACA,YAAIlD,SAASqC,aAAa,OAAOrC,MAAMP,QAAS,UAAU;AACxD,cAAIwD,KAAKjB,WAAW,KAAKinC,UAAUjmC,MAAMC,KAAKjB,WAAW;AAChD,mBAAA,CACLX,eAAe,CAACrB,KAAK,GAAGuW,MAAMvW,MAAMhB,IAAI,EAAE,CAAC,GAC3C,CAAC;AAAA,cAACS,MAAMO,MAAMP;AAAAA,YAAAA,CAAK,CAAC;AAGxB,gBAAMypC,UAAU7nC,eACd,CAACrB,KAAK,GACNuW,MAAMvW,MAAMhB,MACZuM,qBAAqBiL,IAAIpY,MAAM,CACjC,EAAE,CAAC;AACCA,cAAAA,OAAOsH,YAAYwjC,OAAO,GAAG;AAC/B,kBAAMC,UAAUD,QAAQxoC,SAASuoC,UAAUjmC,MAAMC,KAAK,CAAC,CAAC;AACpDkmC,gBAAAA;AACK,qBAAA,CACLA,SACA,CAAC;AAAA,gBAAC1pC,MAAMO,MAAMP;AAAAA,iBAAO,YAAY;AAAA,gBAACA,MAAM0pC,QAAQ1pC;AAAAA,cAAAA,CAAK,CAAC;AAAA,UAAA;AAAA,QAG5D;AAAA,MACF;AAEK,aAAA,CAACsC,QAAWA,MAAS;AAAA,IAC9B;AAAA,IACAqnC,aACEpkC,CACwB,YAAA;AACpBjC,UAAAA;AACA,UAAA;AACF,cAAM,CAACgd,IAAI,IAAIlgB,MAAMyC,KACnBC,OAAOC,MAAMpE,QAAQ;AAAA,UACnBqE,IAAI,CAAE;AAAA,UACNC,OAAQC,CAAAA,MAAMA,EAAElD,SAASuF,QAAQvF;AAAAA,QAClC,CAAA,KAAK,CAAA,CACR,EAAE,CAAC,KAAK,CAACsC,MAAS;AACXsnC,eAAAA,YAAYthC,UAAU3J,QAAQ2hB,IAAI;AAAA,MAAA,QACnC;AAAA,MAAA;AAGDhd,aAAAA;AAAAA,IACT;AAAA,IACAsU,mBAAmBA,MAA4B;AAC7C,UAAI,CAACjZ,OAAO0E,aAAa1E,OAAO0E,UAAUE,MAAMC,KAAKjB,SAAS;AAC5D,eAAO,CAAE;AAEP,UAAA;AACF,cAAMqV,oBAA0C,CAAA,GAC1CiyB,QAAQ/mC,OAAOC,MAAMpE,QAAQ;AAAA,UACjCqE,IAAIrE,OAAO0E;AAAAA,UACXJ,OAAQK,CACNd,SAAAA,KAAKC,OAAOa,IAAI,KAChBA,KAAK/B,UAAUe,UACflC,MAAMC,QAAQiD,KAAK/B,KAAK,KACxB+B,KAAK/B,MAAMgB,SAAS;AAAA,QAAA,CACvB;AACD,mBAAW,CAACsT,MAAMrS,IAAI,KAAKqmC,OAAO;AAChC,gBAAM,CAACtpC,KAAK,IAAIuC,OAAOQ,KAAK3E,QAAQ6E,MAAM;AAAA,YAACwY,OAAO;AAAA,UAAA,CAAE;AAChDrd,iBAAOsH,YAAY1F,KAAK,KAC1BA,MAAMQ,UAAUiS,QAASqF,CAAQ,QAAA;AAE7B7V,iBAAKC,OAAOoT,IAAI,KAChBA,KAAKtU,SACLnB,MAAMC,QAAQwV,KAAKtU,KAAK,KACxBsU,KAAKtU,MAAM+V,SAASe,IAAIrY,IAAI,KAE5B4X,kBAAkB/Q,KAAKwR,GAAG;AAAA,UAAA,CAE7B;AAAA,QAAA;AAGET,eAAAA;AAAAA,MAAAA,QACD;AACN,eAAO,CAAE;AAAA,MAAA;AAAA,IAEb;AAAA,IACAkyB,oBACEC,oBAEOD,mBAAmB;AAAA,MAACnrC;AAAAA,MAAQyd,YAAY;AAAA,QAAC7c,MAAMwqC;AAAAA,MAAAA;AAAAA,IAAc,CAAE;AAAA,IAExEC,eAAeA,CAACh7B,MAAMjP,UAAU;AAC1B4iB,UAAAA;AAEG5F,aAAAA,OAAAA,mBAAmBpe,QAAQ,MAAM;AACtCgkB,gBAAQH,qCAAqC;AAAA,UAC3Chb,SAAS;AAAA,YACPkO,cAAc3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,YAChDvQ,QAAQ2R;AAAAA,UACV;AAAA,UACAlM,WAAW;AAAA,YAETwR,YAAY;AAAA,cAAC7c,MAAMyP,KAAKzP;AAAAA,cAAMQ,OAAOA,SAAS,CAAA;AAAA,YAAE;AAAA,YAChDpB;AAAAA,UAAAA;AAAAA,QACF,CACD;AAAA,MAAA,CACF,GACDA,OAAOqe,SAAAA,GAEA2F;AAAAA,IACT;AAAA,IACAiD,QAAQA,CACNviB,WACA0R,YACS;AACT,UAAI1R,WAAW;AACPiD,cAAAA,QAAQ4D,aAAa7G,WAAW1E,MAAM;AAGxC,YAAA,EADF2H,SAASA,MAAME,OAAOhD,KAAKjB,SAAS,KAAK+D,MAAM/C,MAAMC,KAAKjB,SAAS;AAE7D,gBAAA,IAAIT,MAAM,eAAe;AAEjC,YAAIwE,OAAO;AACT,cAAI,CAACyO,SAAStP,QAAQsP,SAAStP,SAAS,YAAY;AAClDpG,oBAAM,+BAA+B,GACrCyY,WAAW8N,OAAOjnB,QAAQ;AAAA,cACxBqE,IAAIsD;AAAAA,cACJgX,SAAS;AAAA,cACTxC,OAAO;AAAA,YAAA,CACR,GACDnc,OAAOqe,SAAS;AAChB;AAAA,UAAA;AAEEjI,mBAAStP,SAAS,aACpBpG,QAAM,sCAAsC,GAC5CyY,WAAW6N,YAAYhnB,QAAQ;AAAA,YAC7BqE,IAAIsD;AAAAA,YACJwU,OAAO;AAAA,YACP7X,OAAQK,CAAAA,SAEJ3E,OAAOsH,YAAY3C,IAAI,KACtB,CAAC3E,OAAOsH,YAAY3C,IAAI,KAAK2mC,UAAavoC,UAAU4B,IAAI;AAAA,UAAA,CAG9D,IAECyR,SAAStP,SAAS,eACpBpG,QAAM,wCAAwC,GAC9CyY,WAAW6N,YAAYhnB,QAAQ;AAAA,YAC7BqE,IAAIsD;AAAAA,YACJwU,OAAO;AAAA,YACP7X,OAAQK,CAAAA,SAEJA,KAAK9C,UAAUsW,MAAMjB,KAAKtW;AAAAA,YACzB,CAACZ,OAAOsH,YAAY3C,IAAI,KAAK2mC,UAAavoC,UAAU4B,IAAI;AAAA,UAAA,CAG9D,IAOC3E,OAAOsC,SAASsB,WAAW,MAC7B5D,OAAOsC,WAAW,CAACtC,OAAO6sB,mBAAmB;AAAA,YAACpU,YAAY,CAAA;AAAA,UAAA,CAAG,CAAC,IAEhEzY,OAAOqe,SAAS;AAAA,QAAA;AAAA,MAClB;AAAA,IAEJ;AAAA,IACAktB,kBACEl7B,CACS,SAAA;AACTjI,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNoN,YAAY;AAAA,YAAC7c,MAAMyP,KAAKzP;AAAAA,UAAAA;AAAAA,QAC1B;AAAA,QACAZ;AAAAA,MAAAA,CACD;AAAA,IACH;AAAA,IACAwrC,cAAcA,MAA8B;AAC1C,UAAIta,UAA2B;AAC/B,UAAIlxB,OAAO0E,WAAW;AACpB,cAAMysB,WAAW/jB,6BAA6BgL,IAAIpY,OAAO0E,SAAS;AAC9DysB,YAAAA;AACKA,iBAAAA;AAETD,kBAAUxpB,sBAAsB;AAAA,UAC9BlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,UAC1CxG;AAAAA,UACA2H,OAAO3H,OAAO0E;AAAAA,QACf,CAAA,GACD0I,6BAA6BoN,IAAIxa,OAAO0E,WAAWwsB,OAAO;AAAA,MAAA;AAErDA,aAAAA;AAAAA,IACT;AAAA,IACAua,UAAUA,MACDxoC,eACLjD,OAAOsC,UACP6V,MAAMvW,MAAMhB,MACZuM,qBAAqBiL,IAAIpY,MAAM,CACjC;AAAA,IAEF0rC,sBAAsBA,MACb,CAAC,CAAC1rC,OAAO0E,aAAaU,MAAM4M,YAAYhS,OAAO0E,SAAS;AAAA,IAEjEinC,qBAAqBA,MACZ,CAAC,CAAC3rC,OAAO0E,aAAaU,MAAM0Y,WAAW9d,OAAO0E,SAAS;AAAA,IAEhEqlB,aAAaA,MAAM;AACVA,aAAAA,YAAAA,GACP/pB,OAAOqe,SAAS;AAAA,IAClB;AAAA,IACAutB,aAAaA,MACJ3oC,eAAejD,OAAO4rC,eAAezzB,MAAMvW,MAAMhB,IAAI;AAAA,IAE9DirC,yBAAyBA,CACvBC,YACAC,eACG;AAEGC,YAAAA,SAASzgC,aAAaugC,YAAY9rC,MAAM,GACxCisC,SAAS1gC,aAAawgC,YAAY/rC,MAAM;AAGxBoF,aAAAA,MAAMshB,QAAQslB,MAAM,KAAK5mC,MAAMshB,QAAQulB,MAAM,KAG5B7mC,MAAMuT,SAASqzB,QAAQC,MAAM;AAAA,IAAA;AAAA,EAIxE;AAGF;AAEA,SAASd,mBAAmB;AAAA,EAC1BnrC;AAAAA,EACAyd;AAMF,GAAG;AACD,MAAI,CAACzd,OAAO0E,aAAa1E,OAAO0E,UAAUE,MAAMC,KAAKjB,SAAS;AACrD,WAAA;AAGL,MAAA;AACF,UAAMsnC,QAAQ,CACZ,GAAG/mC,OAAOC,MAAMpE,QAAQ;AAAA,MACtBqE,IAAIrE,OAAO0E;AAAAA,MACXJ,OAAQK,CAAAA,SAASd,KAAKC,OAAOa,IAAI;AAAA,IAAA,CAClC,CAAC;AAGAumC,QAAAA,MAAMtnC,WAAW,KAKnBsnC,MAAMnkC,KACJ,CAAC,CAACmQ,IAAI,MACJ,CAACsC,qBAAmBtC,IAAI,KAAK,CAACA,KAAKtU,SAASsU,KAAKtU,OAAOgB,WAAW,CACvE,EAEO,QAAA;AAEHsoC,UAAAA,oBAAoBhB,MAAM97B,OAAO,CAAC+8B,aAAa,CAAGtnC,EAAAA,IAAI,MAAM;AAChE,YAAM,CAACjD,KAAK,IAAIuC,OAAOQ,KAAK3E,QAAQ6E,MAAM;AAAA,QAACwY,OAAO;AAAA,MAAA,CAAE;AACpD,aAAIrd,OAAOsH,YAAY1F,KAAK,KAAKA,MAAMQ,WAC9B,CAAC,GAAG+pC,aAAa,GAAGvqC,MAAMQ,QAAQ,IAEpC+pC;AAAAA,IACT,GAAG,EAA0B;AAEtBjB,WAAAA,MAAM3jC,MAAM,CAAC,CAAC2P,IAAI,MAClBsC,qBAAmBtC,IAAI,IAEPA,KAAKtU,OAAOjB,IAC9ByqC,CAAAA,YACCF,kBAAkBx/B,KAAMgN,CAAAA,QAAQA,KAAKrY,SAAS+qC,OAAO,GAAGvqC,KAC5D,GAEqB8W,SAAS8E,WAAW7c,IAAI,IAPP,EAQvC;AAAA,EAAA,QACK;AACC,WAAA;AAAA,EAAA;AAEX;AC3fO,MAAMyrC,eAAe5jC,MAAM;AAAA,EAChC0P,OAAO;AAAA,IACL0rB,QAAQ,CAAC;AAAA,IACTC,SAAS,CAAA;AAAA,EAAC;AAEd,CAAC,EAAEiB,cAAc;AAAA,EACfv1B,IAAI;AAAA,EACJtP,IAAI;AAAA,IACF,KAAK;AAAA,MACHkQ,SAASi0B,KAAK,CAAC;AAAA,QAAC/7B;AAAAA,MAAAA,MAAWA,KAAK;AAAA,IAAA;AAAA,EAClC;AAEJ,CAAC;AC3FegkC,SAAAA,cACdlrC,OACA+W,OACApB,cACY;AACRw1B,MAAAA,aAA4C,MAC5CC,QAAQ;AACNC,QAAAA,kBAAkB,CACtBt0B,MAAMjB,KAAKtW,MACX,GAAGuX,MAAM3F,cAAc7Q,IAAK4B,CAAMA,MAAAA,EAAE3C,IAAI,CAAC,GAErC8rC,kBAAkB,CACtBv0B,MAAMvW,MAAMhB,MACZ,GAAGuX,MAAMlR,aAAatF,IAAK4B,CAAAA,MAAMA,EAAE3C,IAAI,CAAC;AAI1C,SAAIQ,UAAUuC,SACL;AAAA,IAAC6oC,OAAO;AAAA,IAAMD,YAAY;AAAA,IAAMnrC;AAAAA,EAAAA,IAGrC,CAACK,MAAMC,QAAQN,KAAK,KAAKA,MAAMwC,WAAW,IACrC;AAAA,IACL4oC,OAAO;AAAA,IACPD,YAAY;AAAA,MACVpsB,SAAS,CAAC2O,MAAM,CAAA,CAAE,CAAC;AAAA,MACnB6d,aACE;AAAA,MACFrK,QAAQ;AAAA,MACR3gB,MAAMvgB;AAAAA,MAENwrC,MAAM;AAAA,QACJD,aACE;AAAA,QACFrK,QAAQ;AAAA,MAAA;AAAA,IAEZ;AAAA,IACAlhC;AAAAA,EAIFA,KAAAA,MAAM2F,KAAK,CAAC4F,KAAwB0W,UAA2B;AAEzD,QAAA,CAACwpB,cAAclgC,GAAG;AACP,aAAA,aAAA;AAAA,QACXwT,SAAS,CAAC2O,MAAM,CAACzL,KAAK,CAAC,CAAC;AAAA,QACxBspB,aAAa,gCAAgC90B,OAAOlL,GAAG,CAAC;AAAA,QACxD21B,QAAQ;AAAA,QACR3gB,MAAMhV;AAAAA,QAENigC,MAAM;AAAA,UACJD,aACE;AAAA,UACFrK,QAAQ;AAAA,UACRluB,QAAQ;AAAA,YAACiP;AAAAA,UAAAA;AAAAA,QAAK;AAAA,MAChB,GAEK;AAGT,QAAI,CAAC1W,IAAItL,QAAQ,OAAOsL,IAAItL,QAAS;AACtB,aAAA,aAAA;AAAA,QACX8e,SAAS,CAAC3F,IAAI;AAAA,UAAC,GAAG7N;AAAAA,UAAKtL,MAAM0V,aAAa;AAAA,QAAA,GAAI,CAACsM,KAAK,CAAC,CAAC;AAAA,QACtDspB,aAAa,kBAAkBtpB,KAAK;AAAA,QACpCif,QAAQ;AAAA,QACR3gB,MAAMhV;AAAAA,QAENigC,MAAM;AAAA,UACJD,aACE;AAAA,UACFrK,QAAQ;AAAA,UACRluB,QAAQ;AAAA,YAACiP;AAAAA,UAAAA;AAAAA,QAAK;AAAA,MAChB,GAEK;AAGL,QAAA,CAAC1W,IAAI9K,SAAS,CAAC6qC,gBAAgB/zB,SAAShM,IAAI9K,KAAK,GAAG;AAElD8K,UAAAA,IAAI9K,UAAU,SAAS;AACnBirC,cAAAA,uBAAuB30B,MAAMvW,MAAMhB;AAC5B,eAAA,aAAA;AAAA,UACXuf,SAAS,CACP3F,IAAI;AAAA,YAAC,GAAG7N;AAAAA,YAAK9K,OAAOirC;AAAAA,UAAAA,GAAuB,CAAC;AAAA,YAACzrC,MAAMsL,IAAItL;AAAAA,UAAK,CAAA,CAAC,CAAC;AAAA,UAEhEsrC,aAAa,oBAAoBhgC,IAAItL,IAAI,4BAA4BsL,IAAI9K,KAAK,uDAAuDirC,oBAAoB;AAAA,UACzJxK,QAAQ,aAAawK,oBAAoB;AAAA,UACzCnrB,MAAMhV;AAAAA,UAENigC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cAACxE,KAAKjD,IAAItL;AAAAA,cAAM0rC,kBAAkBD;AAAAA,YAAAA;AAAAA,UAAoB;AAAA,QAChE,GAEK;AAAA,MAAA;AAKP,aAAA,CAACngC,IAAI9K,SACLyF,YAAY;AAAA,QAACd,QAAQ2R;AAAAA,MAAAA,GAAQ;AAAA,QAAC,GAAGxL;AAAAA,QAAK9K,OAAOsW,MAAMvW,MAAMhB;AAAAA,MAAK,CAAA,KAE9D2rC,aAAa;AAAA,QACXpsB,SAAS,CACP3F,IAAI;AAAA,UAAC,GAAG7N;AAAAA,UAAK9K,OAAOsW,MAAMvW,MAAMhB;AAAAA,QAAAA,GAAO,CAAC;AAAA,UAACS,MAAMsL,IAAItL;AAAAA,QAAK,CAAA,CAAC,CAAC;AAAA,QAE5DsrC,aAAa,oBAAoBhgC,IAAItL,IAAI,8EAA8E8W,MAAMvW,MAAMhB,IAAI;AAAA,QACvI0hC,QAAQ,aAAanqB,MAAMvW,MAAMhB,IAAI;AAAA,QACrC+gB,MAAMhV;AAAAA,QAENigC,MAAM;AAAA,UACJD,aACE;AAAA,UACFrK,QACE;AAAA,UACFluB,QAAQ;AAAA,YAACxE,KAAKjD,IAAItL;AAAAA,YAAM0rC,kBAAkB50B,MAAMvW,MAAMhB;AAAAA,UAAAA;AAAAA,QAAI;AAAA,MAGvD,GAAA,MAGJ+L,IAAI9K,SAiBT0qC,aAAa;AAAA,QACXpsB,SAAS,CAAC2O,MAAM,CAAC;AAAA,UAACztB,MAAMsL,IAAItL;AAAAA,QAAK,CAAA,CAAC,CAAC;AAAA,QACnCsrC,aAAa,oBAAoBhgC,IAAItL,IAAI,wBAAwBsL,IAAI9K,KAAK;AAAA,QAC1EygC,QAAQ;AAAA,QACR3gB,MAAMhV;AAAAA,QAENigC,MAAM;AAAA,UACJD,aACE;AAAA,UACFrK,QAAQ;AAAA,UACRluB,QAAQ;AAAA,YAACxE,KAAKjD,IAAItL;AAAAA,YAAM2rC,UAAUrgC,IAAI9K;AAAAA,UAAAA;AAAAA,QAAK;AAAA,MAC7C,GAEK,OA7BL0qC,aAAa;AAAA,QACXpsB,SAAS,CAAC2O,MAAM,CAAC;AAAA,UAACztB,MAAMsL,IAAItL;AAAAA,QAAK,CAAA,CAAC,CAAC;AAAA,QACnCsrC,aAAa,oBAAoBhgC,IAAItL,IAAI;AAAA,QACzCihC,QAAQ;AAAA,QACR3gB,MAAMhV;AAAAA,QAENigC,MAAM;AAAA,UACJD,aACE;AAAA,UACFrK,QAAQ;AAAA,UACRluB,QAAQ;AAAA,YAACxE,KAAKjD,IAAItL;AAAAA,UAAAA;AAAAA,QAAI;AAAA,MAGnB,GAAA;AAAA,IAAA;AAoBX,QAAIsL,IAAI9K,UAAUsW,MAAMvW,MAAMhB,MAAM;AAClC,YAAMmB,YAAY4K;AAElB,UAAI5K,UAAUO,YAAY,CAACb,MAAMC,QAAQK,UAAUO,QAAQ;AAC5C,eAAA,aAAA;AAAA,UACX6d,SAAS,CAAC3F,IAAI;AAAA,YAAClY,UAAU,CAAA;AAAA,UAAA,GAAK,CAAC;AAAA,YAACjB,MAAMU,UAAUV;AAAAA,UAAK,CAAA,CAAC,CAAC;AAAA,UACvDsrC,aAAa,yBAAyB5qC,UAAUV,IAAI;AAAA,UACpDihC,QAAQ;AAAA,UACR3gB,MAAM5f;AAAAA,UAEN6qC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cAACxE,KAAK7N,UAAUV;AAAAA,YAAAA;AAAAA,UAAI;AAAA,QAC9B,GAEK;AAIPU,UAAAA,UAAUO,aAAaqB,UACtBlC,MAAMC,QAAQK,UAAUO,QAAQ,KAAKP,UAAUO,SAASsB,WAAW,GACpE;AACA,cAAMqpC,UAAU;AAAA,UACdprC,OAAOsW,MAAMjB,KAAKtW;AAAAA,UAClBS,MAAM0V,aAAa;AAAA,UACnBpU,MAAM;AAAA,UACNC,OAAO,CAAA;AAAA,QACT;AACa,eAAA,aAAA;AAAA,UACXsqC,aAAa;AAAA,UACb/sB,SAAS,CACPsO,aAAa,CAAA,GAAI,CAAC;AAAA,YAACptB,MAAMsL,IAAItL;AAAAA,UAAAA,GAAO,UAAU,CAAC,GAC/CmtB,OAAO,CAACye,OAAO,GAAG,SAAS,CAAC;AAAA,YAAC5rC,MAAMsL,IAAItL;AAAAA,UAAAA,GAAO,YAAY,CAAC,CAAC,CAAC;AAAA,UAE/DsrC,aAAa,sCAAsChgC,IAAItL,IAAI;AAAA,UAC3DihC,QAAQ;AAAA,UACR3gB,MAAMhV;AAAAA,UAENigC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cAACxE,KAAKjD,IAAItL;AAAAA,YAAAA;AAAAA,UAAI;AAAA,QACxB,GAEK;AAAA,MAAA;AAGH8rC,YAAAA,eAAe1uB,KACnBoD,QACE9f,UAAUO,SACPgV,OAAQ1K,CAAAA,QAAQA,IAAI/K,UAAUsW,MAAMjB,KAAKtW,IAAI,EAC7Ce,IAAKiL,CAAQA,QAAAA,IAAIhK,SAAS,CAAE,CAAA,CACjC,CACF;AAGInB,UAAAA,MAAMC,QAAQiL,IAAIvK,QAAQ,KAAKuK,IAAIvK,SAASwB,SAAS,GAAG;AAC1D,cAAMwpC,iBAA2B3uB,KAC/B9R,IAAIvK,SACDT,IAAK+X,SAAQA,IAAIrY,IAAI,EACrBiW,OAAQ1H,SAAQ,CAACu9B,aAAax0B,SAAS/I,GAAG,CAAC,CAChD;AACA,YAAIw9B,eAAexpC,SAAS;AACb,iBAAA,aAAA;AAAA,YACXspC,aAAa;AAAA,YACb/sB,SAASitB,eAAezrC,IAAK0rC,CAAAA,eAC3Bve,MAAM,CAAC;AAAA,cAACztB,MAAMsL,IAAItL;AAAAA,eAAO,YAAY;AAAA,cAACA,MAAMgsC;AAAAA,YAAW,CAAA,CAAC,CAC1D;AAAA,YACAV,aAAa,2DAA2DS,eAAerpC,KACrF,IACF,CAAC;AAAA,YACDu+B,QAAQ;AAAA,YACR3gB,MAAMhV;AAAAA,YACNigC,MAAM;AAAA,cACJD,aACE;AAAA,cACFrK,QACE;AAAA,cACFluB,QAAQ;AAAA,gBACNxE,KAAKjD,IAAItL;AAAAA,gBACT+rC,gBAAgBA,eAAezrC,IAAK2rC,CAAMA,MAAAA,EAAEv+B,SAAU,CAAA;AAAA,cAAA;AAAA,YACxD;AAAA,UACF,GAEK;AAAA,MAAA;AAQX,YAAMw+B,gBAHkBJ,aAAa71B,OAClCkB,CAAAA,SAAS,CAACL,MAAMM,WAAW9W,IAAK6rC,CAAQA,QAAAA,IAAI5sC,IAAI,EAAE+X,SAASH,IAAI,CAClE,EACsClB,OACnCkB,CAAAA,SACCzW,UAAUK,aAAauB,UACvB,CAAC5B,UAAUK,SAASsK,KAAMgN,CAAAA,QAAQA,IAAIrY,SAASmX,IAAI,CACvD;AACI+0B,UAAAA,cAAc3pC,SAAS,GAAG;AACtB6pC,cAAAA,eAAe1rC,UAAUO,SAASgV,OACrC1K,SACCA,IAAI/K,UAAUsW,MAAMjB,KAAKtW,QACzBa,MAAMC,QAAQkL,IAAIhK,KAAK,KACvBgK,IAAIhK,MAAMmE,KAAMyR,UAAS+0B,cAAc50B,SAASH,IAAI,CAAC,CACzD;AACA,YAAIi1B,cAAc;AACVC,gBAAAA,WAAWH,cAAcxpC,KAAK,IAAI;AAC3B,iBAAA,aAAA;AAAA,YACXmpC,aAAa;AAAA,YACb/sB,SAASstB,aAAa9rC,IAAKY,CAClBiY,UAAAA,KACJjY,MAAMK,SAAS,CAAI0U,GAAAA,OACjBq2B,UAAS,CAACJ,cAAc50B,SAASg1B,IAAI,CACxC,GACA,CAAC;AAAA,cAACtsC,MAAMsL,IAAItL;AAAAA,eAAO,YAAY;AAAA,cAACA,MAAMkB,MAAMlB;AAAAA,YAAAA,GAAO,OAAO,CAC5D,CACD;AAAA,YACDsrC,aAAa,oBAAoBhgC,IAAItL,IAAI,qBAAqBqsC,QAAQ;AAAA,YACtEpL,QAAQ;AAAA,YACR3gB,MAAMhV;AAAAA,YAENigC,MAAM;AAAA,cACJD,aACE;AAAA,cACFrK,QACE;AAAA,cACFluB,QAAQ;AAAA,gBACNxE,KAAKjD,IAAItL;AAAAA,gBACTksC,eAAeA,cAAc5rC,IAAK2rC,CAAMA,MAAAA,EAAEv+B,SAAU,CAAA;AAAA,cAAA;AAAA,YACtD;AAAA,UACF,GAEK;AAAA,QAAA;AAAA,MACT;AAKAhN,gBAAUO,SAASyE,KAAK,CAACxE,OAAOqrC,WAAmB;AAC7C,YAAA,CAACf,cAActqC,KAAK;AACT,iBAAA,aAAA;AAAA,YACX4d,SAAS,CAAC2O,MAAM,CAAC;AAAA,cAACztB,MAAMsL,IAAItL;AAAAA,YAAAA,GAAO,YAAYusC,MAAM,CAAC,CAAC;AAAA,YACvDjB,aAAa,mBAAmBiB,MAAM,wBAAwBjhC,IAAItL,IAAI;AAAA,YACtEihC,QAAQ;AAAA,YACR3gB,MAAMhV;AAAAA,YAENigC,MAAM;AAAA,cACJD,aACE;AAAA,cACFrK,QACE;AAAA,cACFluB,QAAQ;AAAA,gBAACxE,KAAKjD,IAAItL;AAAAA,gBAAMgiB,OAAOuqB;AAAAA,cAAAA;AAAAA,YAAM;AAAA,UACvC,GAEK;AAGT,YAAI,CAACrrC,MAAMlB,QAAQ,OAAOkB,MAAMlB,QAAS,UAAU;AACjD,gBAAMwsC,WAAW;AAAA,YAAC,GAAGtrC;AAAAA,YAAOlB,MAAM0V,aAAa;AAAA,UAAC;AACnC,iBAAA,aAAA;AAAA,YACXm2B,aAAa;AAAA,YACb/sB,SAAS,CACP3F,IAAIqzB,UAAU,CAAC;AAAA,cAACxsC,MAAMsL,IAAItL;AAAAA,YAAAA,GAAO,YAAYusC,MAAM,CAAC,CAAC;AAAA,YAEvDjB,aAAa,kBAAkBiB,MAAM,gDAAgDjhC,IAAItL,IAAI;AAAA,YAC7FihC,QAAQ;AAAA,YACR3gB,MAAMhV;AAAAA,YAENigC,MAAM;AAAA,cACJD,aACE;AAAA,cACFrK,QACE;AAAA,cACFluB,QAAQ;AAAA,gBAACxE,KAAKjD,IAAItL;AAAAA,gBAAMgiB,OAAOuqB;AAAAA,cAAAA;AAAAA,YAAM;AAAA,UACvC,GAEK;AAAA,QAAA;AAIT,eAAKrrC,MAAMV,QAoBN4qC,gBAAgB9zB,SAASpW,MAAMV,KAAK,IA0BvCU,MAAMV,UAAUsW,MAAMjB,KAAKtW,QAC3B,OAAO2B,MAAMI,QAAS,YAEtB4pC,aAAa;AAAA,UACXpsB,SAAS,CACP3F,IAAI;AAAA,YAAC,GAAGjY;AAAAA,YAAOI,MAAM;AAAA,UAAA,GAAK,CACxB;AAAA,YAACtB,MAAMsL,IAAItL;AAAAA,aACX,YACA;AAAA,YAACA,MAAMkB,MAAMlB;AAAAA,UAAK,CAAA,CACnB,CAAC;AAAA,UAEJsrC,aAAa,oBAAoBpqC,MAAMlB,IAAI,wBAAwBsL,IAAItL,IAAI;AAAA,UAC3EihC,QAAQ;AAAA,UACR3gB,MAAMhV;AAAAA,UAENigC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cAACxE,KAAKjD,IAAItL;AAAAA,cAAMoL,UAAUlK,MAAMlB;AAAAA,YAAAA;AAAAA,UAAI;AAAA,QAC9C,GAEK,MAEF,MAlDLkrC,aAAa;AAAA,UACXpsB,SAAS,CACP2O,MAAM,CAAC;AAAA,YAACztB,MAAMsL,IAAItL;AAAAA,aAAO,YAAY;AAAA,YAACA,MAAMkB,MAAMlB;AAAAA,UAAK,CAAA,CAAC,CAAC;AAAA,UAE3DsrC,aAAa,oBAAoBpqC,MAAMlB,IAAI,wBAAwBsL,IAAItL,IAAI,mCAAmCkB,MAAMV,KAAK;AAAA,UACzHygC,QAAQ;AAAA,UACR3gB,MAAMhV;AAAAA,UAENigC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cACNxE,KAAKjD,IAAItL;AAAAA,cACToL,UAAUlK,MAAMlB;AAAAA,cAChBysC,WAAWvrC,MAAMV;AAAAA,YAAAA;AAAAA,UACnB;AAAA,QACF,GAEK,OAxCP0qC,aAAa;AAAA,UACXpsB,SAAS,CACP2O,MAAM,CAAC;AAAA,YAACztB,MAAMsL,IAAItL;AAAAA,aAAO,YAAY;AAAA,YAACA,MAAMkB,MAAMlB;AAAAA,UAAK,CAAA,CAAC,CAAC;AAAA,UAE3DsrC,aAAa,oBAAoBpqC,MAAMlB,IAAI,wBAAwBsL,IAAItL,IAAI;AAAA,UAC3EihC,QAAQ;AAAA,UACR3gB,MAAMhV;AAAAA,UAENigC,MAAM;AAAA,YACJD,aACE;AAAA,YACFrK,QACE;AAAA,YACFluB,QAAQ;AAAA,cAACxE,KAAKjD,IAAItL;AAAAA,cAAMoL,UAAUlK,MAAMlB;AAAAA,YAAAA;AAAAA,UAAI;AAAA,QAGzC,GAAA;AAAA,MAAA,CAuDV,MAEDmrC,QAAQ;AAAA,IAAA;AAGL,WAAA;AAAA,EAAA,CACR,MAEDA,QAAQ,KAEH;AAAA,IAACA;AAAAA,IAAOD;AAAAA,IAAYnrC;AAAAA,EAAAA;AAC7B;ACzZA,MAAMV,UAAQC,cAAc,cAAc,GAqBpCotC,oBAcFA,CAAC;AAAA,EAAChQ;AAAAA,EAAUgG;AAAK,MAAM;AACb,cAAA;AAAA,IACVl7B,SAASk7B,MAAMl7B;AAAAA,IACfk1B;AAAAA,IACA11B,aAAa07B,MAAM17B;AAAAA,IACnBjH,OAAO2iC,MAAM3iC;AAAAA,IACb4sC,cAAcjK,MAAMiK;AAAAA,EAAAA,CACrB;AACH,GAEMC,iBAAiBrF,aAAamF,iBAAiB,GAgBxCG,cAAczlC,MAAM;AAAA,EAC/B0P,OAAO;AAAA,IACLtP,SAAS,CAAC;AAAA,IAWVk7B,OAAO,CAAC;AAAA,IAORF,QAAQ,CAAC;AAAA,IAgBTC,SAAS,CAAA;AAAA,EAQX;AAAA,EACA1zB,SAAS;AAAA,IACP,+BAA+B6zB,OAAO;AAAA,MACpCkK,oBAAoB;AAAA,IAAA,CACrB;AAAA,IACD,mBAAmBlK,OAAO;AAAA,MACxB/xB,UAAUA,CAAC;AAAA,QAAC5J;AAAAA,MACV47B,OAAAA,YAAY57B,OAAO,iBAAiB,GAC7BA,MAAM4J;AAAAA,IAAAA,CAEhB;AAAA,IACD,wBAAwB+xB,OAAO;AAAA,MAC7BmK,cAAcA,CAAC;AAAA,QAAC9lC;AAAAA,MACd47B,OAAAA,YAAY57B,OAAO,cAAc,GAC1BA,MAAMlH;AAAAA,IAAAA,CAEhB;AAAA,IACD,uBAAuB6iC,OAAO;AAAA,MAC5BmK,cAAczqC;AAAAA,IAAAA,CACf;AAAA,IACD,yBAAyBsgC,OAAO;AAAA,MAC9BzT,eAAeA,CAAC;AAAA,QAACloB;AAAAA,MACf47B,OAAAA,YAAY57B,OAAO,cAAc,GAC1BA,MAAMlH;AAAAA,IAAAA,CAEhB;AAAA,IACD,2BAA2BijC,KAAK;AAAA,MAC9Bh0B,MAAM;AAAA,IAAA,CACP;AAAA,IACD,sBAAsBg0B,KAAK;AAAA,MACzBh0B,MAAM;AAAA,IACP,CAAA;AAAA,EACH;AAAA,EACAw0B,QAAQ;AAAA,IACN,wBAAwBwJ,CAAC;AAAA,MAACxlC;AAAAA,UAAaA,QAAQslC;AAAAA,IAC/C,WAAWG,CAAC;AAAA,MAACzlC;AAAAA,IAAAA,MAAa;AACxB,YAAM0lC,WAAW,CAAC1lC,QAAQqJ,UACpBs8B,2BAA2B3lC,QAAQ2lC,0BACnCC,aAAal0B,mBAAmB1R,QAAQR,WAAW,KAAK,IACxDqmC,SAASH,aAAaC,4BAA4BC;AAExD/tC,aAAAA,QAAM,UAAU;AAAA,QAACguC;AAAAA,QAAQH;AAAAA,QAAUC;AAAAA,QAA0BC;AAAAA,MAAW,CAAA,GAEjEC;AAAAA,IACT;AAAA,IACA,kBAAkBC,CAAC;AAAA,MAACrmC;AAAAA,IACXA,MAAAA,MAAM+H,SAAS,kBAAkB/H,MAAMlH,UAAUuC;AAAAA,IAE1D,kBAAkBirC,CAAC;AAAA,MAACtmC;AAAAA,IAAK,MAErBA,MAAM+H,SAAS,kBACf5O,MAAMC,QAAQ4G,MAAMlH,KAAK,KACzBkH,MAAMlH,MAAMwC,WAAW;AAAA,IAG3B,gBAAgBirC,CAAC;AAAA,MAAChmC;AAAAA,MAASP;AAAAA,IAAAA,MAEvBA,MAAM+H,SAAS,kBAAkBxH,QAAQ2nB,kBAAkBloB,MAAMlH;AAAAA,IAGrE,+BAA+B0tC,CAAC;AAAA,MAACjmC;AAAAA,MAASP;AAAAA,IAAAA,OACxC47B,YAAY57B,OAAO,cAAc,GAC1BO,QAAQulC,iBAAiB9lC,MAAMlH;AAAAA,IAExC,uCAAuC2tC,CAAC;AAAA,MAAClmC;AAAAA,IAChCvH,MAAAA,QAAQuH,QAAQulC,cAAcvlC,QAAQ2nB,aAAa;AAAA,EAE9D;AAAA,EACAmY,QAAQ;AAAA,IACN,cAAcsF;AAAAA,EAAAA;AAElB,CAAC,EAAElJ,cAAc;AAAA,EACfv1B,IAAI;AAAA,EACJ3G,SAASA,CAAC;AAAA,IAACk7B;AAAAA,EAAAA,OAAY;AAAA,IACrB7O,cAAc6O,MAAM7O;AAAAA,IACpBiZ,oBAAoB;AAAA,IACpBK,0BAA0B;AAAA,IAC1Bz3B,cAAcgtB,MAAMhtB;AAAAA,IACpBvQ,QAAQu9B,MAAMv9B;AAAAA,IACd0L,UAAU6xB,MAAM7xB;AAAAA,IAChB7J,aAAa07B,MAAM17B;AAAAA,IACnB+lC,cAAczqC;AAAAA,IACd6sB,eAAe7sB;AAAAA,EAAAA;AAAAA,EAEjBgnB,OAAO,CACL0K,QAAM,CAAC;AAAA,IAACxsB;AAAAA,EAAAA,OACC;AAAA,IAACwH,MAAM;AAAA,IAAgBjP,OAAOyH,QAAQqsB;AAAAA,IAC9C,CAAC;AAAA,EAEJh1B,IAAI;AAAA,IACF,yBAAyB;AAAA,MACvBkQ,SAAS6zB,OAAO;AAAA,QACduK,0BAA0B;AAAA,MAC3B,CAAA;AAAA,IACH;AAAA,IACA,UAAY;AAAA,MACVp+B,SAAS6zB,OAAO;AAAA,QACduK,0BAA0B;AAAA,MAC3B,CAAA;AAAA,IACH;AAAA,IACA,mBAAmB;AAAA,MACjBp+B,SAAS,CAAC,iBAAiB;AAAA,IAAA;AAAA,EAE/B;AAAA,EACA80B,SAAS;AAAA,EACTD,QAAQ;AAAA,IACNW,MAAM;AAAA,MACJjb,OAAO,CACL,MAAM;AACJjqB,gBAAM,sBAAsB;AAAA,MAAA,CAC7B;AAAA,MAEHykC,MAAM,CACJ,MAAM;AACJzkC,gBAAM,qBAAqB;AAAA,MAAA,CAC5B;AAAA,MAEHR,IAAI;AAAA,QACF,gBAAgB,CACd;AAAA,UACE8P,OAAO85B,IAAI,CAAC,kBAAkBC,IAAI,sBAAsB,CAAC,CAAC;AAAA,UAC1D35B,SAAS,CAAC,+BAA+B,yBAAyB;AAAA,QAAA,GAEpE;AAAA,UACEJ,OAAO85B,IAAI,CAAC,kBAAkBC,IAAI,sBAAsB,CAAC,CAAC;AAAA,UAC1D35B,SAAS,CACP,+BACAi0B,KAAK;AAAA,YAACh0B,MAAM;AAAA,YAAiBjP,OAAO,CAAA;AAAA,UAAG,CAAA,GACvC,yBAAyB;AAAA,QAAA,GAG7B;AAAA,UACE4O,OAAO85B,IAAI,CAAC,WAAW,cAAc,CAAC;AAAA,UACtCvgC,QAAQ;AAAA,UACR6G,SAAS,CAAC,sBAAsB;AAAA,QAAA,GAElC;AAAA,UACEJ,OAAO;AAAA,UACPzG,QAAQ;AAAA,UACR6G,SAAS,CAAC,sBAAsB;AAAA,QAAA,GAElC;AAAA,UACEJ,OAAO+5B,IAAI,sBAAsB;AAAA,UACjC35B,SAAS,CACP,MAAM;AACJ1P,oBAAM,qDAAgD;AAAA,UACxD,GACA,+BACA,yBAAyB;AAAA,QAAA,GAG7B;AAAA,UACE0P,SAAS,CACP,MAAM;AACJ1P,oBAAM,+CAA+C;AAAA,UACtD,CAAA;AAAA,QAEJ,CAAA;AAAA,MAAA;AAAA,IAGP;AAAA,IACAsuC,MAAM;AAAA,MACJrkB,OAAO,CACL,MAAM;AACJjqB,gBAAM,sBAAsB;AAAA,MAAA,CAC7B;AAAA,MAEHykC,MAAM,CACJ,MAAM;AACJzkC,gBAAM,qBAAqB;AAAA,MAAA,CAC5B;AAAA,MAEH6yB,OAAO;AAAA,QACL,KAAM,CACJ;AAAA,UACEvjB,OAAO;AAAA,UACPzG,QAAQ;AAAA,UACRqgC,SAAS;AAAA,UACTx5B,SAAS,CACP,MAAM;AACJ1P,oBAAM,wBAAwB;AAAA,UAC/B,CAAA;AAAA,QAAA,GAGL;AAAA,UACE6I,QAAQ;AAAA,QACT,CAAA;AAAA,MAEL;AAAA,MACArJ,IAAI;AAAA,QACF,gBAAgB,CACd;AAAA,UACE8P,OAAO;AAAA,UACPI,SAAS,CAAC,sBAAsB;AAAA,QACjC,CAAA;AAAA,MAAA;AAAA,IAGP;AAAA,IACA6+B,SAAS;AAAA,MACPtkB,OAAO,CACL,MAAM;AACJjqB,gBAAM,yBAAyB;AAAA,SAEjC,oBAAoB;AAAA,MAEtBykC,MAAM,CACJ,MAAM;AACJzkC,gBAAM,wBAAwB;AAAA,SAEhC,yBAAyB;AAAA,MAE3BgpC,QAAQ;AAAA,QACNC,KAAK;AAAA,QACLn6B,IAAI;AAAA,QACJu0B,OAAOA,CAAC;AAAA,UAACl7B;AAAAA,QAAAA,OACA;AAAA,UACLA,SAAS;AAAA,YACPkO,cAAclO,QAAQkO;AAAAA,YACtByZ,eAAe3nB,QAAQ2nB;AAAAA,YACvBte,UAAUrJ,QAAQqJ;AAAAA,YAClB1L,QAAQqC,QAAQrC;AAAAA,UAClB;AAAA,UACA6B,aAAaQ,QAAQR;AAAAA,UACrB2lC,cAAc,CAACnlC,QAAQslC;AAAAA,UACvB/sC,OAAOyH,QAAQulC;AAAAA,QACjB;AAAA,MAEJ;AAAA,MACAluC,IAAI;AAAA,QACF,gBAAgB;AAAA,UACd8P,OAAO;AAAA,UACPI,SAAS,CAAC,sBAAsB;AAAA,QAClC;AAAA,QACA,OAAS;AAAA,UACPA,SAAS,CAACi0B,KAAK,CAAC;AAAA,YAAC/7B;AAAAA,UAAK,MAAMA,KAAK,CAAC;AAAA,QACpC;AAAA,QACA,iBAAiB;AAAA,UACf8H,SAAS,CAACi0B,KAAK,CAAC;AAAA,YAAC/7B;AAAAA,UAAK,MAAMA,KAAK,CAAC;AAAA,QACpC;AAAA,QACA,iBAAiB;AAAA,UACf8H,SAAS,CAACi0B,KAAK,CAAC;AAAA,YAAC/7B;AAAAA,UAAK,MAAMA,KAAK,CAAC;AAAA,QACpC;AAAA,QACA,gBAAgB,CACd;AAAA,UACE0H,OAAO;AAAA,UACPI,SAAS,CAAC,yBAAyB,6BAA6B;AAAA,UAChE7G,QAAQ;AAAA,UACRqgC,SAAS;AAAA,QAAA,GAEX;AAAA,UACErgC,QAAQ;AAAA,UACR6G,SAAS,CACP,uBACA,yBACA,6BAA6B;AAAA,QAEhC,CAAA;AAAA,MAAA;AAAA,IAEL;AAAA,EACF;AAEJ,CAAC;AAED,eAAe8+B,YAAY;AAAA,EACzBrmC;AAAAA,EACAk1B;AAAAA,EACA11B;AAAAA,EACA2lC;AAAAA,EACA5sC;AAYF,GAAG;AACD,MAAI+tC,cAAc,IACdC,YAAY,IACZC,UAAU;AAERC,QAAAA,eAAe,CAAC,CAACjnC,YAAY3D;AAG/B,OAAA,CAACtD,SAASA,MAAMwC,WAAW,OAC7BlD,QAAM,gBAAgB,GACtByD,OAAOia,mBAAmB/V,aAAa,MAAM;AAC3C6Z,kBAAc7Z,aAAa,MAAM;AAC/B+R,wBAAkB/R,aAAa,MAAM;AACnCqnB,wBAAgBrnB,aAAa,MAAM;AAC7B8mC,cAAAA;AACF;AAGEG,0BACFn2B,WAAWiJ,SAAS/Z,WAAW;AAG3BknC,gBAAAA,iBAAiBlnC,YAAY/F,SAASsB;AAE5CyE,sBAAY/F,SAAS+R,QAAQ,CAACuY,GAAGvJ,UAAU;AACzClK,uBAAW6N,YAAY3e,aAAa;AAAA,cAClChE,IAAI,CAACkrC,iBAAiB,IAAIlsB,KAAK;AAAA,YAAA,CAChC;AAAA,UACF,CAAA,GAEDlK,WAAWI,YACTlR,aACAA,YAAYwkB,mBAAmB;AAAA,YAACpU,YAAY,CAAA;AAAA,UAAA,CAAG,GAC/C;AAAA,YAACpU,IAAI,CAAC,CAAC;AAAA,UAAA,CACT,GAGIirC,gBACFn2B,WAAWwO,OAAOtf,aAAa,CAAC,GAAG,CAAC,CAAC;AAAA,QAAA,CAExC;AAAA,MAAA,CACF;AAAA,IAAA,CACF;AAAA,EAAA,CACF,GACD+mC,YAAY,KAGVhuC,SAASA,MAAMwC,SAAS,GAAG;AACvB4rC,UAAAA,sBAAsBjuC,aAAaH,OAAO;AAAA,MAC9CI,aAAaqH,QAAQrC;AAAAA,IAAAA,CACtB;AAEGwnC,mBACF,MAAM,IAAIyB,QAAeC,CAAY,YAAA;AAC5BtxB,aAAAA,mBAAmB/V,aAAa,MAAM;AAC3C+R,0BAAkB/R,aAAa,MAAM;AACnCqnB,0BAAgBrnB,aAAa,MAAM;AACjC,gBAAI8mC,aAAa;AACP,sBAAA;AACR;AAAA,YAAA;AAGFC,wBAAYO,kBAAkB;AAAA,cAC5BtnC;AAAAA,cACAmnC;AAAAA,YACD,CAAA,IAEqB,YAAY;AAChC,+BAAiB,CACfI,cACAC,iBAAiB,KACdC,kBAAkB;AAAA,gBACrBC,YAAYP;AAAAA,cAAAA,CACb,GAAG;AACI,sBAAA;AAAA,kBAACQ;AAAAA,kBAAcC;AAAAA,oBAAcC,UAAU;AAAA,kBAC3CrnC;AAAAA,kBACAk1B;AAAAA,kBACAn8B,OAAOguC;AAAAA,kBACPvsB,OAAOwsB;AAAAA,kBACPxnC;AAAAA,kBACAjH;AAAAA,gBAAAA,CACD;AAEW4uC,4BAAAA,gBAAgBZ,WAC5BC,UAAUA,WAAWY;AAAAA,cAAAA;AAGf,sBAAA;AAAA,YAAA,GAGI;AAAA,UAAA,CACf;AAAA,QAAA,CACF;AAAA,MAAA,CACF;AAAA,IACF,CAAA,IAED9rC,OAAOia,mBAAmB/V,aAAa,MAAM;AAC3C+R,wBAAkB/R,aAAa,MAAM;AACnCqnB,wBAAgBrnB,aAAa,MAAM;AAC7B8mC,cAAAA;AACF;AAGFC,sBAAYO,kBAAkB;AAAA,YAC5BtnC;AAAAA,YACAmnC;AAAAA,UAAAA,CACD;AAED,cAAInsB,QAAQ;AAEZ,qBAAWusB,gBAAgBJ,qBAAqB;AACxC,kBAAA;AAAA,cAACQ;AAAAA,cAAcC;AAAAA,gBAAcC,UAAU;AAAA,cAC3CrnC;AAAAA,cACAk1B;AAAAA,cACAn8B,OAAOguC;AAAAA,cACPvsB;AAAAA,cACAhb;AAAAA,cACAjH;AAAAA,YAAAA,CACD;AAEDguC,wBAAYY,gBAAgBZ,WAC5BC,UAAUA,WAAWY,YACrB5sB;AAAAA,UAAAA;AAAAA,QACF,CACD;AAAA,MAAA,CACF;AAAA,IAAA,CACF;AAAA,EAAA;AAIL,MAAI,CAACgsB,SAAS;AACZ3uC,YAAM,0BAA0B,GAChCyuC,cAAc,IACdpR,SAAS;AAAA,MAAC1tB,MAAM;AAAA,MAAgBjP;AAAAA,IAAAA,CAAM;AACtC;AAAA,EAAA;AAGF,MAAIguC,WAAW;AACb1uC,YAAM,sCAAsC;AACxC,QAAA;AACF2H,kBAAYgW,SAAS;AAAA,aACd8D,KAAK;AACJrQ,cAAAA,MAAMqQ,GAAG,GACjB4b,SAAS;AAAA,QACP1tB,MAAM;AAAA,QACNk8B,YAAY;AAAA,QACZnrC;AAAAA,MAAAA,CACD,GACD+tC,cAAc,IACdpR,SAAS;AAAA,QAAC1tB,MAAM;AAAA,QAAgBjP;AAAAA,MAAAA,CAAM;AACtC;AAAA,IAAA;AAEEkuC,oBAAgB,CAACjnC,YAAY3D,cAC/ByU,WAAWwO,OAAOtf,aAAa;AAAA,MAC7BR,QAAQ;AAAA,QAAChD,MAAM,CAAC,GAAG,CAAC;AAAA,QAAGkD,QAAQ;AAAA,MAAC;AAAA,MAChCnD,OAAO;AAAA,QAACC,MAAM,CAAC,GAAG,CAAC;AAAA,QAAGkD,QAAQ;AAAA,MAAA;AAAA,IAC/B,CAAA,GACDM,YAAYgW,aAEd0f,SAAS;AAAA,MAAC1tB,MAAM;AAAA,MAAiBjP;AAAAA,IAAAA,CAAM;AAAA,EACzC;AACEV,YAAM,0DAA0D;AAGlEyuC,gBAAc,IACdpR,SAAS;AAAA,IAAC1tB,MAAM;AAAA,IAAgBjP;AAAAA,EAAAA,CAAM;AACxC;AAEA,SAASuuC,kBAAkB;AAAA,EACzBtnC;AAAAA,EACAmnC;AAIF,GAAG;AACD,MAAIJ,YAAY;AACVG,QAAAA,iBAAiBlnC,YAAY/F,SAASsB;AAGxC4rC,MAAAA,oBAAoB5rC,SAAS2rC,gBAAgB;AAC/C,aAASzgC,IAAIygC,iBAAiB,GAAGzgC,IAAI0gC,oBAAoB5rC,SAAS,GAAGkL;AACnEqK,iBAAW6N,YAAY3e,aAAa;AAAA,QAClChE,IAAI,CAACyK,CAAC;AAAA,MAAA,CACP;AAES,gBAAA;AAAA,EAAA;AAEPsgC,SAAAA;AACT;AAEA,gBAAgBU,kBAAkB;AAAA,EAChCC;AAGF,GAAG;AACD,MAAI1sB,QAAQ;AACZ,mBAAiBzhB,SAASmuC;AACpB1sB,YAAQ,OAAO,KACjB,MAAM,IAAIosB,QAAeC,CAAYS,YAAAA,WAAWT,SAAS,CAAC,CAAC,GAE7D,MAAM,CAAC9tC,OAAOyhB,KAAK,GACnBA;AAEJ;AAEA,SAAS6sB,UAAU;AAAA,EACjBrnC;AAAAA,EACAk1B;AAAAA,EACAn8B;AAAAA,EACAyhB;AAAAA,EACAhb;AAAAA,EACAjH;AAaF,GAAG;AACG4uC,MAAAA,eAAe,IACfC,aAAa;AACjB,QAAML,eAAehuC,OACfiuC,oBAAoBxsB,OACpBuL,WAAWvmB,YAAY/F,SAASutC,iBAAiB,GACjDO,aAAaxhB,YAAY,CAACttB,QAAQsuC,cAAchhB,QAAQ;AAEvDxQ,SAAAA,OAAAA,mBAAmB/V,aAAa,MAAM;AAC3C+R,sBAAkB/R,aAAa,MAAM;AACnCqnB,sBAAgBrnB,aAAa,MAAM;AACjC,YAAI+nC,cAAcH,YAAY;AAC5B,gBAAMI,kBAAkB,CAACjvC,MAAMyuC,iBAAiB,CAAC,GAC3CS,aAAahE,cACjB+D,iBACAxnC,QAAQrC,QACRqC,QAAQkO,YACV;AAGE,WAACu5B,WAAW9D,SACZ8D,WAAW/D,YAAYW,eACvBoD,WAAW/D,YAAYpsB,QAAQvc,SAAS,KAItC,CAACiF,QAAQqJ,YACTrJ,QAAQ2nB,iBACR3nB,QAAQ2nB,kBAAkBpvB,UAG1BiK,QAAQC,KACN,GAAGglC,WAAW/D,WAAWjK,MAAM,yBAAyB+N,gBAAgB,CAAC,EAAEhvC,IAAI,MAAMivC,WAAW/D,YAAYI,WAAW,EACzH,GACA2D,WAAW/D,WAAWpsB,QAAQ9L,QAAS6K,CAAU,UAAA;AACtC,qBAAA;AAAA,cAAC7O,MAAM;AAAA,cAAS6O;AAAAA,YAAAA,CAAM;AAAA,UAAA,CAChC,IAGDoxB,WAAW9D,SAAS8D,WAAW/D,YAAYW,eACzCte,SAASvtB,SAASuuC,aAAavuC,QAC7BX,QAAMI,WAASJ,QAAM,kBAAkBkuB,UAAUghB,YAAY,GACjEW,aACEloC,aACAunC,cACAhhB,UACAihB,iBACF,MAEInvC,QAAMI,WACRJ,QAAM,mBAAmBkuB,UAAUghB,YAAY,GACjDY,cAAcnoC,aAAaunC,cAAcC,iBAAiB,IAE5DG,eAAe,OAEfjS,SAAS;AAAA,YACP1tB,MAAM;AAAA,YACNk8B,YAAY+D,WAAW/D;AAAAA,YACvBnrC;AAAAA,UAAAA,CACD,GACD6uC,aAAa;AAAA,QAAA;AAIb,YAAA,CAACrhB,YAAYqhB,YAAY;AAC3B,gBAAMI,kBAAkB,CAACjvC,MAAMyuC,iBAAiB,CAAC,GAC3CS,aAAahE,cACjB+D,iBACAxnC,QAAQrC,QACRqC,QAAQkO,YACV;AACIrW,kBAAMI,WACRJ,QACE,8DACAkvC,YACF,GACEU,WAAW9D,SAAS8D,WAAW/D,YAAYW,cAC7C/zB,WAAWI,YAAYlR,aAAaunC,cAAc;AAAA,YAChDvrC,IAAI,CAACwrC,iBAAiB;AAAA,UACvB,CAAA,KAEDnvC,QAAM,WAAW4vC,UAAU,GAC3BvS,SAAS;AAAA,YACP1tB,MAAM;AAAA,YACNk8B,YAAY+D,WAAW/D;AAAAA,YACvBnrC;AAAAA,UAAAA,CACD,GACD6uC,aAAa;AAAA,QAAA;AAAA,MAEjB,CACD;AAAA,IAAA,CACF;AAAA,EAAA,CACF,GAEM;AAAA,IAACD;AAAAA,IAAcC;AAAAA,EAAU;AAClC;AAMA,SAASO,cACPnoC,aACAunC,cACAC,mBACA;AAGMznB,QAAAA,mBAAmB/f,YAAY3D,WAC/B+rC,wBACJroB,oBAAoBA,iBAAiBxjB,MAAMC,KAAK,CAAC,MAAMgrC;AACrDY,2BACFt3B,WAAWiJ,SAAS/Z,WAAW,GAEjC8Q,WAAW6N,YAAY3e,aAAa;AAAA,IAAChE,IAAI,CAACwrC,iBAAiB;AAAA,EAAE,CAAA,GAC7D12B,WAAWI,YAAYlR,aAAaunC,cAAc;AAAA,IAACvrC,IAAI,CAACwrC,iBAAiB;AAAA,EAAA,CAAE,GAC3ExnC,YAAYgW,YACRoyB,yBACFt3B,WAAWwO,OAAOtf,aAAa+f,gBAAgB;AAEnD;AAMA,SAASmoB,aACPloC,aACAunC,cACAhhB,UACAihB,mBACA;AAEA12B,MAAAA,WAAWiD,SAAS/T,aAAaunC,cAA+B;AAAA,IAC9DvrC,IAAI,CAACwrC,iBAAiB;AAAA,EAAA,CACvB,GAGCxnC,YAAYf,YAAYsoC,YAAY,KACpCvnC,YAAYf,YAAYsnB,QAAQ,GAChC;AACM8hB,UAAAA,yBAAyB9hB,SAAStsB,SAASsB;AAC7CgsC,iBAAattC,SAASsB,SAAS8sC,0BAEjCjvC,MAAMyC,KACJzC,MAAMivC,yBAAyBd,aAAattC,SAASsB,MAAM,CAC7D,EAAEyQ,QAAQ,CAACuY,GAAGvJ,UAAU;AAChBvd,YAAAA,aAAa4qC,yBAAyB,IAAIrtB;AAC5Cvd,mBAAa,MACfpF,QAAM,gBAAgB,GACtByY,WAAW6N,YAAY3e,aAAa;AAAA,QAClChE,IAAI,CAACwrC,mBAAmB/pC,UAAU;AAAA,MAAA,CACnC;AAAA,IAAA,CAEJ,GAEH8pC,aAAattC,SAAS+R,QACpB,CAACs8B,mBAAmBC,2BAA2B;AACvCC,YAAAA,gBAAgBjiB,SAAStsB,SAASsuC,sBAAsB,GACxDE,iBAAiB,CAACxvC,QAAQqvC,mBAAmBE,aAAa,GAC1DE,gBAAgB,CAACzvC,QACrBqvC,kBAAkBhuC,MAClBkuC,eAAeluC,IACjB,GACMkC,OAAO,CAACgrC,mBAAmBe,sBAAsB;AACnDE,UAAAA;AAEEH,YAAAA,kBAAkBtvC,SAASwvC,eAAexvC,MAAM;AAClDX,kBAAM,0BAA0BiwC,mBAAmBE,aAAa,GAChE13B,WAAWiD,SACT/T,aACAsoC,mBACA;AAAA,YACEtsC,IAAIQ;AAAAA,UAAAA,CAER;AACA,gBAAMytB,cACJzuB,KAAKC,OAAO6sC,iBAAiB,KAC7BA,kBAAkB9uC,UAAU,UAC5BgC,KAAKC,OAAO+sC,aAAa,KACzBA,cAAchvC,UAAU;AACtBywB,UAAAA,eAAcye,iBACZF,cAAcluC,KAAKiB,SAAS,KAC9BuV,WAAW8N,OAAO5e,aAAa;AAAA,YAC7BhE,IAAI;AAAA,cACFO,OAAO;AAAA,gBAACC;AAAAA,gBAAMkD,QAAQ;AAAA,cAAC;AAAA,cACvBF,QAAQ;AAAA,gBAAChD;AAAAA,gBAAMkD,QAAQ8oC,cAAcluC,KAAKiB;AAAAA,cAAAA;AAAAA,YAAM;AAAA,UAEnD,CAAA,GAEHuV,WAAWC,WAAW/Q,aAAasoC,kBAAkBhuC,MAAM;AAAA,YACzD0B,IAAIQ;AAAAA,UACL,CAAA,GACDwD,YAAYgW,SACFiU,KAAAA,gBAEV5xB,QAAM,wCAAwCiwC,iBAAiB,GAC/Dx3B,WAAWiD,SACT/T,aACA;AAAA,YAAChH,MAAML;AAAAA,UAAAA,GACP;AAAA,YACEqD,IAAI,CAAC,GAAGQ,MAAM,CAAC;AAAA,YACfsX,OAAO;AAAA,UAAA,CAEX;AAAA,QAAA,MAGO00B,kBACTnwC,QAAM,mBAAmBiwC,iBAAiB,GAC1Cx3B,WAAW6N,YAAY3e,aAAa;AAAA,UAClChE,IAAI,CAACwrC,mBAAmBe,sBAAsB;AAAA,QAC/C,CAAA,GACDz3B,WAAWI,YAAYlR,aAAasoC,mBAA2B;AAAA,UAC7DtsC,IAAI,CAACwrC,mBAAmBe,sBAAsB;AAAA,QAC/C,CAAA,GACDvoC,YAAYgW,SAEFwyB,KAAAA,kBACVnwC,QAAM,uBAAuBiwC,iBAAiB,GAC9Cx3B,WAAWI,YAAYlR,aAAasoC,mBAA2B;AAAA,UAC7DtsC,IAAI,CAACwrC,mBAAmBe,sBAAsB;AAAA,QAAA,CAC/C,GACDvoC,YAAYgW;IAAS,CAI7B;AAAA,EAAA;AAEJ;AC70BA,MAAM3d,UAAQC,cAAc,OAAO;AAU5B,SAASqwC,qBAAqBzhC,QASnC;AACA7O,UAAM,8BAA8B;AAEpC,QAAMuf,gBAAyC,CACzC7X,GAAAA,cAAc6oC,YAAYrN,eAAe;AAAA,IAC7CG,OAAOmN,2BAA2B3hC,MAAM;AAAA,EAAA,CACzC,GACKsgB,aAAaohB,YAAY5E,YAAY,GACrChkC,cAAc0sB,kBAAkB;AAAA,IACpC3sB;AAAAA,IACAynB;AAAAA,IACA5P;AAAAA,EAAAA,CACD,GACKsuB,WAAWvE,kBAAkB3hC,YAAYsT,UAAUvT,WAAW,GAC9D;AAAA,IAAC+oC;AAAAA,IAAeC;AAAAA,MAAaC,aAAa;AAAA,IAC9CjpC;AAAAA,IACAynB;AAAAA,IACAxnB,aAAaA,YAAYsT;AAAAA,IACzBsE;AAAAA,EAAAA,CACD;AA+GM,SAAA;AAAA,IACL0oB,QAAQ;AAAA,MACNvgC;AAAAA,MACA+oC;AAAAA,MACAthB;AAAAA,MACAuhB;AAAAA,IACF;AAAA,IACApxC,QApHa;AAAA,MACbuI,aAAaA,MACXiT,kBAAkB;AAAA,QAChBD,qBAAqBnT,YAAYG,YAAY;AAAA,QAC7CkT,qBAAqBpT,YAAYsT;AAAAA,MAAAA,CAClC;AAAA,MACH21B,kBAAmBxgC,CAAmB,mBAAA;AACpC,cAAMP,WAAWjB,qBAAqB;AAAA,UACpC1O,MAAM;AAAA,UACN6O,WAAW;AAAA,YACTc,UAAUb;AAAAA,YACVc,YAAY;AAAA,UAAA;AAAA,QAEf,CAAA,GACK+gC,6BAA6B;AAAA,UACjC,GAAGzgC;AAAAA,UACHP;AAAAA,QACF;AAEAnI,eAAAA,YAAY2I,KAAK;AAAA,UACfV,MAAM;AAAA,UACNS,gBAAgBygC;AAAAA,QACjB,CAAA,GAEM,MAAM;AACXnpC,sBAAY2I,KAAK;AAAA,YACfV,MAAM;AAAA,YACNS,gBAAgBygC;AAAAA,UAAAA,CACjB;AAAA,QACH;AAAA,MACF;AAAA,MACAxgC,MAAOzI,CAAU,UAAA;AACf,gBAAQA,MAAM+H,MAAI;AAAA,UAChB,KAAK;AACH+gC,sBAAUrgC,KAAKzI,KAAK;AACpB;AAAA,UAEF,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACHF,wBAAY2I,KAAKzI,KAAK;AACtB;AAAA,UAEF,KAAK;AACHF,wBAAY2I,KAAK;AAAA,cACfV,MAAM;AAAA,cACNrQ,QAAQqI,YAAYsT;AAAAA,YAAAA,CACrB;AACD;AAAA,UAEF,KAAK;AACHvT,wBAAY2I,KAAK;AAAA,cACfV,MAAM;AAAA,cACNrQ,QAAQqI,YAAYsT;AAAAA,YAAAA,CACrB;AACD;AAAA,UAEF,KAAK;AACHvT,wBAAY2I,KAAK;AAAA,cACfV,MAAM;AAAA,cACNuZ,eAAe;AAAA,gBACbvZ,MAAM;AAAA,gBACNzO,OAAO;AAAA,kBACLC,OAAOyG,MAAMpB,YAAYtG;AAAAA,kBACzB,GAAI0H,MAAMpB,YAAY9F,SAAS,CAAA;AAAA,gBACjC;AAAA,gBACAsmB,WAAWpf,MAAMof;AAAAA,cACnB;AAAA,cACA1nB,QAAQqI,YAAYsT;AAAAA,YAAAA,CACrB;AACD;AAAA,UAEF;AACEvT,wBAAY2I,KAAK;AAAA,cACfV,MAAM;AAAA,cACNuZ,eAAethB;AAAAA,cACftI,QAAQqI,YAAYsT;AAAAA,YAAAA,CACrB;AAAA,QAAA;AAAA,MAEP;AAAA,MACAzb,IAAIA,CAACoI,OAAOkpC,aACW3hB,WAAW3vB,GAAGoI,OAAQA,CAAAA,WAAU;AACnD,gBAAQA,OAAM+H,MAAI;AAAA,UAChB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACHmhC,qBAASlpC,MAAK;AACd;AAAA,QAAA;AAAA,MACJ,CACD;AAAA,MAIHoT,WAAW;AAAA,QACT6yB;AAAAA,QACAnmC;AAAAA,QACAC;AAAAA,MAAAA;AAAAA,IAEJ;AAAA,IAUE4X;AAAAA,EACF;AACF;AAEA,SAASixB,2BAA2B3hC,QAAsB;AAClD,QAAA;AAAA,IAACwD;AAAAA,IAAcvM;AAAAA,EAAAA,IAAUirC,+BAA+BliC,MAAM;AAE7D,SAAA;AAAA,IACL6F,YAAY0C,qBAAqB/E,YAAY;AAAA,IAC7ClB,iBAAiBA,MAAMkB;AAAAA,IACvBgE,cAAcxH,OAAOwH,gBAAgBrI;AAAAA,IACrCgb,WAAWna,OAAOma;AAAAA,IAClBxX,UAAU3C,OAAO2C;AAAAA,IACjB1L;AAAAA,IACA0uB,cAAc3lB,OAAO2lB;AAAAA,EACvB;AACF;AAEA,SAASuc,+BAA+BliC,QAAsB;AACtDwD,QAAAA,eAAexD,OAAOmiC,mBACxB3J,sCAAsCx4B,OAAOmiC,gBAAgB,IAC7D3L,mBACEx2B,OAAO/I,OAAOwtB,eAAe,UAAU,IACnCzkB,OAAO/I,SACPuR,YAAYxI,OAAO/I,MAAM,CAC/B,GACEA,SAASqhC,2BAA2B90B,YAAY;AAE/C,SAAA;AAAA,IACLA;AAAAA,IACAvM;AAAAA,EACF;AACF;AAEA,SAAS6qC,aAAa9hC,QAQpB;AACA7O,UAAM,qBAAqB;AAErBywC,QAAAA,gBAAgBF,YAAY3I,iBAAiB;AAAA,IACjDvE,OAAO;AAAA,MACL7xB,UAAU3C,OAAOnH,YACdG,YAAAA,EACAC,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY;AAAA,MACrChC,QAAQ+I,OAAOnH,YAAYG,cAAcM,QAAQrC;AAAAA,MACjD6B,aAAakH,OAAOlH;AAAAA,IAAAA;AAAAA,EACtB,CACD,GAEK+oC,YAAYH,YAAY/C,aAAa;AAAA,IACzCnK,OAAO;AAAA,MACL7O,cAAc3lB,OAAOnH,YAAYG,cAAcM,QAAQqsB;AAAAA,MACvDne,cAAcxH,OAAOnH,YAAYG,cAAcM,QAAQkO;AAAAA,MACvD7E,UAAU3C,OAAOnH,YACdG,YAAAA,EACAC,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY;AAAA,MACrChC,QAAQ+I,OAAOnH,YAAYG,cAAcM,QAAQrC;AAAAA,MACjD6B,aAAakH,OAAOlH;AAAAA,IAAAA;AAAAA,EACtB,CACD;AAEM4X,SAAAA,OAAAA,cAAc/X,KAAK,MAAM;AAC9B,UAAM7H,eAAe8wC,cAAcjxC,GAAG,KAAMoI,CAAU,UAAA;AAChDA,YAAM+H,SAAS,2BACjB+gC,UAAUrgC,KAAK;AAAA,QAACV,MAAM;AAAA,MAAwB,CAAA,GAE5C/H,MAAM+H,SAAS,eACjB+gC,UAAUrgC,KAAK;AAAA,QAACV,MAAM;AAAA,MAAA,CAAW,GACjCd,OAAOnH,YAAY2I,KAAK;AAAA,QACtBV,MAAM;AAAA,QACN8P,SAAS7X,MAAM6X;AAAAA,QACfjS,UAAU5F,MAAM4F;AAAAA,QAChB9M,OAAOkH,MAAM4F;AAAAA,MAAAA,CACd,IAEC5F,MAAM+H,SAAS,WACjBd,OAAOsgB,WAAW9e,KAAKzI,KAAK;AAAA,IAAA,CAE/B;AAED,WAAO,MAAM;AACXjI,mBAAaC,YAAY;AAAA,IAC3B;AAAA,EACD,CAAA,GAEDiP,OAAO0Q,cAAc/X,KAAK,MAAM;AAC9B,UAAM7H,eAAe+wC,UAAUlxC,GAAG,KAAMoI,CAAU,UAAA;AAChD,cAAQA,MAAM+H,MAAI;AAAA,QAChB,KAAK;AACIwf,iBAAAA,WAAW9e,KAAKzI,KAAK;AAC5B;AAAA,QACF,KAAK;AACIunB,iBAAAA,WAAW9e,KAAKzI,KAAK;AAC5B;AAAA,QACF,KAAK;AACHiH,iBAAOnH,YAAY2I,KAAK;AAAA,YACtB,GAAGzI;AAAAA,YACH+H,MAAM;AAAA,YACNjP,OAAO6B,eACLsM,OAAOlH,YAAY/F,UACnBiN,OAAOnH,YAAYG,YAAAA,EAAcM,QAAQrC,OAAO5E,MAAMhB,MACtDuM,qBAAqBiL,IAAI7I,OAAOlH,WAAW,CAC7C;AAAA,UAAA,CACD;AACD;AAAA,QAEF;AACSD,iBAAAA,YAAY2I,KAAKzI,KAAK;AAAA,MAAA;AAAA,IACjC,CACD;AAED,WAAO,MAAM;AACXjI,mBAAaC,YAAY;AAAA,IAC3B;AAAA,EACD,CAAA,GAEDiP,OAAO0Q,cAAc/X,KAAK,MAAM;AAC9B,UAAM7H,eAAekP,OAAOnH,YAAYupC,UAAWzjC,CAAa,aAAA;AAC1DA,eAAS1F,QAAQ;AAAA,QAAC,aAAa;AAAA,MAAA,CAAY,KAC7C2oC,cAAcpgC,KAAK;AAAA,QAACV,MAAM;AAAA,QAAmB6B,UAAU;AAAA,MAAA,CAAK,GAC5Dk/B,UAAUrgC,KAAK;AAAA,QAACV,MAAM;AAAA,QAAmB6B,UAAU;AAAA,MAAA,CAAK,MAExDi/B,cAAcpgC,KAAK;AAAA,QAACV,MAAM;AAAA,QAAmB6B,UAAU;AAAA,MAAA,CAAM,GAC7Dk/B,UAAUrgC,KAAK;AAAA,QAACV,MAAM;AAAA,QAAmB6B,UAAU;AAAA,MAAA,CAAM;AAAA,IAAA,CAE5D;AAED,WAAO,MAAM;AACX7R,mBAAaC,YAAY;AAAA,IAC3B;AAAA,EACD,CAAA,GAEDiP,OAAO0Q,cAAc/X,KAAK,MAAM;AAC9B,UAAM7H,eAAekP,OAAOnH,YAAYlI,GAAG,KAAMoI,CAAU,UAAA;AACzD,cAAQA,MAAM+H,MAAI;AAAA,QAChB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACIwf,iBAAAA,WAAW9e,KAAKzI,KAAK;AAC5B;AAAA,QACF,KAAK;AACH6oC,wBAAcpgC,KAAK;AAAA,YAAC,GAAGzI;AAAAA,YAAO+H,MAAM;AAAA,UAAA,CAAQ;AAC5C;AAAA,MAAA;AAAA,IACJ,CACD;AAED,WAAO,MAAM;AACXhQ,mBAAaC,YAAY;AAAA,IAC3B;AAAA,EAAA,CACD,GAEM;AAAA,IACL6wC;AAAAA,IACAC;AAAAA,EACF;AACF;AC3UA,MAAMQ,qCACJtkC,cAAsC,IAAI,GAO/BukC,iCAAiCA,MAAA;AAC5CntC,QAAAA,YAAkBiM,WAAAihC,kCAA6C;AAAC,MAE5DltC,cAASf;AAAcR,UAAAA,IAAAA,MAEvB,6GAA+G;AAG5GuB,SAAAA;AAAS,GAEZhE,UAAQC,cAAc,gDAAgD;AAMrE,SAAAmxC,oCAAAjyC,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA,GAKL,CAAA2E,WAAAqtC,YAAA,IAAkC3gC,aAA8B;AAAC,MAAAhR,IAAAG;AAAAT,IAAA,CAAA,MAAAD,MAAAuI,eAGvDhI,KAAAA,MAAA;AACRM,YAAM,kCAAkC;AACxC,UAAAL,eAAqBR,MAAKuI,YAAAlI,GAAgB,aAAWoI,CAAA,UAAA;AAEnD0pC,sBAAA,MAAA;AAEED,qBAAazpC,MAAK5D,SAAU;AAAA,MAAA,CAC7B;AAAA,IAAA,CACF;AAAC,WAAA,MAAA;AAGMhE,cAAA,oCAAoC,GAC1CL,aAAYC,YAAa;AAAA,IAAC;AAAA,EAE3BC,GAAAA,KAAA,CAACV,MAAKuI,WAAA,GAAatI,EAAA,CAAA,IAAAD,MAAAuI,aAAAtI,OAAAM,IAAAN,OAAAS,OAAAH,KAAAN,EAAA,CAAA,GAAAS,KAAAT,EAAA,CAAA,IAdtBU,UAAUJ,IAcPG,EAAmB;AAACqQ,MAAAA;AAAA,SAAA9Q,SAAAD,MAAAyC,YAAAxC,SAAA4E,aAGrBkM,KAAA,oBAAA,mCAAA,UAAA,EAAoDlM,OAAQ,WACzD7E,UAAAA,MAAKyC,SACR,CAAA,GAA8CxC,EAAA,CAAA,IAAAD,MAAAyC,UAAAxC,OAAA4E,WAAA5E,OAAA8Q,MAAAA,KAAA9Q,EAAA,CAAA,GAF9C8Q;AAE8C;AC9DrCqhC,MAAAA,oBAAoB3kC,cAA0B,EAAgB;ACEpE,SAAA4kC,qBAAAryC,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA;AAAAK,MAAAA;AAAAN,WAAAD,SAQ+BO,KAAA+xC,CAClCtyC,WAAAA,MAAKwe,SAAU8zB,MAAM,GAACryC,OAAAD,OAAAC,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AADxBsyC,QAAAA,eAAqBjyC,eAAeC,EAEpC;AAACG,MAAAA;AAAAT,WAAAsyC,gBAAAtyC,EAAAD,CAAAA,MAAAA,MAAAgwB,cAEStvB,KAAAA,MAAA;AACR,UAAA2f,MAAYrgB,MAAKgwB,WAAA3vB,GAAe,KAAGoI,CAAA,UAAA;AACjC+pC,YAAAA,WAAeC,cAAchqC,KAAK;AAE9B6pC,kBACFC,aAAaD,QAAM;AAAA,IAAA,CAEtB;AAAC,WAAA,MAAA;AAEAjyB,UAAG5f,YAAa;AAAA,IAAC;AAAA,EAAA,GAEpBR,OAAAsyC,cAAAtyC,EAAA,CAAA,IAAAD,MAAAgwB,YAAA/vB,OAAAS,MAAAA,KAAAT,EAAA,CAAA;AAAA8Q,MAAAA;AAAA9Q,SAAAA,EAAA,CAAA,MAAAD,MAAAgwB,cAAEjf,KAAA,CAAC/Q,MAAKgwB,UAAA,GAAY/vB,EAAA,CAAA,IAAAD,MAAAgwB,YAAA/vB,OAAA8Q,MAAAA,KAAA9Q,EAAA,CAAA,GAXrBU,UAAUD,IAWPqQ,EAAkB,GAAC;AAAA;AAKjB,SAAS0hC,cACdhqC,OAC0B;AAC1B,UAAQA,MAAM+H,MAAI;AAAA,IAChB,KAAK;AACI,aAAA;AAAA,QAACA,MAAM;AAAA,QAAQ/H,OAAOA,MAAMA;AAAAA,MAAK;AAAA,IAE1C,KAAK;AACIA,aAAAA;AAAAA,IACT,KAAK;AACI,aAAA;AAAA,QAAC+H,MAAM;AAAA,QAAWkiC,WAAW;AAAA,MAAI;AAAA,IAE1C,KAAK;AACI,aAAA;AAAA,QAACliC,MAAM;AAAA,QAAWkiC,WAAW;AAAA,MAAK;AAAA,IAE3C,KAAK;AACI,aAAA;AAAA,QAACliC,MAAM;AAAA,QAAS/H,OAAOA,MAAMA;AAAAA,MAAK;AAAA,IAE3C,KAAK;AACI,aAAA;AAAA,QAAC+H,MAAM;AAAA,QAASjP,OAAOkH,MAAMlH;AAAAA,MAAK;AAAA,IAE3C,KAAK;AACI,aAAA;AAAA,QACLiP,MAAM;AAAA,QACNk8B,YAAYjkC,MAAMikC;AAAAA,QAClBnrC,OAAOkH,MAAMlH;AAAAA,MACf;AAAA,IAEF,KAAK;AACIkH,aAAAA;AAAAA,IAET,KAAK;AACIA,aAAAA;AAAAA,IAET,KAAK;AACIA,aAAAA;AAAAA,IAET,KAAK;AACIA,aAAAA;AAAAA,EAAAA;AAGb;ACnCA,MAAM5H,UAAQC,cAAc,8BAA8B;AAyEnD,MAAM6xC,2BAA2BC,UAEtC;AAAA,EACA,OAAcC,cAAc;AAAA;AAAA;AAAA;AAAA,EAIrBC,UAAyB,IAAIC,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBpC3yB,gBAAyC,CAAE;AAAA,EAC3C4yB,gBAAmC,CAAE;AAAA,EAE7CC,YAAYjzC,OAAgC;AAC1C,QAAA,MAAMA,KAAK,GAEPA,MAAMG;AACR,WAAKA,SAASH,MAAMG,QACpB,KAAKwB,cAAc,KAAKxB,OAAO0b,UAAUtT,YACtCG,YAAAA,EACAM,QAAQgJ,gBAAgB;AAAA,SACtB;AACC,YAAA;AAAA,QAAC82B;AAAAA,QAAQ3oC;AAAAA,QAAQigB;AAAAA,UAAiB+wB,qBAAqB;AAAA,QAC3D9b,cAAcr1B,MAAMuB;AAAAA,QACpB2V,cAAclX,MAAMkX;AAAAA,QACpB2S,WACE7pB,MAAM6pB,cAAc/lB,SAChBA,SACAovC,OAAOC,SAASnzC,MAAM6pB,UAAU3a,SAAS,GAAG,EAAE;AAAA,QACpDmD,UAAUrS,MAAMqS;AAAAA,QAChB1L,QAAQ3G,MAAMwS;AAAAA,MAAAA,CACf;AAED,WAAK4N,gBAAgBA,eACrB,KAAK0oB,SAASA,QAEd,KAAK3oC,SAASA,QACd,KAAKwB,cAAcmnC,OAAOvgC,YACvBG,YAAY,EACZM,QAAQgJ,gBAAgB;AAAA,IAAA;AAGxB08B,SAAAA,WAAW,KAAKvuC,OAAO0b,UAAU6yB;AAAAA,EAAAA;AAAAA,EAGxC0E,oBAA0B;AACxB,QAAI,CAAC,KAAKtK;AACR;AAGF,eAAWtoC,gBAAgB,KAAK4f;AACzB4yB,WAAAA,cAAc3qC,KAAK7H,cAAc;AAGxC,UAAM6yC,yBAAyB,KAAKvK,OAAO9Y,WAAW3vB,GAAG,KAAMoI,CAAU,UAAA;AACjE6pC,YAAAA,SAASG,cAAchqC,KAAK;AAE7B6pC,iBAIA,KAAKtyC,MAAMG,UACd,KAAKH,MAAMwe,SAAS8zB,MAAM,GAG5B,KAAKQ,QAAQpqB,KAAK4pB,MAAM;AAAA,IAAA,CACzB;AAEIU,SAAAA,cAAc3qC,KAAKgrC,uBAAuB5yC,WAAW,GAE1D,KAAKqoC,OAAOvgC,YAAY/C,MAAAA,GACxB,KAAKsjC,OAAOwI,cAAc9rC,MAAAA,GAC1B,KAAKsjC,OAAO9Y,WAAWxqB,SACvB,KAAKsjC,OAAOyI,UAAU/rC,MAAM;AAAA,EAAA;AAAA,EAG9B8tC,mBAAmBC,WAAoC;AAGnD,KAAC,KAAKvzC,MAAMG,UACZ,CAACozC,UAAUpzC,UACX,KAAKH,MAAMwS,eAAe+gC,UAAU/gC,cAEpChH,QAAQC,KAAK,6CAA6C,GAGxD,CAAC,KAAKzL,MAAMG,UAAU,CAACozC,UAAUpzC,WAC/B,KAAKH,MAAMqS,aAAakhC,UAAUlhC,YACpC,KAAKlS,OAAO0b,UAAUtT,YAAY2I,KAAK;AAAA,MACrCV,MAAM;AAAA,MACN6B,UAAU,KAAKrS,MAAMqS,YAAY;AAAA,IAClC,CAAA,GAGC,KAAKrS,MAAM6pB,cAAc0pB,UAAU1pB,aACrC,KAAK1pB,OAAO0b,UAAUtT,YAAY2I,KAAK;AAAA,MACrCV,MAAM;AAAA,MACNqZ,WACE,KAAK7pB,MAAM6pB,cAAc/lB,SACrBA,SACAovC,OAAOC,SAAS,KAAKnzC,MAAM6pB,UAAU3a,YAAY,EAAE;AAAA,IAAA,CAC1D,GAGC,KAAKlP,MAAMuB,UAAUgyC,UAAUhyC,SACjC,KAAKpB,OAAO+Q,KAAK;AAAA,MACfV,MAAM;AAAA,MACNjP,OAAO,KAAKvB,MAAMuB;AAAAA,IAAAA,CACnB,GAID,KAAKvB,MAAMwzC,cAAcD,UAAUC,aACnC,KAAKxzC,MAAMwzC,cAEX,KAAKxzC,MAAMwzC,UAAUh0B,UAAU;AAAA,EAAA;AAAA,EAKrCi0B,uBAA6B;AAC3B,eAAWhzC,eAAe,KAAKuyC;AACjB,kBAAA;AAGV,SAAKlK,WACPr0B,UAAU,KAAKq0B,OAAOvgC,WAAW,GACjCkM,UAAU,KAAKq0B,OAAOwI,aAAa,GACnC78B,UAAU,KAAKq0B,OAAO9Y,UAAU,GAChCvb,UAAU,KAAKq0B,OAAOyI,SAAS;AAAA,EAAA;AAAA,EAI5BmC,cAAehF,CAA0B,aAAA;AACzCvuC,SAAAA,OAAO0b,UAAU6yB,WAAW;AAAA,MAC/B,GAAG,KAAKvuC,OAAO0b,UAAU6yB;AAAAA,MACzB,GAAGA;AAAAA,IACL;AAAA,EACF;AAAA,EAEAiF,SAAS;AACDC,UAAAA,gBAAiB,KAAK5zC,MAAMG,SAE9B2D,SADC,KAAK9D,MAAM6zC,oBAAoB,KAAK7zC,MAAM8zC;AAG/C,WAEKF,qBAAAA,UAAAA,EAAAA,UAAAA;AAAAA,MACC,gBAAA,oBAAC,uCACC,aAAa,KAAKzzC,OAAO0b,UAAUtT,aACnC,UAAUqrC,cAAAA,CACV,IACA;AAAA,MACJ,oBAAC,mBAAmB,UAAnB,EAA4B,OAAO,KAAKzzC,OAAO0b,UAAUtT,aACxD,UAAC,oBAAA,kBAAkB,UAAlB,EAA2B,OAAO,KAAKugC,OAAQ9Y,YAC9C,UAAA,oBAAC,SACC,QAAQ,KAAK7vB,OAAO0b,UAAUrT,YAAYsT,UAC1C,cAAc,KAAK3b,OAAO0b,UAAUrT,YAAY6sB,cAEhD,8BAAC,0BAA0B,UAA1B,EAAmC,OAAO,MACzC,UAAA,oBAAC,uCACC,aAAa,KAAKl1B,OAAO0b,UAAUtT,aAElC,UAAA,KAAKvI,MAAMyC,SACd,CAAA,EACF,CAAA,EACF,CAAA,EACF,CAAA,EACF,CAAA;AAAA,IAAA,GACF;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcJ,OAAO2W,oBACLjZ,CAAAA,WAEOA,UAAUA,OAAOuuC,WAAWvuC,OAAOuuC,SAASt1B,kBAAkB,IAAI,CAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa7E,OAAOkyB,qBAAqBA,CAC1BnrC,QACAorC,mBAEOprC,UAAUA,OAAOuuC,WACpBvuC,OAAOuuC,SAASpD,mBAAmBC,cAAc,IACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBN,OAAOC,gBAAgBA,CACrBrrC,QACAqQ,MACAjP,UAEApB,OAAOuuC,UAAUlD,cAAch7B,MAAMjP,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa5C,OAAOqjC,OAAQzkC,CAAqC,WAAA;AAClDU,YAAM,cAAc,GACpBV,OAAOuuC,UAAU9J,KAAK;AAAA,EACxB;AAAA,EAEA,OAAOxd,SAASA,CACdjnB,QACA0E,WACA0R,YACGpW,OAAOuuC,UAAUtnB,OAAOviB,WAAW0R,OAAO;AAAA,EAE/C,OAAO40B,cAAcA,CACnBhrC,QACA4G,YAEO5G,OAAOuuC,UAAUvD,YAAYpkC,OAAO;AAAA,EAG7C,OAAOgkC,aAAaA,CAAC5qC,QAA4B6E,SACxC7E,OAAOuuC,UAAU3D,WAAW/lC,IAAI,KAAK,CAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAchD,OAAOD,QAAS5E,CAAqC,WAAA;AACnDU,YAAM,uBAAuB,GAC7BV,OAAOuuC,UAAU3pC,MAAM;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAOgB,aAAc5F,CACZA,WAAAA,OAAOuuC,UAAU3oC,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAarC,OAAOG,aACL/F,CAEOA,WAAAA,OAAOuuC,UAAUxoC,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAarC,OAAOylC,eAAgBxrC,CACdA,WAAAA,OAAOuuC,WAAWvuC,OAAOuuC,SAAS/C,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa5D,OAAOC,WAAYzrC,CACVA,WAAAA,OAAOuuC,UAAU9C,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAanC,OAAOf,gBAAgBA,CAAC1qC,QAA4B4zC,eAC3C5zC,OAAOuuC,UAAU7D,cAAckJ,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAalD,OAAOjJ,eAAeA,CAAC3qC,QAA4B6zC,cAC1C7zC,OAAOuuC,UAAU5D,aAAakJ,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAahD,OAAOnI,uBAAwB1rC,CAC7BA,WAAAA,OAAOuuC,UAAU7C,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYxC,OAAOC,sBAAuB3rC,CAC5BA,WAAAA,OAAOuuC,UAAU5C,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYvC,OAAOvB,eAAeA,CAACpqC,QAA4BwY,SACjDxY,OAAOuuC,UAAUnE,aAAa5xB,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBpC,OAAO+xB,cAAcA,CACnBvqC,QACAqQ,MACAjP,WAEAV,QAAM,sBAAsB,GACrBV,OAAOuuC,UAAUhE,YAAYl6B,MAAMjP,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBjD,OAAOwmB,cAAcA,CACnB5nB,QACAqQ,MACAjP,UAEOpB,OAAOuuC,UAAU3mB,YAAYvX,MAAMjP,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcjD,OAAO2oB,cAAe/pB,CACbA,WAAAA,OAAOuuC,UAAUxkB,YAAY;AAAA,EAGtC,OAAOne,SAASA,CACd5L,QACA4G,YAEO5G,OAAOuuC,UAAU3iC,OAAOhF,OAAO;AAAA,EAGxC,OAAOktC,eAAeA,CAACC,SAA6BlvC,SAAwB;AAC1E,QAAI,CAACA,QAAQ,CAACpD,MAAMC,QAAQmD,IAAI,EAAU,QAAA;AAC1C,UAAMmvC,wBAAwBnvC,KAAKjB,SAAS,KAAKiB,KAAK,CAAC,MAAM;AAE7D,WAD8BA,KAAKjB,SAAS,KAAKiB,KAAK,CAAC,MAAM,cAC7BmvC;AAAAA,EAClC;AAAA,EAEA,OAAOpxC,QAAS5C,CACPA,WAAAA,OAAOuuC,UAAU3rC,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAehC,OAAO+kB,SAASA,CACd3nB,QACA0E,cACG;AACHhE,YAAM,0BAA0BgE,SAAS,GACzC1E,OAAOuuC,UAAU5mB,OAAOjjB,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,OAAO6mC,mBAAmBA,CACxBvrC,QACAqQ,SACGrQ,OAAOuuC,UAAUhD,iBAAiBl7B,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAc3C,OAAO85B,mBAAmBA,CACxBnqC,QACA4zC,gBAEAlzC,QAAM,8BAA8B,GAC7BV,OAAOuuC,UAAUpE,iBAAiByJ,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAerD,OAAO1J,aAAaA,CAAClqC,QAA4B6zC,cACxC7zC,OAAOuuC,UAAUrE,WAAW2J,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAe9C,OAAO5J,aAAaA,CAACjqC,QAA4BwY,SAAuB;AACtE9X,YAAM,sBAAsB8X,IAAI,GAChCxY,OAAOuuC,UAAUtE,WAAWzxB,IAAI;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAOozB,cACL5rC,CAEOA,WAAAA,OAAOuuC,UAAU3C,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EActC,OAAOvhB,OAAQrqB,CAAqC,WAAA;AAClDU,YAAM,cAAc,GACpBV,OAAOuuC,UAAUlkB,KAAK;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAOF,OAAQnqB,CAAqC,WAAA;AAClDU,YAAM,cAAc,GACpBV,OAAOuuC,UAAUpkB,KAAK;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAO0hB,0BAA0BA,CAC/B7rC,QACA8rC,YACAC,eAEO/rC,OAAOuuC,UAAU1C,wBAAwBC,YAAYC,UAAU;AAE1E;AAEA,SAAAkI,oCAAAp0C,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA;AAAA,MAAAK,IAAAG;AAAAT,SAAAA,EAAAD,CAAAA,MAAAA,MAAAuI,eAAAtI,EAAA,CAAA,MAAAD,MAAA8zC,YAIYvzC,KAAAA,MAAA;AACR,UAAAC,eAAqBR,MAAK8zC,SAAAhC,UAAAuC,CAAA,YAAA;AACxBr0C,YAAKuI,YAAA2I,KAAA;AAAA,QAAAV,MACG;AAAA,QAAS,GACZ6jC;AAAAA,MAAAA,CACJ;AAAA,IAAA,CACF;AAAC,WAAA,MAAA;AAGA7zC,mBAAYC,YAAa;AAAA,IAAC;AAAA,EAAA,GAE3BC,MAACV,MAAKuI,aAAcvI,MAAK8zC,QAAA,GAAU7zC,EAAA,CAAA,IAAAD,MAAAuI,aAAAtI,EAAA,CAAA,IAAAD,MAAA8zC,UAAA7zC,OAAAM,IAAAN,OAAAS,OAAAH,KAAAN,EAAA,CAAA,GAAAS,KAAAT,EAAA,CAAA,IAXtCU,UAAUJ,IAWPG,EAAmC,GAAC;AAAA;AC7vBlC,SAAS4zC,WAAWt0C,OAAwB;AAC3CwI,QAAAA,cAAckJ,kBACdnJ,cAAcuI,WAAWtD,kBAAkB,GAC3C0F,eAAepB,YAAYvJ,aAAcwJ,CAAAA,MAC7CA,EAAE/I,QAAQgJ,iBACZ,GACMuiC,UAAU9iC,OAAoB,IAAI,GAClC+iC,qBAAqBtgC,yBACrBugC,gBAAgB7iC,YAAY,GAC5B,CAACM,SAASwiC,UAAU,IAAInjC,SAAS,EAAK,GACtC,CAACI,UAAUgjC,WAAW,IAAIpjC,SAAS,EAAK,GAExCvK,SAAShH,MAAMyC,SAASzC,MAAMgH,QAC9BjF,QAAQiF,UAAUwB,YAAYf,YAAYT,MAAM,IAAIA,SAASlD,QAE7DkB,OAAO4vC,QACX,MACE7yC,QACI,CAAC;AAAA,IAACP,MAAMO,MAAMP;AAAAA,KAAO,YAAY;AAAA,IAACA,MAAMxB,MAAM60C,KAAKrzC;AAAAA,EAAAA,CAAK,IACxDsC,QACN,CAAC/B,OAAO/B,MAAM60C,KAAKrzC,IAAI,CACzB,GAEMszC,uBAAuBvsC,YAC1BG,YAAAA,EACAM,QAAQrC,OAAOiS,WAAW9W,IAAK+W,CAAAA,cAAcA,UAAU9X,IAAI,GAExD6X,aAAagG,MAChB5e,MAAM60C,KAAK9xC,SAAS,CAAA,GAAI0U,OAAQkB,CAAAA,SAC/Bm8B,qBAAqBh8B,SAASH,IAAI,CACpC,CACF,GAEMo8B,sBAAsB/0C,MAAM60C,KAAK9xC,SAAS,CAAE,GAAEqT,QAASuC,CAAS,WAAA;AAChEm8B,QAAAA,qBAAqBh8B,SAASH,MAAI;AACpC,aAAO,CAAE;AAGX,UAAMgE,YAAU5a,OAAOQ,UAAUsK,KAAM8P,CAAYA,YAAAA,QAAQnb,SAASmX,MAAI;AAExE,WAAIgE,YACK,CAACA,SAAO,IAGV,CAAE;AAAA,EACV,CAAA,GAEKq4B,+BACJD,mBAAmBhxC,SAAS,KAAK0wC;AAEnC9zC,YAAU,MAAM;AACd,QAAI,CAACq0C,8BAA8B;AACjCN,iBAAW,EAAK;AAChB;AAAA,IAAA;AAGIO,UAAAA,MAAMtC,mBAAmBhH,aAAa6I,kBAAkB;AAG5DS,WACAxzC,QAAQwzC,IAAIlwC,MAAMC,MAAMA,IAAI,KAC5B2tC,mBAAmB9G,qBAAqB2I,kBAAkB,KAE1DrC,gBAAgB,MAAM;AACpBuC,iBAAW,EAAI;AAAA,IAAA,CAChB;AAAA,EAEF,GAAA,CAACM,8BAA8BhwC,MAAMwvC,kBAAkB,CAAC;AAGrDU,QAAAA,uBAAuBC,YAAY,MAAM;AAC7C,QAAI,CAACH;AACH;AAGII,UAAAA,eAAezqC,OAAOghC,aAAa;AAEzC,QAAI,CAACyJ,cAAc;AACjBT,kBAAY,EAAK;AACjB;AAAA,IAAA;AAGES,QAAAA,gBAAgBA,aAAaC,aAAa,GAAG;AACzCvtC,YAAAA,QAAQstC,aAAaE,WAAW,CAAC;AAEnCf,cAAQ/0B,WAAW1X,MAAMytC,eAAehB,QAAQ/0B,OAAO,IACzDm1B,YAAY,EAAI,IAEhBA,YAAY,EAAK;AAAA,IAErB;AACEA,kBAAY,EAAK;AAAA,EAAA,GAElB,CAACK,4BAA4B,CAAC;AAEjCr0C,YAAU,MAAM;AACd,QAAI,CAACq0C;AACH;AAGF,UAAMQ,SAASjtC,YAAYlI,GAAG,WAAW,MAAM;AAClC,iBAAA,EAAK,GAChBs0C,YAAY,EAAK;AAAA,IAClB,CAAA,GAEKc,UAAUltC,YAAYlI,GAAG,WAAW,MAAM;AACxC40C,YAAAA,QAAMtC,mBAAmBhH,aAAa6I,kBAAkB;AAG5DS,eACAxzC,QAAQwzC,MAAIlwC,MAAMC,MAAMA,IAAI,KAC5B2tC,mBAAmB9G,qBAAqB2I,kBAAkB,KAE1DE,WAAW,EAAI,GAGjBQ,qBAAqB;AAAA,IAAA,CACtB,GAEKQ,cAAcntC,YAAYlI,GAAG,aAAcoI,CAAU,UAAA;AAEvDA,YAAM5D,aACNpD,QAAQgH,MAAM5D,UAAUE,MAAMC,MAAMA,IAAI,KACxC2tC,mBAAmB9G,qBAAqB2I,kBAAkB,IAE1DE,WAAW,EAAI,IAEfA,WAAW,EAAK,GAElBQ,qBAAqB;AAAA,IAAA,CACtB;AAED,WAAO,MAAM;AACXM,aAAO/0C,eACPg1C,QAAQh1C,YAAY,GACpBi1C,YAAYj1C,YAAY;AAAA,IAC1B;AAAA,EACC,GAAA,CACD8H,aACAvD,MACAwvC,oBACAU,sBACAF,4BAA4B,CAC7B,GAEDr0C,UAAU,MAAMu0C,wBAAwB,CAACA,oBAAoB,CAAC;AAE9D,MAAIzyC,WAAWzC,MAAMyC;AAKrB,aAAWkW,UAAQC,YAAY;AAC7B,UAAM+8B,4BAA4BziC,aAAa0F,WAAW/L,KACvD8gC,CAAQA,QAAAA,IAAIpsC,UAAUoX,MACzB;AAEI3T,YAAQ2wC,6BAA6B31C,MAAM41C,oBAC7CnzC,WAAWzC,MAAM41C,gBAAgB;AAAA,MAC/BnzC;AAAAA,MACA8P,kBAAkBgiC;AAAAA,MAClBriC;AAAAA,MACAlN;AAAAA,MACA2M;AAAAA,MACAa,YAAYmjC;AAAAA,MACZp0C,OAAOoX;AAAAA,MACPnI,MAAMmlC;AAAAA,IAAAA,CACP;AAAA,EAAA;AAOL,aAAWE,qBAAqBd,oBAAoB;AAC5Ce,UAAAA,6BAA6B5iC,aAAaH,YAAYlG,KACzDnJ,OAAMA,EAAE3C,SAAS80C,kBAAkB7zC,KACtC;AACI8zC,mCACE/zC,SAASiD,QAAQhF,MAAM+1C,mBACzBtzC,WACE,oBAAC,QAAK,EAAA,KAAK8xC,SACRv0C,UAAAA,MAAM+1C,iBAAiB;AAAA,MACtBh0C;AAAAA,MACAU;AAAAA,MACA8P,kBAAkBgiC;AAAAA,MAClBriC;AAAAA,MACAlN;AAAAA,MACA2M;AAAAA,MACAa,YAAYsjC;AAAAA,MACZv0C,OAAOs0C;AAAAA,MACPrlC,MAAMslC;AAAAA,IAAAA,CACP,EACH,CAAA,IAGFrzC,+BAAY,QAAK,EAAA,KAAK8xC,SAAU9xC,SAAS,CAAA;AAAA,EAAA;AAQ3CV,MAAAA,SAASiD,QAAQhF,MAAM8S,aAAa;AAChCpQ,UAAAA,QAAQX,MAAMU,SAASoK,KAC1BmpC,YAAWA,OAAOx0C,SAASxB,MAAM60C,KAAKrzC,IACzC;AAEIkB,cACFD,WAAWzC,MAAM8S,YAAY;AAAA,MAC3BC,aAAagiC;AAAAA,MACbtyC;AAAAA,MACA8P,kBAAkBgiC;AAAAA,MAClBriC;AAAAA,MACAlN;AAAAA,MACAwN,YAAYU,aAAamE;AAAAA,MACzB1F;AAAAA,MACApQ,OAAOmB;AAAAA,MACP8N,MAAM0C,aAAamE;AAAAA,IAAAA,CACpB;AAAA,EAAA;AAIL,6BACG,QAAK,EAAA,GAAIrX,MAAMoS,YAAY,KAAKmiC,SAC9B9xC,UACH;AAEJ;ACrPA,MAAMwzC,oBAAmC;AAAA,EACvCjrC,UAAU;AAAA,EACViD,YAAY;AAAA,EACZioC,eAAe;AAAA,EACftf,MAAM;AAAA,EACNK,OAAO;AACT;AAEO,SAAAkf,WAAAn2C,OAAA;AAAAC,QAAAA,IAAAC,EAAA,EAAA,GAULqI,cAAoBuI,WAAAtD,kBAA6B,GACjD7G,SAAemL,YAAYvJ,aAAWsL,KAAyB;AAAC,MAE5D7T,MAAK60C,KAAA7yC,UAAgB2E,OAAM0Q,KAAAtW;AAAU,WAChCf,MAAKyC;AAAAlC,MAAAA;AAAAN,WAAAD,SAGKO,KAAC,oBAAA,YAAA,EAAeP,GAAAA,OAAS,GAAAC,OAAAD,OAAAC,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AAA5C,MAAAm2C,eAAmB71C;AAGjBP,MAAAA,MAAKq2C,qBACLr2C,MAAK60C,KAAAyB,eACLt2C,MAAK8C,KAAAA,SAAe,IAAE;AAAApC,QAAAA;AAAAT,MAAA,CAAA,MAAAD,MAAAq2C,qBAKf31C,KAAAV,MAAKq2C,qBAAoBp2C,EAAA,CAAA,IAAAD,MAAAq2C,mBAAAp2C,OAAAS,MAAAA,KAAAT,EAAA,CAAA;AAAA8Q,QAAAA;AAAA9Q,aAAAS,MAD5BqQ,mCAAaklC,OAAAA,mBAAoC,iBAAA,IAC9Cv1C,cACH,GAAOT,OAAAS,IAAAT,OAAA8Q,MAAAA,KAAA9Q,EAAA,CAAA;AAAA8T,QAAAA;AAAA9T,WAAAA,EAAAm2C,CAAAA,MAAAA,gBAAAn2C,SAAA8Q,MAHTgD,KACEhD,qBAAAA,UAAAA,EAAAA,UAAAA;AAAAA,MAAAA;AAAAA;MAGa,CAAA,GACZ9Q,OAAAm2C,cAAAn2C,OAAA8Q,IAAA9Q,OAAA8T,MAAAA,KAAA9T,EAAA,CAAA,GALH8T;AAAAA,EAAAA;AASJwiC,QAAAA,kBAAwBv2C,MAAK60C,KAAA0B;AAAqB,MAE9CA,iBAAe;AAAA71C,QAAAA;AAAAT,MAAAs2C,CAAAA,MAAAA,mBAAAt2C,UAAAm2C,gBACF11C,KAAA61C,gBAAeC,UAAA;AAAA,MAAA/zC,UAAsB2zC;AAAAA,IAAAA,CAAa,GAACn2C,OAAAs2C,iBAAAt2C,QAAAm2C,cAAAn2C,QAAAS,MAAAA,KAAAT,EAAA,EAAA,GAAlEm2C,eAAeA;AAAAA,EAAAA;AAGVA,SAAAA;AAAY;AAxCd,SAAAviC,MAAA9B,GAAA;AAAA,SAW0CA,EAAC/I,QAAArC;AAAA;AC3B3C,SAAA8vC,WAAAz2C,OAAA;AAAAC,QAAAA,IAAAC,EAAA,CAAA;AAAAK,MAAAA;AAAA,SAAAN,EAAAD,CAAAA,MAAAA,MAAAoS,cAAAnS,EAAAD,CAAAA,MAAAA,MAAAyC,YAAAxC,SAAAD,MAAA8C,KAAAtB,QAAAvB,EAAA,CAAA,MAAAD,MAAA8C,KAAAd,SAEHzB,mCACMP,GAAAA,MAAKoS,YACO,kBAAApS,MAAK8C,KAAAtB,MACJ,mBAAAxB,MAAK8C,KAAAd,OACN,mBAAA,QAEfhC,UAAAA,MAAKyC,SACR,CAAA,GAAOxC,EAAA,CAAA,IAAAD,MAAAoS,YAAAnS,EAAA,CAAA,IAAAD,MAAAyC,UAAAxC,EAAAD,CAAAA,IAAAA,MAAA8C,KAAAtB,MAAAvB,EAAAD,CAAAA,IAAAA,MAAA8C,KAAAd,OAAA/B,OAAAM,MAAAA,KAAAN,EAAA,CAAA,GAPPM;AAOO;ACNX,MAAMM,UAAQC,cAAc,oBAAoB;AAMhC41C,SAAAA,kBACdnuC,aACAisC,oBACAmC,oBACwD;AAClDC,QAAAA,kBAAkB,CAAC,SAAS,OAAO,SAAS,UAAU,KAAK,GAC3DC,gBAAgBF,sBAAsB,CAAC;AAC7C,SAAO,SAAqBx2C,QAA+C;AACzEA,WAAAA,OAAO22C,iBAAkBruC,CAA+C,UAAA;AAEtE6L,aAAO4Y,KAAK2pB,aAAa,EAAEriC,QAASuiC,CAAQ,QAAA;AAC1C,YAAIA,QAAQ;AACCtf,qBAAAA,UAAUof,cAAcE,GAAG,GAAG;AACnCH,gBAAAA,gBAAgB99B,SAAS2e,MAAM;AACjC,oBAAM,IAAIn0B,MAAM,cAAcm0B,MAAM,eAAe;AAErD,gBAAID,SAASC,QAAQhvB,MAAMm5B,WAAW,GAAG;AACvCn5B,oBAAMu5B,eAAe;AACfgV,oBAAAA,eAAeH,cAAcE,GAAG;AACtC,kBAAIC,cAAc;AACVr+B,sBAAAA,OAAOq+B,aAAavf,MAAM;AAChC52B,wBAAM,UAAU42B,MAAM,cAAc9e,IAAI,EAAE,GAC1CpQ,YAAY2I,KAAK;AAAA,kBACfV,MAAM;AAAA,kBACNuZ,eAAe;AAAA,oBACbvZ,MAAM;AAAA,oBACNqI,WAAWF;AAAAA,kBACb;AAAA,kBACAxY;AAAAA,gBAAAA,CACD;AAAA,cAAA;AAAA,YACH;AAAA,UACF;AAGJ,YAAI42C,QAAQ;AACCtf,qBAAAA,UAAUof,cAAcE,GAAG,GAAG;AACnCH,gBAAAA,gBAAgB99B,SAAS2e,MAAM;AACjC,oBAAM,IAAIn0B,MAAM,cAAcm0B,MAAM,eAAe;AAErD,gBAAID,SAASC,QAAQhvB,MAAMm5B,WAAW,GAAG;AACjCqV,oBAAAA,kBAAkBJ,cAAcE,GAAG;AACzC,kBAAIE,iBAAiB;AACb5gB,sBAAAA,UAAU4gB,gBAAgBxf,MAAM;AACtCpB,wBAAQ5tB,OAAO+rC,kBAAkB;AAAA,cAAA;AAAA,YACnC;AAAA,UACF;AAAA,MACF,CAEH;AAAA,IAAA,GAEIr0C;AAAAA,EACT;AACF;AC3CA,MAAM+2C,yBAIFA,CAAC;AAAA,EAAChT;AAAAA,EAAOhG;AAAQ,MAAM;AACnB8K,QAAAA,gBAAgB9E,MAAM17B,YAAYyT;AAElCzT,SAAAA,MAAAA,YAAYyT,QAASc,CAAO,OAAA;AAC5BA,OAAGvM,SAAS,mBACd0tB,SAAS;AAAA,MAAC1tB,MAAM;AAAA,MAAmBpE,WAAW2Q;AAAAA,IAAAA,CAAG,GAGnDisB,cAAcjsB,EAAE;AAAA,EAAA,GAGX,MAAM;AACXmnB,UAAM17B,YAAYyT,QAAQ+sB;AAAAA,EAC5B;AACF,GAIamO,0BAA0BvuC,MAAM;AAAA,EAC3C0P,OAAO;AAAA,IACLtP,SAAS,CAAC;AAAA,IASVk7B,OAAO,CAAC;AAAA,IAORF,QAAQ,CAAA;AAAA,EAgBV;AAAA,EACAzzB,SAAS;AAAA,IACP,oCAAoC6zB,OAAO;AAAA,MACzCgT,yBAAyBA,CAAC;AAAA,QAACpuC;AAAAA,QAASP;AAAAA,MAAAA,MAC9BA,MAAM+H,SAAS,8BACVxH,QAAQouC,0BAGV3uC,MAAM4uC;AAAAA,IAAAA,CAEhB;AAAA,IACD,oCAAoCjT,OAAO;AAAA,MACzCkT,iBAAiBA,CAAC;AAAA,QAACtuC;AAAAA,MAAAA,MAAa;AAC9B,cAAMuuC,uBAA8C,CAAE;AAE3ChB,mBAAAA,mBAAmBvtC,QAAQouC,yBAAyB;AAC7D,gBAAMI,aAAa9rC,aACjB6qC,gBAAgB1xC,WAChBmE,QAAQR,WACV;AAEA,cAAI,CAACjD,MAAMshB,QAAQ2wB,UAAU,GAAG;AAC9BjB,4BAAgBkB,UAAU;AAAA,cACxBjxB,cAAc;AAAA,cACd+vB;AAAAA,cACA/1B,QAAQ;AAAA,YAAA,CACT;AACD;AAAA,UAAA;AAGF+2B,+BAAqBlvC,KAAK;AAAA,YACxBkuC;AAAAA,YACA,GAAGiB;AAAAA,UAAAA,CACJ;AAAA,QAAA;AAGID,eAAAA;AAAAA,MAAAA;AAAAA,IACT,CACD;AAAA,IACD,4BAA4BnT,OAAO;AAAA,MACjCkT,iBAAiBA,CAAC;AAAA,QAACtuC;AAAAA,QAASP;AAAAA,MAAAA,MAAW;AACrC,YAAIA,MAAM+H,SAAS;AACjB,iBAAOxH,QAAQsuC;AAGjB,cAAMC,uBAA8C,CAAE;AAE3ChB,mBAAAA,mBAAmB9tC,MAAM4uC,kBAAkB;AACpD,gBAAMG,aAAa9rC,aACjB6qC,gBAAgB1xC,WAChBmE,QAAQR,WACV;AAEA,cAAI,CAACjD,MAAMshB,QAAQ2wB,UAAU,GAAG;AAC9BjB,4BAAgBkB,UAAU;AAAA,cACxBjxB,cAAc;AAAA,cACd+vB;AAAAA,cACA/1B,QAAQ;AAAA,YAAA,CACT;AACD;AAAA,UAAA;AAGF+2B,+BAAqBlvC,KAAK;AAAA,YACxBkuC;AAAAA,YACA,GAAGiB;AAAAA,UAAAA,CACJ;AAAA,QAAA;AAGID,eAAAA;AAAAA,MAAAA;AAAAA,IACT,CACD;AAAA,IACD,0BAA0BnT,OAAO;AAAA,MAC/BkT,iBAAiBA,CAAC;AAAA,QAACtuC;AAAAA,QAASP;AAAAA,MAAAA,MAAW;AACrC,YAAIA,MAAM+H,SAAS;AACjB,iBAAOxH,QAAQsuC;AAGjB,cAAMC,uBAA8C,CAAE;AAE3CG,mBAAAA,kBAAkB1uC,QAAQsuC,iBAAiB;AACpD,gBAAME,aAAa9rC,aACjBgsC,eAAenB,gBAAgB1xC,WAC/BmE,QAAQR,WACV;AAEA,cAAI,CAACjD,MAAMshB,QAAQ2wB,UAAU,GAAG;AAC9BE,2BAAenB,gBAAgBkB,UAAU;AAAA,cACvCjxB,cAAc;AAAA,cACd+vB,iBAAiBmB,eAAenB;AAAAA,cAChC/1B,QAAQ;AAAA,YAAA,CACT;AACD;AAAA,UAAA;AAGEmG,cAAAA;AAEJA,cAAAA,WAAWxa,qBAAqBqrC,YAAY/uC,MAAM2D,SAAS,GAExDua,YAAYA,aAAa6wB,cACzB7wB,aAAa,QAAQ6wB,YACtB;AACMG,kBAAAA,oBAAoBhxB,WACtB9e,sBAAsB;AAAA,cACpBlB,QAAQqC,QAAQrC;AAAAA,cAChBxG,QAAQ6I,QAAQR;AAAAA,cAChBV,OAAO6e;AAAAA,YACR,CAAA,IACD;AAEJ+wB,2BAAenB,gBAAgBkB,UAAU;AAAA,cACvCjxB,cAAcmxB;AAAAA,cACdpB,iBAAiBmB,eAAenB;AAAAA,cAChC/1B,QAAQ;AAAA,YAAA,CACT;AAAA,UAAA;AAKCmG,uBAAa,QACf4wB,qBAAqBlvC,KAAK;AAAA,YACxB,GAAIse,YAAY6wB;AAAAA,YAChBjB,iBAAiB;AAAA,cACf,GAAGmB,eAAenB;AAAAA,cAClB1xC,WAAWgD,sBAAsB;AAAA,gBAC/BlB,QAAQqC,QAAQrC;AAAAA,gBAChBxG,QAAQ6I,QAAQR;AAAAA,gBAChBV,OAAO6e;AAAAA,cACR,CAAA;AAAA,YAAA;AAAA,UACH,CACD;AAAA,QAAA;AAIE4wB,eAAAA;AAAAA,MAAAA;AAAAA,IACT,CACD;AAAA,IACD,mBAAmBnT,OAAO;AAAA,MACxB/xB,UAAUA,CAAC;AAAA,QAACrJ;AAAAA,QAASP;AAAAA,MAAAA,MACfA,MAAM+H,SAAS,qBACVxH,QAAQqJ,WAGV5J,MAAM4J;AAAAA,IAAAA,CAEhB;AAAA,IACD,0BAA0B+xB,OAAO;AAAA,MAC/BwT,aAAaA,CAAC;AAAA,QAAC5uC;AAAAA,MAAAA,MACNA,QAAQ4uC,cAAc;AAAA,IAEhC,CAAA;AAAA,EACH;AAAA,EACA9O,QAAQ;AAAA,IACN,4BAA4BC,aAAamO,sBAAsB;AAAA,EACjE;AAAA,EACAlS,QAAQ;AAAA,IACN,iCAAiC6S,CAAC;AAAA,MAAC7uC;AAAAA,IAAAA,MACjCA,QAAQouC,wBAAwBrzC,SAAS;AAAA,IAC3C,yBAAyB+zC,CAAC;AAAA,MAAC9uC;AAAAA,IAAAA,MAAaA,QAAQsuC,gBAAgBvzC,SAAS;AAAA,IACzE,6BAA6Bg0C,CAAC;AAAA,MAAC/uC;AAAAA,MAASP;AAAAA,IAAAA,MAAW;AACjD,UAAIA,MAAM+H,SAAS;AACV,eAAA;AAGT,YAAMwnC,2BAA2BhvC,QAAQsuC,gBAAgBx1C,IACtD41C,CAAoB,oBAAA;AAAA,QACnB1vC,QAAQ0vC,eAAenB,gBAAgB1xC,WAAWmD;AAAAA,QAClDjD,OAAO2yC,eAAenB,gBAAgB1xC,WAAWE;AAAAA,MAAAA,EAErD,GAEMkzC,sBAAsBxvC,MAAM4uC,iBAAiBv1C,IAChDy0C,CAAqB,qBAAA;AAAA,QACpBvuC,QAAQuuC,gBAAgB1xC,WAAWmD;AAAAA,QACnCjD,OAAOwxC,gBAAgB1xC,WAAWE;AAAAA,MAAAA,EAEtC;AAEkB,aAAA,CAACtD,QAAQu2C,0BAA0BC,mBAAmB;AAAA,IAG1E;AAAA,IACA,iBAAiBC,CAAC;AAAA,MAAClvC;AAAAA,IAAAA,MAAa,CAACA,QAAQqJ;AAAAA,IACzC,qBAAqB8lC,CAAC;AAAA,MAACnvC;AAAAA,UAAaA,QAAQovC;AAAAA,EAAAA;AAEhD,CAAC,EAAElT,cAAc;AAAA,EACfv1B,IAAI;AAAA,EACJ3G,SAASA,CAAC;AAAA,IAACk7B;AAAAA,EAAAA,OAAY;AAAA,IACrB7xB,UAAU6xB,MAAM7xB;AAAAA,IAChB+kC,yBAAyBlT,MAAMmT;AAAAA,IAC/BC,iBAAiB,CAAE;AAAA,IACnBc,WAAWlU,MAAMkU;AAAAA,IACjBzxC,QAAQu9B,MAAMv9B;AAAAA,IACd6B,aAAa07B,MAAM17B;AAAAA,IACnBovC,aAAa;AAAA,EAAA;AAAA,EAEf/N,QAAQ;AAAA,IACNC,KAAK;AAAA,IACL5F,OAAOA,CAAC;AAAA,MAACl7B;AAAAA,IAAAA,OAAc;AAAA,MAACR,aAAaQ,QAAQR;AAAAA,IAAW;AAAA,EAC1D;AAAA,EACAnI,IAAI;AAAA,IACF,oBAAoB;AAAA,MAClBkQ,SAAS,CAAC,iBAAiB;AAAA,IAAA;AAAA,EAE/B;AAAA,EACA80B,SAAS;AAAA,EACTD,QAAQ;AAAA,IACN,cAAc;AAAA,MACZK,QAAQ,CACN;AAAA,QACEt1B,OAAO85B,IAAI,CAAC,qBAAqB,+BAA+B,CAAC;AAAA,QACjEvgC,QAAQ;AAAA,QACR6G,SAAS,CACP,oCACA,wBAAwB;AAAA,MAAA,GAG5B;AAAA,QACEJ,OAAO;AAAA,QACPzG,QAAQ;AAAA,MAAA,CACT;AAAA,MAEHrJ,IAAI;AAAA,QACF,6BAA6B;AAAA,UAC3BkQ,SAAS,CAAC,kCAAkC;AAAA,QAC9C;AAAA,QACA,OAAS,CACP;AAAA,UACE7G,QAAQ;AAAA,UACRyG,OAAO;AAAA,UACPI,SAAS,CACP,oCACA,wBAAwB;AAAA,QAAA,GAG5B;AAAA,UACE7G,QAAQ;AAAA,QACT,CAAA;AAAA,MAAA;AAAA,IAGP;AAAA,IACA,OAAS;AAAA,MACP27B,SAAS;AAAA,MACThlC,IAAI;AAAA,QACF,6BAA6B;AAAA,UAC3BqJ,QAAQ;AAAA,UACRyG,OAAO;AAAA,UACPI,SAAS,CAAC,4BAA4B,wBAAwB;AAAA,QAAA;AAAA,MAElE;AAAA,MACA60B,QAAQ;AAAA,QACN,MAAQ;AAAA,UACN/kC,IAAI;AAAA,YACF,mBAAmB;AAAA,cACjBqJ,QAAQ;AAAA,cACRyG,OAAO85B,IAAI,CAAC,yBAAyB,eAAe,CAAC;AAAA,YAAA;AAAA,UACvD;AAAA,QAEJ;AAAA,QACA,4BAA4B;AAAA,UAC1Bnf,OAAO,CAAC,wBAAwB;AAAA,UAChC2a,QAAQ;AAAA,YACN/7B,QAAQ;AAAA,UAAA;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEJ,CAAC;AAEM,SAAS2uC,eACdC,sBACA;AACA,SAAO,SAAkB,CAACxzC,MAAME,IAAI,GAAgC;AAEhEnB,QAAAA,qBACEy0C,qBAAqB5vC,YAAAA,EAAcM,QAAQR,YAAY/F,UACvD61C,qBAAqB5vC,cAAcM,QAAQrC,MAC7C;AAEA,aAAO,CACL;AAAA,QACEqB,QAAQ;AAAA,UACNhD,MAAM,CAAC,GAAG,CAAC;AAAA,UACXkD,QAAQ;AAAA,QACV;AAAA,QACAnD,OAAO;AAAA,UACLC,MAAM,CAAC,GAAG,CAAC;AAAA,UACXkD,QAAQ;AAAA,QACV;AAAA,QACAouC,aAAa;AAAA,MAAA,CACd;AAKL,QAAItxC,KAAKjB,WAAW;AAClB,aAAO,CAAE;AAGX,QAAI,CAACd,UAAQC,UAAU4B,IAAI,KAAKA,KAAKrC,SAASsB,WAAW;AACvD,aAAO,CAAE;AAGLY,UAAAA,aAAaK,KAAKR,GAAG,CAAC;AAExBG,WAAAA,eAAeb,SACV,KAGFw0C,qBACJ5vC,cACAM,QAAQsuC,gBAAgB7/B,OAAQigC,oBAE3BnyC,MAAM4M,YAAYulC,cAAc,IAE3B5yC,KAAKrC,SAASyE,KACnB,CAAC6lB,GAAG9mB,eACFiU,KAAK3N,OAAOmrC,eAAe1vC,OAAOhD,MAAM,CACtCL,YACAsB,UAAU,CACX,KACDiU,KAAK3N,OAAOmrC,eAAe3yC,MAAMC,MAAM,CAACL,YAAYsB,UAAU,CAAC,CACnE,IAIAV,MAAMgzC,aAAab,gBAAgB;AAAA,MACjC1vC,QAAQ;AAAA,QAAChD;AAAAA,QAAMkD,QAAQ;AAAA,MAAC;AAAA,MACxBnD,OAAO;AAAA,QAACC;AAAAA,QAAMkD,QAAQ;AAAA,MAAA;AAAA,IACvB,CAAA,KAAK3C,MAAMuT,SAAS4+B,gBAAgB1yC,IAAI,CAE5C;AAAA,EACL;AACF;AChWA,MAAMnE,QAAQC,cAAc,oBAAoB,GA+CnC03C,uBAAuBC,WAGlC,SAA8Bz4C,OAAO04C,cAAc;AAC7C,QAAA;AAAA,IACJC;AAAAA,IACAnD;AAAAA,IACAC;AAAAA,IACAmD;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAC;AAAAA,IACAlC;AAAAA,IACAtB;AAAAA,IACAzjC;AAAAA,IACAQ;AAAAA,IACA8iC;AAAAA,IACAtiC;AAAAA,IACA+iC;AAAAA,IACAjjC;AAAAA,IACAvO,WAAW20C;AAAAA,IACXC;AAAAA,IACA9lC;AAAAA,IACA,GAAG+lC;AAAAA,EAAAA,IACD15C,OAEEw0C,qBAAqBtgC,sBAAAA,GACrBS,MAAMlD,OAA8B,IAAI,GACxC,CAACkoC,iBAAiBC,kBAAkB,IAAIroC,SAC5C,IACF,GACM,CAACsoC,iBAAiBC,kBAAkB,IAAIvoC,SAAS,EAAK;AAI1DmnC,sBAAAA,cACA,MAAM/jC,IAAI6K,OACZ;AAEA,QAAMjX,cAAcuI,WAAWtD,kBAAkB,GAC3CwiB,aAAalf,WAAWshC,iBAAiB,GACzC//B,WAAWP,YAAYvJ,aAAcwJ,CAAAA,MACzCA,EAAEpJ,QAAQ;AAAA,IAAC,aAAa;AAAA,EAAA,CAAY,CACtC,GACMH,cAAcuxC,SAEdC,GAAAA,wBAAwBC,YAAY9C,yBAAyB;AAAA,IACjEjT,OAAO;AAAA,MACLmT,kBAAkBA,oBAAoB,CAAE;AAAA,MACxChlC;AAAAA,MACA1L,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,MAC1C6B;AAAAA,MACA4vC,WAAW,CAAC7vC,YAAYG,YAAAA,EAAcC,QAAQ;AAAA,QAACC,OAAO;AAAA,MAAa,CAAA;AAAA,IAAA;AAAA,EACrE,CACD;AACDkJ,cAAYkoC,uBAAwBjoC,CAAAA,QAAMA,IAAE/I,QAAQ4uC,WAAW;AACzDsC,QAAAA,WAAWtF,QACf,MAAMyD,eAAe2B,qBAAqB,GAC1C,CAACA,qBAAqB,CACxB;AAEAr5C,YAAU,MAAM;AACdq5C,0BAAsB9oC,KAAK;AAAA,MACzBV,MAAM;AAAA,MACN6B;AAAAA,IAAAA,CACD;AAAA,KACA,CAAC2nC,uBAAuB3nC,QAAQ,CAAC,GAEpC1R,UAAU,MAAM;AACdq5C,0BAAsB9oC,KAAK;AAAA,MACzBV,MAAM;AAAA,MACN6mC,kBAAkBA,oBAAoB,CAAA;AAAA,IAAA,CACvC;AAAA,EAAA,GACA,CAAC2C,uBAAuB3C,gBAAgB,CAAC,GAK5CzC,QAAQ,MAEFviC,WACK7J,cAEWkuC,kBAClBnuC,aACAisC,oBACAmE,OACF,EAEmBnwC,WAAW,GAC7B,CAACD,aAAaowC,SAASnE,oBAAoBniC,UAAU7J,WAAW,CAAC;AAE9D2xC,QAAAA,gBAAgBhF,YACnBiF,CAAAA,WACE,oBAAA,eAAA,EACC,GAAIA,QACJ,UACA,aACA,aACA,gBACA,aACA,WAEH,CAAA,GACD,CACEzmC,YACAtB,UACAC,aACAQ,aACAQ,gBACAF,WAAW,CAEf,GAEMinC,aAAalF,YAEfmF,CAAAA,cAIC,oBAAA,YAAA,EACC,GAAIA,WACJ,UACA,kBACA,aACA,iBACA,sBAGJ,CACEjoC,UACA0jC,kBACAjjC,aACA8iC,iBACAS,iBAAiB,CAErB,GAEMkE,aAAapF,YAChBn1C,CAAAA,YAA4B,oBAAA,YAAA,KAAeA,QAAS,CAAA,GACrD,CAAA,CACF,GAEMw6C,4BAA4BrF,YAAY,MAAM;AAClD,QAAIqE,gBAAgB;AAClB34C,YAAM,wBAAwBmV,KAAKC,UAAUujC,cAAc,CAAC,EAAE;AAC9D,YAAMiB,sBAAsBztC,mBAC1BwsC,gBACAp2C,eACEoF,YAAY/F,UACZ8F,YAAYG,YAAcM,EAAAA,QAAQrC,OAAO5E,MAAMhB,IACjD,CACF;AACA,UAAI05C,wBAAwB,MAAM;AAChC55C,cACE,mCAAmCmV,KAAKC,UAAUwkC,mBAAmB,CAAC,EACxE;AACMjD,cAAAA,aAAa9rC,aAAa+uC,qBAAqBjyC,WAAW;AAC5DgvC,uBACFl+B,WAAWwO,OAAOtf,aAAagvC,UAAU,GAGpChvC,YAAYsU,WAAW5V,KAAMwzC,OAAMA,EAAElqC,SAAS,eAAe,KAChEjI,YAAY2I,KAAK;AAAA,UACfV,MAAM;AAAA,UACN3L,WAAW41C;AAAAA,QAAAA,CACZ,GAEHjyC,YAAYgW;MAAS;AAAA,IAEzB;AAAA,EAED,GAAA,CAACjW,aAAaixC,gBAAgBhxC,WAAW,CAAC;AAG7C7H,YAAU,MAAM;AACd,UAAMg6C,UAAUpyC,YAAYlI,GAAG,SAAS,MAAM;AAC5C25C,4BAAsB9oC,KAAK;AAAA,QACzBV,MAAM;AAAA,MACP,CAAA,GAEDgqC,0BAA0B;AAAA,IAC3B,CAAA,GAEKI,iBAAiBryC,YAAYlI,GAAG,iBAAiB,MAAM;AAC3Dy5C,yBAAmB,EAAI;AAAA,IACxB,CAAA,GAEKe,iBAAiBtyC,YAAYlI,GAAG,iBAAiB,MAAM;AAC3Dy5C,yBAAmB,EAAK;AAAA,IAAA,CACzB;AAED,WAAO,MAAM;AACXa,cAAQl6C,eACRm6C,eAAen6C,YAAY,GAC3Bo6C,eAAep6C,YAAY;AAAA,IAC7B;AAAA,EAAA,GACC,CAACu5C,uBAAuBzxC,aAAaiyC,yBAAyB,CAAC,GAGlE75C,UAAU,MAAM;AACV64C,sBAAkB,CAACK,mBACrBW,0BAA0B;AAAA,EAE3B,GAAA,CAACX,iBAAiBL,gBAAgBgB,yBAAyB,CAAC;AAGzDM,QAAAA,aAAa3F,YAChB1sC,CAA8D,UAAA;AACzDqwC,QAAAA;AACaA,aAAOrwC,KAAK,MAEZ3E,UACb2E,MAAMu5B,eAAe;AAAA,aAEdv5B,MAAMm5B,YAAYmZ,eAAe;AAEpCC,YAAAA,gBAAAA,GACNvyC,MAAMu5B,eAAe;AAEfn9B,YAAAA,YAAY2D,YAAY3D,YAC1BgD,sBAAsB;AAAA,QACpBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,QAC1CxG,QAAQqI;AAAAA,QACRV,OAAOU,YAAY3D;AAAAA,MAAAA,CACpB,IACDf,QACEkH,WAAWnG,YAAY;AAAA,QAACA;AAAAA,MAAAA,IAAaf;AAE3C,UAAI,CAACkH,UAAU;AACbQ,gBAAQC,KAAK,wCAAwC;AACrD;AAAA,MAAA;AAGFlD,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,MAAMm5B,YAAYmZ;AAAAA,UAClC;AAAA,UACA/vC;AAAAA,QACF;AAAA,QACA7K,QAAQqI;AAAAA,QACRo5B,aAAan5B;AAAAA,MAAAA,CACd;AAAA,IAAA;AAAA,EACH,GAEF,CAACqwC,QAAQvwC,aAAaC,WAAW,CACnC,GAEMyyC,YAAY9F,YACf1sC,CAA0C,YAAA;AACrCswC,QAAAA;AACaA,YAAMtwC,OAAK,MAEX3E,UACb2E,QAAMu5B,eAAe;AAAA,aAEdv5B,QAAMm5B,YAAYmZ,eAAe;AAEpCC,cAAAA,gBAAAA,GACNvyC,QAAMu5B,eAAe;AAErB,YAAMn9B,cAAY0D,YAAYG,YAAAA,EAAcM,QAAQnE,WAC9CmG,aAAWnG,cAAY;AAAA,QAACA,WAAAA;AAAAA,MAAAA,IAAaf;AAE3C,UAAI,CAACkH,YAAU;AACbQ,gBAAQC,KAAK,uCAAuC;AACpD;AAAA,MAAA;AAGFlD,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,QAAMm5B,YAAYmZ;AAAAA,UAClC;AAAA,UACA/vC,UAAAA;AAAAA,QACF;AAAA,QACA7K,QAAQqI;AAAAA,QACRo5B,aAAan5B;AAAAA,MAAAA,CACd;AAAA,IAAA;AAAA,EACH,GAEF,CAACswC,OAAOxwC,aAAaC,WAAW,CAClC,GAGM0yC,cAAc/F,YACjB1sC,CAAgE,YAAA;AAC/D,UAAMlH,QAAQ6B,eACZoF,YAAY/F,UACZ8F,YAAYG,YAAAA,EAAcM,QAAQrC,OAAO5E,MAAMhB,MAC/CuM,qBAAqBiL,IAAI/P,WAAW,CACtC,GAQMxD,QAPUwD,YAAY3D,YACxBgD,sBAAsB;AAAA,MACpBlB,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,MAC1CxG,QAAQqI;AAAAA,MACRV,OAAOU,YAAY3D;AAAAA,IAAAA,CACpB,IACD,OACkBE,MAAMC,QAAQ,CAAE,GAChCm2C,gBAAgBtC,UAAU;AAAA,MAC9BpwC,OAAAA;AAAAA,MACAlH;AAAAA,MACAyD;AAAAA,MACArD,aAAa6yC,mBAAmB7yC;AAAAA,IAAAA,CACjC;AAEGw5C,QAAAA,iBAAiB,CAAC3yC,YAAY3D;AAC1Bm9B,cAAAA,eAAAA,GAGNhS,WAAW9e,KAAK;AAAA,QAACV,MAAM;AAAA,MAAA,CAAU,GAEjCo/B,QAAQC,QAAQsL,aAAa,EAC1BC,KAAM3X,CAAW,aAAA;AAChB5iC,YAAAA,MAAM,8CAA8C4iC,QAAM,GAEtD,CAACA,YAAU,CAACA,SAAO9U,QAAQ;AAC7B9tB,gBAAM,uDAAuD;AAE7D,gBAAMgE,cAAY0D,YAAYG,YAAAA,EAAcM,QAAQnE,WAC9CmG,aAAWnG,cAAY;AAAA,YAACA,WAAAA;AAAAA,UAAAA,IAAaf;AAE3C,cAAI,CAACkH,YAAU;AACbQ,oBAAQC,KAAK,yCAAyC;AACtD;AAAA,UAAA;AAGFlD,sBAAY2I,KAAK;AAAA,YACfV,MAAM;AAAA,YACNuZ,eAAe;AAAA,cACbvZ,MAAM;AAAA,cACNiF,aAAa;AAAA,gBACX2U,cAAc3hB,QAAMsyC;AAAAA,cACtB;AAAA,cACA/vC,UAAAA;AAAAA,YACF;AAAA,YACA7K,QAAQqI;AAAAA,YACRo5B,aAAan5B;AAAAA,UAAAA,CACd;AAAA,QACI,MAAIg7B,UAAO9U,SAChBpmB,YAAY2I,KAAK;AAAA,UACfV,MAAM;AAAA,UACNuZ,eAAe;AAAA,YACbvZ,MAAM;AAAA,YACNqF,QAAQwlC,YAAY;AAAA,cAClBryC,SAAS;AAAA,gBACPkO,cACE3O,YAAYG,YAAY,EAAEM,QAAQkO;AAAAA,gBACpCvQ,QAAQ4B,YAAYG,YAAY,EAAEM,QAAQrC;AAAAA,cAC5C;AAAA,cACAkP,QAAQ4tB,SAAO9U;AAAAA,cACfpY,SAAS;AAAA,gBACPC,aAAa;AAAA,gBACbC,gBAAgB;AAAA,cAAA;AAAA,YAClB,CACD;AAAA,YACDoR,WAAW;AAAA,UACb;AAAA,UACA1nB,QAAQqI;AAAAA,QACT,CAAA,IAEDgD,QAAQC,KACN,wDACAg4B,QACF;AAAA,MAEH,CAAA,EACA6X,MAAOrpC,CACNzG,WAAAA,QAAQC,KAAKwG,KAAK,GAEXA,MACR,EACAspC,QAAQ,MAAM;AACbvrB,mBAAW9e,KAAK;AAAA,UAACV,MAAM;AAAA,QAAA,CAAe;AAAA,MAAA,CACvC;AAAA,aACM/H,QAAMm5B,YAAYmZ,eAAe;AAEpC/Y,cAAAA,eAAAA,GACNv5B,QAAMuyC,gBAAgB;AAEtB,YAAMn2C,cAAY0D,YAAYG,YAAAA,EAAcM,QAAQnE,WAC9CmG,aAAWnG,cAAY;AAAA,QAACA,WAAAA;AAAAA,MAAAA,IAAaf;AAE3C,UAAI,CAACkH,YAAU;AACbQ,gBAAQC,KAAK,yCAAyC;AACtD;AAAA,MAAA;AAGFlD,kBAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,QAAMm5B,YAAYmZ;AAAAA,UAClC;AAAA,UACA/vC,UAAAA;AAAAA,QACF;AAAA,QACA7K,QAAQqI;AAAAA,QACRo5B,aAAan5B;AAAAA,MAAAA,CACd;AAAA,IAAA;AAGH5H,UAAM,uDAAuD;AAAA,EAC/D,GACA,CAAC0H,aAAaswC,SAASrE,oBAAoBxkB,YAAYxnB,WAAW,CACpE,GAEMgzC,gBAAmDrG,YACtD1sC,CAAU,YAAA;AAIT,QAHIgtC,WACFA,QAAQhtC,OAAK,GAEX,CAACA,QAAMgzC,sBAAsB;AACzB52C,YAAAA,cAAY8tC,mBAAmBhH,aAAa6I,kBAAkB;AAEhE3vC,sBAAc,SAChByU,WAAWwO,OAAOtf,aAAalE,OAAOkB,MAAMgD,aAAa,CAAE,CAAA,CAAC,GAC5DA,YAAYgW,SAAS,IAEvBwR,WAAW9e,KAAK;AAAA,QAACV,MAAM;AAAA,QAAW/H,OAAAA;AAAAA,MAAAA,CAAM;AAClC+d,YAAAA,eAAemsB,mBAAmBhH,aAAa6I,kBAAkB;AAEnE3vC,sBAAc2hB,gBAChBje,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACN3L,WAAAA;AAAAA,MAAAA,CACD;AAAA,IAAA;AAAA,EAGP,GACA,CAAC0D,aAAaktC,SAASjtC,aAAagsC,oBAAoBxkB,UAAU,CACpE,GAEM0rB,cAAcvG,YACjB1sC,CAAwD,YAAA;AACnDuwC,QAAAA,WACFA,QAAQvwC,OAAK,GAGXA,QAAMgzC,mBAAmB,KAAKhzC,QAAMkzC,qBAAqB;AAC3D;AAGF,UAAM3wC,aAAW1C,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,QAAMm5B;AAAAA,IAAAA,CACd;AAEG52B,kBACFzC,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNxF,UAAAA;AAAAA,MACF;AAAA,MACA7K,QAAQqI;AAAAA,MACRo5B,aAAan5B;AAAAA,IAAAA,CACd;AAAA,EAAA,GAGL,CAACuwC,SAASzwC,aAAaC,WAAW,CACpC,GAEMozC,eAAkDzG,YACrD1sC,CAAU,YAAA;AACL+sC,cACFA,OAAO/sC,OAAK,GAETA,QAAMkzC,qBAAqB,KAC9B3rB,WAAW9e,KAAK;AAAA,MAACV,MAAM;AAAA,MAAW/H,OAAAA;AAAAA,IAAAA,CAAM;AAAA,EAAA,GAG5C,CAACunB,YAAYwlB,MAAM,CACrB,GAEMqG,sBAAsB1G,YACzB1sC,CAAsB,YAAA;AACjBmwC,qBACFA,cAAcnwC,OAAK;AAAA,KAGvB,CAACmwC,aAAa,CAChB,GAkBMkD,oBAAoB3G,YAAY,MAAM;AAC1C,QAAI,CAAC3sC,YAAY3D;AACf;AAEF,UAAMguB,OAAOuY,YAAY2Q,yBAAyBvzC,WAAW,GACvD;AAAA,MAACwzC;AAAAA,IAAAA,IAAiBnpB;AAExB,QAAIle,IAAI6K,YAAYw8B;AAClB;AAGF,UAAMC,eADS7Q,YAAYxgC,UAAUpC,WAAW,EACpBmjC,aAAa;AACrC,QAAA,CAACsQ,gBAAgBA,aAAa5G,eAAe;AAC/C;AAEI6G,UAAAA,mBAAmBD,aAAa3G,WAAW,CAAC;AAC9C,QAAA;AACF,YAAM6G,cAAc/Q,YAAYgR,WAC9B5zC,aACAA,YAAY3D,SACd;AACA,OACEs3C,YAAYE,gBAAgBH,iBAAiBG,eAC7CF,YAAYG,cAAcJ,iBAAiBI,eAE3Cz7C,MAAM,6CAA6C,GAEnDo7C,cAAcM,gBAEdN,GAAAA,aAAaO,SAASL,WAAW;AAAA,IAAA,QAE7B;AACNt7C,YAAM,qDAAqD,GAE3DyY,WAAWiJ,SAAS/Z,WAAW,GAE3BA,YAAY/F,SAASsB,SAAS,KAChCuV,WAAWwO,OAAOtf,aAAa,CAAC,GAAG,CAAC,CAAC,GAEvCA,YAAYgW,SAAS;AAAA,IAAA;AAAA,EACvB,GACC,CAAC7J,KAAKnM,WAAW,CAAC;AAIrB7H,YAAU,MAAM;AACd,QAAIg5C,iBAAiB;AACb8C,YAAAA,mBAAmB,IAAIC,iBAAiBZ,iBAAiB;AAC/DW,aAAAA,iBAAiBE,QAAQhD,iBAAiB;AAAA,QACxCiD,mBAAmB;AAAA,QACnBxqC,YAAY;AAAA,QACZyqC,eAAe;AAAA,QACfC,WAAW;AAAA,QACXC,SAAS;AAAA,MACV,CAAA,GACM,MAAM;AACXN,yBAAiBO,WAAW;AAAA,MAC9B;AAAA,IAAA;AAAA,EACF,GAEC,CAAClB,mBAAmBnC,eAAe,CAAC;AAEjCsD,QAAAA,gBAAgB9H,YACnB1sC,CAAyC,YAAA;AACpCzI,UAAMk9C,aACRl9C,MAAMk9C,UAAUz0C,OAAK,GAElBA,QAAMgzC,mBAAAA,KACTjzC,YAAYsuC,eAAeruC,OAAK,GAE7BA,QAAMgzC,mBAAmB,KAC5BlzC,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNiF,aAAa;AAAA,UACX1F,KAAKtH,QAAMsH;AAAAA,UACX0oB,MAAMhwB,QAAMgwB;AAAAA,UACZZ,QAAQpvB,QAAMovB;AAAAA,UACdC,SAASrvB,QAAMqvB;AAAAA,UACfC,SAAStvB,QAAMsvB;AAAAA,UACfC,UAAUvvB,QAAMuvB;AAAAA,QAAAA;AAAAA,MAEpB;AAAA,MACA73B,QAAQqI;AAAAA,MACRo5B,aAAan5B;AAAAA,IAAAA,CACd;AAAA,EAAA,GAGL,CAACzI,OAAOuI,aAAaC,WAAW,CAClC,GAEM20C,cAAchI,YACjB1sC,CAAyC,YAAA;AACpCzI,UAAMo9C,WACRp9C,MAAMo9C,QAAQ30C,OAAK,GAEhBA,QAAMgzC,mBAAAA,KACTlzC,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNiF,aAAa;AAAA,UACX1F,KAAKtH,QAAMsH;AAAAA,UACX0oB,MAAMhwB,QAAMgwB;AAAAA,UACZZ,QAAQpvB,QAAMovB;AAAAA,UACdC,SAASrvB,QAAMqvB;AAAAA,UACfC,SAAStvB,QAAMsvB;AAAAA,UACfC,UAAUvvB,QAAMuvB;AAAAA,QAAAA;AAAAA,MAEpB;AAAA,MACA73B,QAAQqI;AAAAA,MACRo5B,aAAan5B;AAAAA,IAAAA,CACd;AAAA,EAAA,GAGL,CAACzI,OAAOuI,aAAaC,WAAW,CAClC,GAEM60C,iCAAiCzI,QAAQ,MAAM;AAEnD,QAAI6E,4BAA4B31C;AAIhC,aAAI21C,4BAA4B,OACvB6D,OAGF,CAACpJ,SAAsBrpC,aAAoB;AAChD4uC,gCAAwBjF,oBAAoB3pC,QAAQ;AAAA,MACtD;AAAA,EAAA,GACC,CAAC2pC,oBAAoBiF,uBAAuB,CAAC;AAKhD94C,YAAU,MAAM;AACV6e,QAAAA,UAAU4rB,YAAYthC,UACxBtB,aACAA,WACF,GACAoxC,mBAAmBjlC,IAAI6K,OAAO;AAAA,KAC7B,CAAChX,aAAamM,GAAG,CAAC,GAErBhU,UAAU,MAAM;AACd,UAAMgK,WAASygC,YAAYxgC,UAAUpC,WAAW,GAE1C2wC,cAAYA,MAAM;AACtB5wC,kBAAY2I,KAAK;AAAA,QAACV,MAAM;AAAA,MAAA,CAAU;AAAA,IACpC,GACM8oC,WAASA,MAAM;AACnB/wC,kBAAY2I,KAAK;AAAA,QAACV,MAAM;AAAA,MAAA,CAAO;AAAA,IACjC;AAEO1F,WAAAA,SAAAA,SAASyyC,iBAAiB,WAAWpE,WAAS,GACrDxuC,SAAOG,SAASyyC,iBAAiB,QAAQjE,QAAM,GAExC,MAAM;AACJxuC,eAAAA,SAAS0yC,oBAAoB,WAAWrE,WAAS,GACxDxuC,SAAOG,SAAS0yC,oBAAoB,QAAQlE,QAAM;AAAA,IACpD;AAAA,EAAA,GACC,CAAC9wC,aAAaD,WAAW,CAAC;AAEvBk1C,QAAAA,kBAAkBtI,YACrB1sC,CAA2C,YAAA;AAG1C,QAFAwwC,cAAcxwC,OAAK,GAEfA,QAAMgzC,mBAAmB,KAAKhzC,QAAMkzC,qBAAqB;AAC3D;AAGF,UAAM3wC,aAAW1C,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,QAAMm5B;AAAAA,IAAAA,CACd;AAED,QAAI,CAAC52B,YAAU;AACbQ,cAAQC,KAAK,6CAA6C;AAC1D;AAAA,IAAA;AAGFlD,WAAAA,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNgQ,QAAQxV;AAAAA,IAAAA,CACT,GAEDzC,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNiF,aAAa;AAAA,UACXxK,SAASxC,QAAMwC;AAAAA,UACfC,SAASzC,QAAMyC;AAAAA,UACfkf,cAAc3hB,QAAM2hB;AAAAA,QACtB;AAAA,QACApf,UAAAA;AAAAA,MACF;AAAA,MACA7K,QAAQqI;AAAAA,IACT,CAAA,GAGM;AAAA,EAAA,GAET,CAACywC,aAAa1wC,aAAaC,WAAW,CACxC,GAEMk1C,aAAavI,YAChB1sC,CAA2C,YAAA;AAC1CywC,QAAAA,SAASzwC,OAAK,GAEVA,EAAMgzC,QAAAA,wBAAwBhzC,QAAMkzC,0BAUpC,CANarzC,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,QAAMm5B;AAAAA,IAAAA,CACd;AAMDr5B,aAAAA,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,QAAM2hB;AAAAA,UAAAA;AAAAA,QAExB;AAAA,QACAjqB,QAAQqI;AAAAA,MACT,CAAA,GAGM;AAAA,EAAA,GAET,CAAC0wC,QAAQ3wC,aAAaC,WAAW,CACnC,GAEMm1C,gBAAgBxI,YACnB1sC,CAA2C,aAAA;AAG1C,QAFA0wC,YAAY1wC,QAAK,GAEbA,WAAMgzC,wBAAwBhzC,SAAMkzC;AAIxCpzC,aAAAA,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,SAAM2hB;AAAAA,UAAAA;AAAAA,QAExB;AAAA,QACAjqB,QAAQqI;AAAAA,MACT,CAAA,GAGM;AAAA,EAAA,GAET,CAAC2wC,WAAW5wC,aAAaC,WAAW,CACtC,GAEMo1C,kBAAkBzI,YACrB1sC,CAA2C,aAAA;AAG1C,QAFA2wC,cAAc3wC,QAAK,GAEfA,SAAMgzC,mBAAmB,KAAKhzC,SAAMkzC,qBAAqB;AAC3D;AAGF,UAAM3wC,aAAW1C,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,SAAMm5B;AAAAA,IAAAA,CACd;AAEI52B,QAAAA;AAILzC,aAAAA,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,SAAM2hB;AAAAA,UACtB;AAAA,UACApf,UAAAA;AAAAA,QACF;AAAA,QACA7K,QAAQqI;AAAAA,MACT,CAAA,GAGM;AAAA,EAAA,GAET,CAAC4wC,aAAa7wC,aAAaC,WAAW,CACxC,GAEMq1C,iBAAiB1I,YACpB1sC,CAA2C,aAAA;AAG1C,QAFA4wC,aAAa5wC,QAAK,GAEdA,SAAMgzC,mBAAmB,KAAKhzC,SAAMkzC,qBAAqB;AAC3D;AAGF,UAAM3wC,aAAW1C,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,SAAMm5B;AAAAA,IAAAA,CACd;AAEI52B,QAAAA;AAILzC,aAAAA,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,SAAM2hB;AAAAA,UACtB;AAAA,UACA/Z,YAAY9H,YAAYG,YAAY,EAAEM,QAAQw8B,cAAchlB;AAAAA,UAC5DxV,UAAAA;AAAAA,QACF;AAAA,QACA7K,QAAQqI;AAAAA,QACRo5B,aAAan5B;AAAAA,MACd,CAAA,GAGM;AAAA,EAAA,GAET,CAAC4wC,YAAY9wC,aAAaC,WAAW,CACvC,GAEMs1C,aAAa3I,YAChB1sC,CAA2C,aAAA;AAG1C,QAFA6wC,SAAS7wC,QAAK,GAEVA,SAAMgzC,mBAAmB,KAAKhzC,SAAMkzC,qBAAqB;AAC3D;AAGF,UAAM3wC,aAAW1C,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,SAAMm5B;AAAAA,IAAAA,CACd;AAED,QAAI,CAAC52B,YAAU;AACbQ,cAAQC,KAAK,wCAAwC;AACrD;AAAA,IAAA;AAGFlD,WAAAA,YAAY2I,KAAK;AAAA,MACfV,MAAM;AAAA,MACNuZ,eAAe;AAAA,QACbvZ,MAAM;AAAA,QACNiF,aAAa;AAAA,UACX2U,cAAc3hB,SAAM2hB;AAAAA,QACtB;AAAA,QACA/Z,YAAY9H,YAAYG,YAAY,EAAEM,QAAQw8B,cAAchlB;AAAAA,QAC5DxV,UAAAA;AAAAA,MACF;AAAA,MACA7K,QAAQqI;AAAAA,MACRo5B,aAAan5B;AAAAA,IACd,CAAA,GAGM;AAAA,EAAA,GAET,CAAC6wC,QAAQ/wC,aAAaC,WAAW,CACnC,GAEMu1C,kBAAkB5I,YACrB1sC,CAA2C,aAAA;AAC1C8wC,QAAAA,cAAc9wC,QAAK,GAEfA,EAAMgzC,SAAAA,wBAAwBhzC,SAAMkzC,0BAUpC,CANarzC,iBAAiB;AAAA,MAChCC;AAAAA,MACAC;AAAAA,MACAC,OAAOA,SAAMm5B;AAAAA,IAAAA,CACd;AAMDr5B,aAAAA,YAAY2I,KAAK;AAAA,QACfV,MAAM;AAAA,QACNuZ,eAAe;AAAA,UACbvZ,MAAM;AAAA,UACNiF,aAAa;AAAA,YACX2U,cAAc3hB,SAAM2hB;AAAAA,UAAAA;AAAAA,QAExB;AAAA,QACAjqB,QAAQqI;AAAAA,MACT,CAAA,GAGM;AAAA,EAET,GAAA,CAAC+wC,aAAahxC,aAAaC,WAAW,CACxC;AAEKgsC,SAAAA,qBAIEqF,kBAAkB,OACvB;AAAA,IAACmE;AAAAA,IAAA;AAAA,MACC,GAAItE;AAAAA,MACJ,kBAAgBrnC;AAAAA,MAChB,WAAW;AAAA,MACX,WAAWqnC,UAAUuE,aAAa;AAAA,MAClC;AAAA,MACA,QAAQrC;AAAAA,MACR,QAAQd;AAAAA,MACR,OAAOG;AAAAA,MACP,SAASS;AAAAA,MACT,kBAAkBG;AAAAA,MAClB,aAAa4B;AAAAA,MACb,QAAQC;AAAAA,MACR,WAAWC;AAAAA,MACX,aAAaC;AAAAA,MACb,YAAYC;AAAAA,MACZ,QAAQC;AAAAA,MACR,aAAaC;AAAAA,MACb,SAASvC;AAAAA,MACT,WAAWyB;AAAAA,MACX,SAASE;AAAAA,MACT,SAASjC;AAAAA,MACT;AAAA,MAGA,mBAAmBp3C;AAAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA,yBAAyBu5C;AAAAA,IAAAA;AAAAA,EAAAA,IAjCpB;AAoCX,CAAC;AAED7E,qBAAqB3F,cAAc;ACljCnC,SAAwBqL,YACtBC,SACW;AACLxpC,QAAAA,MAAMypC,MAAM3sC,OAA+B,IAAI;AAEhDkD,SAAAA,IAAI6K,YACP7K,IAAI6K,UAAU;AAAA,IAAC6+B,UAAUF,QAAQ;AAAA,EAAA,IAG5BxpC,IAAI6K,QAAQ6+B;AACrB;AC8BO,SAAAC,eAAAt+C,OAAA;AAAAC,QAAAA,IAAAC,EAAA,EAAA;AAAAK,MAAAA;AAAAN,IAAA,CAAA,MAAAD,MAAAu+C,iBACoDh+C,KAAAA,MAAA;AACvD,UAAAi+C,iBAAuBrN,qBAAqBnxC,MAAKu+C,aAAc,GAC/D/J,yBAAA7B,mBAAA;AAAA,MAAAxyC,QACUq+C,eAAcr+C;AAAAA,IAAAA,CAAA;AACgB,WAAA;AAAA,MAAAq+C;AAAAA,MAAAhK;AAAAA,IAAA;AAAA,EAGzCv0C,GAAAA,EAAA,CAAA,IAAAD,MAAAu+C,eAAAt+C,OAAAM,MAAAA,KAAAN,EAAA,CAAA;AAPD,QAAA;AAAA,IAAAu+C,gBAAAC;AAAAA,IAAAjK,oBAAAkK;AAAAA,EAAAA,IAA6CR,YAAY39C,EAOxD;AAACG,MAAAA;AAAAT,IAAAw+C,CAAAA,MAAAA,iBAAA3V,OAAAvgC,eAAAtI,EAAA,CAAA,MAAAw+C,iBAAA3V,OAAAwI,iBAAArxC,EAAA,CAAA,MAAAw+C,iBAAA3V,OAAA9Y,cAAA/vB,SAAAw+C,iBAAA3V,OAAAyI,aAAAtxC,EAAAw+C,CAAAA,MAAAA,iBAAAr+B,iBAEQ1f,KAAAA,MAAA;AACR,UAAAsyC,gBAAA,CAAA;AAA2C,eAEtCxyC,gBAAsBg+C,iBAAcp+B;AAC1B/X,oBAAAA,KAAM7H,cAAc;AAGnCg+C,WAAAA,iBAAc1V,OAAAvgC,YAAA/C,SACdg5C,iBAAc1V,OAAAwI,cAAA9rC,MAA4B,GAC1Cg5C,iBAAc1V,OAAA9Y,WAAAxqB,MACdg5C,GAAAA,iBAAc1V,OAAAyI,UAAA/rC,MAAAA,GAAyB,MAAA;AAAA,iBAGhC/E,eAAqBuyC;AACZ,oBAAA;AAGdv+B,gBAAU+pC,iBAAc1V,OAAAvgC,WAAmB,GAC3CkM,UAAU+pC,iBAAc1V,OAAAwI,aAAqB,GAC7C78B,UAAU+pC,iBAAc1V,OAAA9Y,UAAkB,GAC1Cvb,UAAU+pC,iBAAc1V,OAAAyI,SAAiB;AAAA,IAAC;AAAA,EAAA,GAE7CtxC,EAAAw+C,CAAAA,IAAAA,iBAAA3V,OAAAvgC,aAAAtI,EAAAw+C,CAAAA,IAAAA,iBAAA3V,OAAAwI,eAAArxC,EAAAw+C,CAAAA,IAAAA,iBAAA3V,OAAA9Y,YAAA/vB,EAAAw+C,CAAAA,IAAAA,iBAAA3V,OAAAyI,WAAAtxC,EAAA,CAAA,IAAAw+C,iBAAAr+B,eAAAngB,OAAAS,MAAAA,KAAAT,EAAA,CAAA;AAAA8Q,MAAAA;AAAA9Q,WAAAw+C,oBAAE1tC,MAACytC,gBAAc,GAACv+C,OAAAw+C,kBAAAx+C,OAAA8Q,MAAAA,KAAA9Q,EAAA,CAAA,GAtBnBU,UAAUD,IAsBPqQ,EAAgB;AAACgD,MAAAA;AAAA9T,IAAA,EAAA,MAAAy+C,qBAAA5L,WAMJ/+B,KAAAu+B,CAAA,WAAA;AACUQ,yBAAAA,QAAApqB,KAAc4pB,MAAM;AAAA,EACvCryC,GAAAA,EAAA,EAAA,IAAAy+C,qBAAA5L,SAAA7yC,QAAA8T,MAAAA,KAAA9T,EAAA,EAAA;AAAA0+C,MAAAA;AAAA1+C,IAAAw+C,EAAAA,MAAAA,iBAAA3V,OAAA9Y,cAAA/vB,EAAA,EAAA,MAAA8T,MAJH4qC,KAAC,oBAAA,sBAAA,EACa,YAAAH,iBAAc1V,OAAA9Y,YAChB,UAAAjc,GAGV,CAAA,GAAA9T,EAAAw+C,EAAAA,IAAAA,iBAAA3V,OAAA9Y,YAAA/vB,QAAA8T,IAAA9T,QAAA0+C,MAAAA,KAAA1+C,EAAA,EAAA;AAAA2+C,MAAAA;AAAA3+C,IAAA,EAAA,MAAAw+C,iBAAA3V,OAAAvgC,eAAAtI,EAAA,EAAA,MAAAD,MAAAyC,YAUMm8C,KAAA,oBAAC,uCACc,aAAAJ,iBAAc1V,OAAAvgC,aAE1BvI,UAAAA,MAAKyC,SACR,CAAA,GAAsCxC,EAAAw+C,EAAAA,IAAAA,iBAAA3V,OAAAvgC,aAAAtI,EAAA,EAAA,IAAAD,MAAAyC,UAAAxC,QAAA2+C,MAAAA,KAAA3+C,EAAA,EAAA;AAAA4+C,MAAAA;AAAA5+C,IAAAy+C,EAAAA,MAAAA,wBAAAz+C,UAAA2+C,MALxCC,KAAA,oBAAA,0BAAA,UAAA,EAA2CrK,OAAAA,sBACzCoK,UAKF,GAAA,CAAA,GAAqC3+C,QAAAy+C,sBAAAz+C,QAAA2+C,IAAA3+C,QAAA4+C,MAAAA,KAAA5+C,EAAA,EAAA;AAAA6+C,MAAAA;AAAA7+C,IAAAw+C,EAAAA,MAAAA,iBAAAt+C,OAAA0b,UAAArT,YAAA6sB,gBAAAp1B,UAAAw+C,iBAAAt+C,OAAA0b,UAAArT,YAAAsT,YAAA7b,EAAA,EAAA,MAAA4+C,MAZvCC,yBAAC,OACS,EAAA,QAAAN,iBAAcr+C,OAAA0b,UAAArT,YAAAsT,UAEpB,cAAA0iC,iBAAcr+C,OAAA0b,UAAArT,YAAA6sB,cAGhBwpB,UAOF,GAAA,CAAA,GAAQ5+C,EAAA,EAAA,IAAAw+C,iBAAAt+C,OAAA0b,UAAArT,YAAA6sB,cAAAp1B,EAAA,EAAA,IAAAw+C,iBAAAt+C,OAAA0b,UAAArT,YAAAsT,UAAA7b,QAAA4+C,IAAA5+C,QAAA6+C,MAAAA,KAAA7+C,EAAA,EAAA;AAAA8+C,MAAAA;AAAA9+C,IAAAw+C,EAAAA,MAAAA,iBAAA3V,OAAA9Y,cAAA/vB,EAAA,EAAA,MAAA6+C,MAdVC,KAAmC,oBAAA,kBAAA,UAAA,EAAA,OAAAP,iBAAc1V,OAAA9Y,YAC/C8uB,UAAAA,GAAAA,CAcF,GAA6B7+C,EAAAw+C,EAAAA,IAAAA,iBAAA3V,OAAA9Y,YAAA/vB,QAAA6+C,IAAA7+C,QAAA8+C,MAAAA,KAAA9+C,EAAA,EAAA;AAAA++C,MAAAA;AAAA/+C,IAAAw+C,EAAAA,MAAAA,iBAAA3V,OAAAvgC,eAAAtI,EAAA,EAAA,MAAA8+C,MAhB/BC,KAAoC,oBAAA,mBAAA,UAAA,EAAA,OAAAR,iBAAc1V,OAAAvgC,aAChDw2C,UAAAA,GAAAA,CAgBF,GAA8B9+C,EAAAw+C,EAAAA,IAAAA,iBAAA3V,OAAAvgC,aAAAtI,QAAA8+C,IAAA9+C,QAAA++C,MAAAA,KAAA/+C,EAAA,EAAA;AAAAg/C,MAAAA;AAAAh/C,SAAAA,EAAA,EAAA,MAAAw+C,iBAAAt+C,UAAAF,EAAA,EAAA,MAAA0+C,MAAA1+C,EAAA,EAAA,MAAA++C,MAxBhCC,MAA+B,qBAAA,cAAA,UAAA,EAAA,OAAAT,iBAAcr+C,QAC3Cw+C,UAAAA;AAAAA,IAAAA;AAAAA,IAMAK;AAAAA,EAAAA,GAkBF,GAAyB/+C,EAAA,EAAA,IAAAw+C,iBAAAt+C,QAAAF,QAAA0+C,IAAA1+C,QAAA++C,IAAA/+C,QAAAg/C,OAAAA,MAAAh/C,EAAA,EAAA,GAzBzBg/C;AAyByB;","x_google_ignoreList":[34,40]}